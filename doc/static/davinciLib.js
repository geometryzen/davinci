Sk.builtinFiles={"files": {"src/lib/pythonds/trees/binheap.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n", "src/lib/pythonds/basic/stack.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#stack.py\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def push(self, item):\r\n        self.items.append(item)\r\n\r\n    def pop(self):\r\n        return self.items.pop()\r\n\r\n    def peek(self):\r\n        return self.items[len(self.items)-1]\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n\r\n", "src/lib/pythonds/trees/bst.py": "#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    '''\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError('Error, key not in tree')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        \"\"\"The standard inorder traversal of a binary tree.\"\"\"\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n", "src/lib/c3ga/__init__.js": "/**\n * Geometric Algebra (c3ga) module for DaVinci Python.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n  /**\n   * Symbolic constants representing the Python classes or functions that are exported by this module.\n   * These are captured here for both consistency and self-documentation.\n   */\n  var CONFORMAL_3    = \"Conformal3\";    // Multivector of 5-dimensional Conformal space to represent Euclidean 3D Motions.\n\n  // The following symbolic constant simulates a zero scalar argument for convenience functions.\n  var ARG_ZERO      = Sk.builtin.assk$(0, Sk.builtin.nmber.float$);\n\n  var mod = {};\n\n  function isNumber(x)    { return typeof x === 'number'; }\n  function isString(x)    { return typeof x === 'string'; }\n  function isBoolean(x)   { return typeof x === 'boolean'; }\n  function isNull(x)      { return typeof x === 'object' && x === null; }\n  function isUndefined(x) { return typeof x === 'undefined'; }\n  function isDefined(x)   { return typeof x !== 'undefined'; }\n\n  function remapC3ToPy(x0, x1, x2, x3) {\n    return Sk.misceval.callsim(mod[CONFORMAL_3],\n      Sk.builtin.assk$(x0, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x1, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x2, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x3, Sk.builtin.nmber.float$));\n  }\n\n  mod[CONFORMAL_3] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, x0, x1, x2, x3) {\n      x0 = Sk.ffi.remapToJs(x0);\n      x1 = Sk.ffi.remapToJs(x1);\n      x2 = Sk.ffi.remapToJs(x2);\n      x3 = Sk.ffi.remapToJs(x3);\n      self.tp$name = CONFORMAL_3;\n      self.v = [x0, x1, x2, x3];\n    });\n    $loc.__add__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" + \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" - \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" * \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__xor__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rxor__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" ^ \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__ixor__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__lshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rlshift__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" << \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__ilshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__rshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rrshift__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" >> \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__irshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__or__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      throw new Error(\"Under construction or\");\n    });\n    $loc.nb$negative = function() {\n      var self = Sk.ffi.remapToJs(this);\n      return remapC3ToPy(-self[0], -self[1], -self[2], -self[3]);\n    };\n    $loc.nu$pos = function() {\n      return this;\n    };\n    $loc.nb$invert = function() {\n      var self = Sk.ffi.remapToJs(this);\n      return remapC3ToPy(self[0], self[1], self[2], -self[3]);\n    };\n    $loc.__div__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      throw new Error(\"Under construction\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      return new Sk.builtin.str(CONFORMAL_3 + \"(\" + mv.join(\", \") + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      if (isDefined(mv)) {\n        return new Sk.builtin.str(bladeSTR.stringFromCoordinates([mv[0], mv[1], mv[2], mv[3]], [\"1\", \"i\", \"j\", \"I\"]));\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + CONFORMAL_3 + \"'>\");\n      }\n    });\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      throw new Error(\"Under construction eq\");\n    });\n\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      throw new Error(\"Under construction ne\");\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n      if (key === 'w') {\n        return Sk.builtin.assk$(self.v.coordinate(0), Sk.builtin.nmber.float$);\n      }\n      else if (key === 'x') {\n        return Sk.builtin.assk$(self.v.coordinate(1), Sk.builtin.nmber.float$);\n      }\n      else if (key === 'y') {\n        return Sk.builtin.assk$(self.v.coordinate(2), Sk.builtin.nmber.float$);\n      }\n      else if (key === 'xy') {\n        return Sk.builtin.assk$(self.v.coordinate(3), Sk.builtin.nmber.float$);\n      }\n      else {\n        throw new Error(key + \" is not a valid \" + CONFORMAL_3 + \" attribute.\");\n      }\n    });\n  }, CONFORMAL_3, []);\n\n  return mod;\n}\n", "src/lib/time/__init__.js": "\n/*\n\tBarebones implementation of the Python time package.\n\n\tFor now, only the time() function is implemented.\n*/\n \nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    mod.time = new Sk.builtin.func(function() {\n\t  return Sk.builtin.assk$(new Date().getTime() / 1000, undefined);\n    });\n\n    return mod;\n}\n", "src/lib/image/__init__.js": "var ImageMod; // the single identifier needed in the global scope\n\nif (! ImageMod) {\n    ImageMod = { };\n    ImageMod.canvasLib = [];\n}\n\n//  todo create an empty image by reading image data from a blank canvas of the appropriate size\n\nvar $builtinmodule = function(name) {\n    var mod = {};\n\n    var image = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,imageId) {\n            self.image = document.getElementById(imageId.v);\n            if (self.image == null) {\n                throw \"There is no image on this page named: \" + imageId.v;\n            }\n            self.width = self.image.width;\n            self.height = self.image.height;\n            self.canvas = document.createElement(\"canvas\");\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.ctx = self.canvas.getContext(\"2d\");\n            self.ctx.drawImage(self.image,0,0)\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n        $loc.getPixel = new Sk.builtin.func(function(self,x,y) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            var red = self.imagedata.data[index]\n            var green = self.imagedata.data[index+1]\n            var blue = self.imagedata.data[index+2]\n            return Sk.misceval.callsim(mod.Pixel,red,green,blue);\n        });\n\n        $loc.setPixel = new Sk.builtin.func(function(self, x, y, pix) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            self.imagedata.data[index] = Sk.misceval.callsim(pix.getRed,pix);\n            self.imagedata.data[index+1] = Sk.misceval.callsim(pix.getGreen,pix);\n            self.imagedata.data[index+2] = Sk.misceval.callsim(pix.getBlue,pix);\n            self.imagedata.data[index+3] = 255;\n        });\n\n        $loc.getHeight = new Sk.builtin.func(function(self) {\n            return self.image.height;\n        });\n\n        $loc.getWidth = new Sk.builtin.func(function(self,titlestring) {\n            return self.image.width;\n        });\n\n        $loc.draw = new Sk.builtin.func(function(self,win,ulx,uly) {\n\t\t\twin = Sk.builtin.asnum$(win);\n\t\t\tulx = Sk.builtin.asnum$(ulx);\n\t\t\tuly = Sk.builtin.asnum$(uly);\n            var can = Sk.misceval.callsim(win.getWin,win);\n            var ctx = can.getContext(\"2d\");\n            //ctx.putImageData(self.imagedata,0,0,0,0,self.imagedata.width,self.imagedata.height);\n            if (! ulx) {\n                ulx = 0;\n                uly = 0;\n            }\n            ctx.putImageData(self.imagedata,ulx,uly);\n        });\n\n        // toList\n\n    }\n\n    mod.Image = Sk.misceval.buildClass(mod, image, 'Image', []);\n\n    var eImage = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            self.width = Sk.builtin.asnum$(width);\n            self.height = Sk.builtin.asnum$(height);\n            self.canvas = document.createElement(\"canvas\");\n            self.ctx = self.canvas.getContext('2d');\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n    }\n\n    mod.EmptyImage = Sk.misceval.buildClass(mod, eImage, 'EmptyImage', [mod.Image]);\n\n    // create a ListImage object\n\n    \n    var pixel = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,r,g,b) {\n            self.red = Sk.builtin.asnum$(r);\n            self.green = Sk.builtin.asnum$(g);\n            self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.getRed = new Sk.builtin.func(function(self) {\n           return self.red;\n        });\n\n        $loc.getGreen = new Sk.builtin.func(function(self) {\n           return self.green;\n        });\n\n        $loc.getBlue = new Sk.builtin.func(function(self) {\n           return self.blue;\n        });\n\n        $loc.setRed = new Sk.builtin.func(function(self,r) {\n           self.red = Sk.builtin.asnum$(r);\n        });\n\n        $loc.setGreen = new Sk.builtin.func(function(self,g) {\n           self.green = Sk.builtin.asnum$(g);\n        });\n\n        $loc.setBlue = new Sk.builtin.func(function(self,b) {\n           self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.__getitem__ = new Sk.builtin.func(function(self,k) {\n\t\t   k = Sk.builtin.asnum$(k);\n           if(k == 0) {\n               return self.red;\n           } else if (k == 1) {\n               return self.green;\n           } else if (k == 2) {\n               return self.blue;\n           }\n        });\n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            return \"[\" + self.red + \",\" + self.green + \",\" + self.blue + \"]\"\n        });\n        \n        //getColorTuple\n        $loc.getColorTuple = new Sk.builtin.func(function(self,x,y) {\n\n        });\n\n        //setRange -- change from 0..255 to 0.0 .. 1.0\n        $loc.setRange = new Sk.builtin.func(function(self,mx) {\n            self.max = Sk.builtin.asnum$(mx);\n        });\n\n    }\n    mod.Pixel = Sk.misceval.buildClass(mod, pixel, 'Pixel', []);\n\n\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            var currentCanvas = ImageMod.canvasLib[Sk.canvas];\n            if (currentCanvas === undefined) {\n                self.theScreen = document.getElementById(Sk.canvas);\n                if (width !== undefined) {\n                    self.theScreen.height = height;\n                    self.theScreen.width = width;\n                }\n\n                ImageMod.canvasLib[Sk.canvas] = self.theScreen;\n            } else {\n                self.theScreen = currentCanvas;\n                self.theScreen.height = self.theScreen.height;\n            }\n            self.theScreen.style.display = \"block\";\n        });\n\n        $loc.getWin = new Sk.builtin.func(function(self) {\n           return self.theScreen;\n        });\n\n        // exitonclick\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            var canvas_id = self.theScreen.id;\n            self.theScreen.onclick = function() {\n                document.getElementById(canvas_id).style.display = 'none';\n                document.getElementById(canvas_id).onclick = null;\n                delete ImageMod.canvasLib[canvas_id];\n            }\n\n        });\n        //getMouse\n    }\n\n    mod.ImageWin = Sk.misceval.buildClass(mod, screen, 'ImageWin', []);\n\n    return mod\n}\n", "src/lib/browser/__init__.js": "/*\n * browser Python module\n *\n * Exposes the window and document variables.\n */\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var CANVAS_GRADIENT_CLASS       = \"CanvasGradient\";\n  var CANVAS_RENDERING_CONTEXT_2D = \"CanvasRenderingContext2D\";\n  var DOCUMENT_CLASS              = \"Document\";\n  var EVENT                       = \"Event\";\n  var NODE                        = \"Node\";\n  var WINDOW_CLASS                = \"Window\";\n  \n  var PROP_ALT_KEY                          = \"altKey\";\n  var PROP_ANIMATION_TIME                   = \"animationTime\";\n  var PROP_BODY                             = \"body\";\n  var PROP_BUBBLES                          = \"bubbles\";\n  var PROP_BUTTON                           = \"button\";\n  var PROP_CANCELABLE                       = \"cancelable\";\n  var PROP_CLIENT_X                         = \"clientX\";\n  var PROP_CLIENT_Y                         = \"clientY\";\n  var PROP_CTRL_KEY                         = \"ctrlKey\";\n  var PROP_CURRENT_TRANSFORM                = \"currentTransform\";\n  var PROP_DEFAULT_PREVENTED                = \"defaultPrevented\";\n  var PROP_DEVICE_PIXEL_RATIO               = \"devicePixelRatio\";\n  var PROP_DIR                              = \"dir\";\n  var PROP_DOCUMENT                         = \"document\";\n  var PROP_FONT                             = \"font\";\n  var PROP_FILL_STYLE                       = \"fillStyle\";\n  var PROP_FIRST_CHILD                      = \"firstChild\";\n  var PROP_HEIGHT                           = \"height\";\n  var PROP_KEY_CODE                         = \"keyCode\";\n  var PROP_LAST_CHILD                       = \"lastChild\";\n  var PROP_LEFT                             = \"left\";\n  var PROP_LINE_CAP                         = \"lineCap\";\n  var PROP_LINE_JOIN                        = \"lineJoin\";\n  var PROP_LINE_WIDTH                       = \"lineWidth\";\n  var PROP_NEXT_SIBLING                     = \"nextSibling\";\n  var PROP_PARENT_NODE                      = \"parentNode\";\n  var PROP_POSITION                         = \"position\";\n  var PROP_PREVIOUS_SIBLING                 = \"previousSibling\";\n  var PROP_SCREEN_X                         = \"screenX\";\n  var PROP_SCREEN_Y                         = \"screenY\";\n  var PROP_SHADOW_BLUR                      = \"shadowBlur\";\n  var PROP_SHADOW_COLOR                     = \"shadowColor\";\n  var PROP_SHADOW_OFFSET_X                  = \"shadowOffsetX\";\n  var PROP_SHADOW_OFFSET_Y                  = \"shadowOffsetY\";\n  var PROP_SHIFT_KEY                        = \"shiftKey\";\n  var PROP_STROKE_STYLE                     = \"strokeStyle\";\n  var PROP_STYLE                            = \"style\";\n  var PROP_TEXT_ALIGN                       = \"textAlign\";\n  var PROP_TEXT_BASELINE                    = \"textBaseline\";\n  var PROP_TOP                              = \"top\";\n  var PROP_WEBKIT_BACKING_STORE_PIXEL_RATIO = \"webkitBackingStorePixelRatio\";\n  var PROP_WEBKIT_HIDDEN                    = \"webkitHidden\";\n  var PROP_WIDTH                            = \"width\";\n  var PROP_WINDOW                           = \"window\";\n\n  var METHOD_ADD_EVENT_LISTENER         = \"addEventListener\";\n  var METHOD_ADD_COLOR_STOP             = \"addColorStop\";\n  var METHOD_APPEND_CHILD               = \"appendChild\";\n  var METHOD_ARC                        = \"arc\";\n  var METHOD_ARC_TO                     = \"arcTo\";\n  var METHOD_BEGIN_PATH                 = \"beginPath\";\n  var METHOD_BEZIER_CURVE_TO            = \"bezierCurveTo\";\n  var METHOD_CANCEL_ANIMATION_FRAME     = \"cancelAnimationFrame\";\n  var METHOD_CLEAR_RECT                 = \"clearRect\";\n  var METHOD_CLIP                       = \"clip\";\n  var METHOD_CLOSE_PATH                 = \"closePath\";\n  var METHOD_CREATE_ELEMENT             = \"createElement\";\n  var METHOD_CREATE_LINEAR_GRADIENT     = \"createLinearGradient\";\n  var METHOD_FILL                       = \"fill\";\n  var METHOD_FILL_RECT                  = \"fillRect\";\n  var METHOD_FILL_TEXT                  = \"fillText\";\n  var METHOD_GET_CONTEXT                = \"getContext\";\n  var METHOD_GET_ELEMENT_BY_ID          = \"getElementById\";\n  var METHOD_GET_ELEMENTS_BY_TAG_NAME   = \"getElementsByTagName\";\n  var METHOD_INSERT_BEFORE              = \"insertBefore\";\n  var METHOD_INVERSE                    = \"inverse\";\n  var METHOD_LINE_TO                    = \"lineTo\";\n  var METHOD_MOVE_TO                    = \"moveTo\";\n  var METHOD_PREVENT_DEFAULT            = \"preventDefault\";\n  var METHOD_QUADRATIC_CURVE_TO         = \"quadraticCurveTo\";\n  var METHOD_RECT                       = \"rect\";\n  var METHOD_REMOVE_CHILD               = \"removeChild\";\n  var METHOD_REMOVE_EVENT_LISTENER      = \"removeEventListener\";\n  var METHOD_REQUEST_ANIMATION_FRAME    = \"requestAnimationFrame\";\n  var METHOD_RESTORE                    = \"restore\";\n  var METHOD_ROTATE                     = \"rotate\";\n  var METHOD_SAVE                       = \"save\";\n  var METHOD_SCALE                      = \"scale\";\n  var METHOD_SET_ATTRIBUTE              = \"setAttribute\";\n  var METHOD_SET_TIMEOUT                = \"setTimeout\";\n  var METHOD_SET_TRANSFORM              = \"setTransform\";\n  var METHOD_STOP_IMMEDIATE_PROPAGATION = \"stopImmediatePropagation\";\n  var METHOD_STOP_PROPAGATION           = \"stopPropagation\";\n  var METHOD_STROKE                     = \"stroke\";\n  var METHOD_STROKE_RECT                = \"strokeRect\";\n  var METHOD_STROKE_TEXT                = \"strokeText\";\n  var METHOD_TRANSFORM                  = \"transform\";\n  var METHOD_TRANSLATE                  = \"translate\";\n  // We must be able to track the JavaScript listener functions.\n  // TODO: This should include both the typoe and the useCapture flag.\n  var winListeners = {};\n  var docListeners = {};\n\n  var wrapNode = function(node) {\n    if (node) {\n      return Sk.misceval.callsim(mod[NODE], node);\n    }\n    else {\n      return null;\n    }\n  }\n\n  var wrapNumber = function(n) {\n    if (typeof n === 'number') {\n      return Sk.builtin.assk$(n, Sk.builtin.nmber.float$);\n    }\n    else {\n      return null;\n    }\n  }\n\n  var wrapString = function(s) {\n    if (typeof s === 'string') {\n      return new Sk.builtin.str(s)\n    }\n    else {\n      return null;\n    }\n  }\n\n  var nodeFromArg = function(arg) {\n    if (arg) {\n      return arg.v;\n    }\n    else {\n      return null;\n    }\n  }\n\n  var numberFromArg = function(arg) {\n    if (arg) {\n      return arg.v;\n    }\n    else {\n      return null;\n    }\n  }\n\n  var stringFromArg = function(arg) {\n    if (arg) {\n      return arg.v;\n    }\n    else {\n      return null;\n    }\n  }\n  /*\n  mod.getElementsByTagName = new Sk.builtin.func(function(tag) {\n    var elements = document.getElementsByTagName(stringFromArg(tag))\n    var reslist = [];\n    for (var i = elements.length - 1; i >= 0; i--) {\n      reslist.push(Sk.misceval.callsim(mod[NODE], elements[i]));\n    }\n    return new Sk.builtin.list(reslist)\n  });\n\n  mod.getElementsByClassName = new Sk.builtin.func(function(cname) {\n    var r = document.getElementsByClassName(stringFromArg(cname));\n    var reslist = [];\n    for (var i = 0; i < r.length; i++) {\n      reslist.push(Sk.misceval.callsim(mod[NODE], r[i]));\n    };\n    return new Sk.builtin.list(reslist);\n  });\n\n  mod.getElementsByName = new Sk.builtin.func(function(cname) {\n    var r = document.getElementsByName(stringFromArg(cname));\n    var reslist = [];\n    for (var i = 0; i < r.length; i++) {\n      reslist.push(Sk.misceval.callsim(mod[NODE], r[i]));\n    };\n    return new Sk.builtin.list(reslist);\n  });\n  */\n  mod[EVENT] = Sk.builtin.event(mod);\n\n  mod[NODE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, node) {\n      self.tp$name = NODE;\n      self.v = node;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(nodePy, name) {\n      var node = Sk.ffi.remapToJs(nodePy);\n      switch(name) {\n        case 'clientHeight': {\n          return wrapNumber(node[name]);\n        }\n        case 'clientWidth': {\n          return wrapNumber(node[name]);\n        }\n        case PROP_DIR: {\n          return new Sk.builtin.str(node[PROP_DIR]);\n        }\n        case PROP_FIRST_CHILD: {\n          return wrapNode(node[PROP_FIRST_CHILD]);\n        }\n        case PROP_LAST_CHILD: {\n          return wrapNode(node[PROP_LAST_CHILD]);\n        }\n        case PROP_NEXT_SIBLING: {\n          return wrapNode(node[PROP_NEXT_SIBLING]);\n        }\n        case PROP_PARENT_NODE: {\n          return wrapNode(node[PROP_PARENT_NODE]);\n        }\n        case PROP_PREVIOUS_SIBLING: {\n          return wrapNode(node[PROP_PREVIOUS_SIBLING]);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(node[PROP_HEIGHT], Sk.builtin.nmber.int$);\n        }\n        case PROP_WIDTH: {\n          return Sk.builtin.assk$(node[PROP_WIDTH], Sk.builtin.nmber.int$);\n        }\n        case PROP_STYLE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = PROP_STYLE;\n              self.v = node.style;\n            });\n            $loc.__getattr__ = new Sk.builtin.func(function(stylePy, name) {\n              var style = Sk.ffi.remapToJs(stylePy);\n              switch(name) {\n                case PROP_HEIGHT: {\n                  return new Sk.builtin.str(style[PROP_HEIGHT]);\n                }\n                case PROP_LEFT: {\n                  return new Sk.builtin.str(style[PROP_LEFT]);\n                }\n                case PROP_POSITION: {\n                  return new Sk.builtin.str(style[PROP_POSITION]);\n                }\n                case PROP_TOP: {\n                  return new Sk.builtin.str(style[PROP_TOP]);\n                }\n                case PROP_WIDTH: {\n                  return new Sk.builtin.str(style[PROP_WIDTH]);\n                }\n              }\n            })\n            $loc.__setattr__ = new Sk.builtin.func(function(stylePy, name, valuePy) {\n              var style = Sk.ffi.remapToJs(stylePy);\n              var value = Sk.ffi.remapToJs(valuePy);\n              switch(name) {\n                case PROP_HEIGHT: {\n                  style[PROP_HEIGHT] = value;\n                }\n                break;\n                case PROP_LEFT: {\n                  style[PROP_LEFT] = value;\n                }\n                break;\n                case PROP_POSITION: {\n                  style[PROP_POSITION] = value;\n                }\n                break;\n                case PROP_TOP: {\n                  style[PROP_TOP] = value;\n                }\n                break;\n                case PROP_WIDTH: {\n                  style[PROP_WIDTH] = value;\n                }\n                break;\n                default: {\n                  throw new Sk.builtin.AssertionError(name + \" is not a writeable attribute of \" + PROP_STYLE);\n                }\n              }\n            })\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(PROP_STYLE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(PROP_STYLE);\n            });\n          }, PROP_STYLE, []));\n        }\n        case METHOD_APPEND_CHILD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_APPEND_CHILD;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, childNode) {\n              return wrapNode(node.appendChild(nodeFromArg(childNode)));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_APPEND_CHILD);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_APPEND_CHILD);\n            });\n          }, METHOD_APPEND_CHILD, []));\n        }\n        case METHOD_GET_CONTEXT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_CONTEXT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, contextIdPy, contextAttributePy) {\n              var contextId = Sk.ffi.remapToJs(contextIdPy);\n              var contextAttribute = Sk.ffi.remapToJs(contextAttributePy);\n              var context = node.getContext(contextId, contextAttribute);\n              return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                $loc.__init__ = new Sk.builtin.func(function(self) {\n                  self.tp$name = CANVAS_RENDERING_CONTEXT_2D;\n                  self.v = context;\n                });\n                $loc.__getattr__ = new Sk.builtin.func(function(contextPy, name) {\n                  switch(name) {\n                    case PROP_FILL_STYLE: {\n                      return new Sk.builtin.str(context[PROP_FILL_STYLE]);\n                    }\n                    case PROP_FONT: {\n                      return new Sk.builtin.str(context[PROP_FONT]);\n                    }\n                    case PROP_LINE_CAP: {\n                      return new Sk.builtin.str(context[PROP_LINE_CAP]);\n                    }\n                    case PROP_LINE_JOIN: {\n                      return new Sk.builtin.str(context[PROP_LINE_JOIN]);\n                    }\n                    case PROP_LINE_WIDTH: {\n                      return Sk.builtin.assk$(context[PROP_LINE_WIDTH], Sk.builtin.nmber.int$);\n                    }\n                    case PROP_SHADOW_BLUR: {\n                      return Sk.builtin.assk$(context[PROP_SHADOW_BLUR], Sk.builtin.nmber.int$);\n                    }\n                    case PROP_SHADOW_COLOR: {\n                      return new Sk.builtin.str(context[PROP_SHADOW_COLOR]);\n                    }\n                    case PROP_SHADOW_OFFSET_X: {\n                      return Sk.builtin.assk$(context[PROP_SHADOW_OFFSET_X], Sk.builtin.nmber.int$);\n                    }\n                    case PROP_SHADOW_OFFSET_Y: {\n                      return Sk.builtin.assk$(context[PROP_SHADOW_OFFSET_Y], Sk.builtin.nmber.int$);\n                    }\n                    case PROP_STROKE_STYLE: {\n                      return new Sk.builtin.str(context[PROP_STROKE_STYLE]);\n                    }\n                    case PROP_TEXT_ALIGN: {\n                      return new Sk.builtin.str(context[PROP_TEXT_ALIGN]);\n                    }\n                    case PROP_TEXT_BASELINE: {\n                      return new Sk.builtin.str(context[PROP_TEXT_BASELINE]);\n                    }\n                    case PROP_WEBKIT_BACKING_STORE_PIXEL_RATIO: {\n                      return Sk.builtin.assk$(context[PROP_WEBKIT_BACKING_STORE_PIXEL_RATIO], Sk.builtin.nmber.int$);\n                    }\n                    case METHOD_ARC: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_ARC;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x, y, radius, startAngle, endAngle, anticlockwise) {\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          radius = Sk.ffi.remapToJs(radius);\n                          startAngle = Sk.ffi.remapToJs(startAngle);\n                          endAngle = Sk.ffi.remapToJs(endAngle);\n                          anticlockwise = Sk.ffi.remapToJs(anticlockwise);\n                          context[METHOD_ARC](x, y, radius, startAngle, endAngle, anticlockwise);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_ARC);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_ARC);\n                        });\n                      }, METHOD_ARC, []));\n                    }\n                    case METHOD_ARC_TO: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_ARC_TO;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x1, y1, x2, y2, radiusX, radiusY, rotation) {\n                          x1 = Sk.ffi.remapToJs(x1);\n                          y1 = Sk.ffi.remapToJs(y1);\n                          x2 = Sk.ffi.remapToJs(x2);\n                          y2 = Sk.ffi.remapToJs(y2);\n                          radiusX = Sk.ffi.remapToJs(radiusX);\n                          radiusY = Sk.ffi.remapToJs(radiusY);\n                          rotation = Sk.ffi.remapToJs(rotation);\n                          context[METHOD_ARC_TO](x1, y1, x2, y2, radiusX, radiusY, rotation);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_ARC_TO);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_ARC_TO);\n                        });\n                      }, METHOD_ARC_TO, []));\n                    }\n                    case METHOD_BEGIN_PATH: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_BEGIN_PATH;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self) {\n                          context[METHOD_BEGIN_PATH]();\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_BEGIN_PATH);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_BEGIN_PATH);\n                        });\n                      }, METHOD_BEGIN_PATH, []));\n                    }\n                    case METHOD_BEZIER_CURVE_TO: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_BEZIER_CURVE_TO;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, cp1x, cp1y, cp2x, cp2y, x, y) {\n                          cp1x = Sk.ffi.remapToJs(cp1x);\n                          cp1y = Sk.ffi.remapToJs(cp1y);\n                          cp2x = Sk.ffi.remapToJs(cp2x);\n                          cp2y = Sk.ffi.remapToJs(cp2y);\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          context[METHOD_BEZIER_CURVE_TO](cp1x, cp1y, cp2x, cp2y, x, y);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_BEZIER_CURVE_TO);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_BEZIER_CURVE_TO);\n                        });\n                      }, METHOD_BEZIER_CURVE_TO, []));\n                    }\n                    case METHOD_CLEAR_RECT: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_CLEAR_RECT;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x, y, w, h) {\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          w = Sk.ffi.remapToJs(w);\n                          h = Sk.ffi.remapToJs(h);\n                          context[METHOD_CLEAR_RECT](x, y, w, h);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_CLEAR_RECT);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_CLEAR_RECT);\n                        });\n                      }, METHOD_CLEAR_RECT, []));\n                    }\n                    case METHOD_CLIP: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_CLIP;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self) {\n                          context[METHOD_CLIP]();\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_CLIP);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_CLIP);\n                        });\n                      }, METHOD_CLIP, []));\n                    }\n                    case METHOD_CLOSE_PATH: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_CLOSE_PATH;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self) {\n                          context[METHOD_CLOSE_PATH]();\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_CLOSE_PATH);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_CLOSE_PATH);\n                        });\n                      }, METHOD_CLOSE_PATH, []));\n                    }\n                    case METHOD_CREATE_LINEAR_GRADIENT: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_CREATE_LINEAR_GRADIENT;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x0, y0, x1, y1) {\n                          x0 = Sk.ffi.remapToJs(x0);\n                          y0 = Sk.ffi.remapToJs(y0);\n                          x1 = Sk.ffi.remapToJs(x1);\n                          y1 = Sk.ffi.remapToJs(y1);\n                          var gradient = context[METHOD_CREATE_LINEAR_GRADIENT](x0, y0, x1, y1);\n                          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                            $loc.__init__ = new Sk.builtin.func(function(self) {\n                              self.tp$name = CANVAS_GRADIENT_CLASS;\n                              self.v = gradient;\n                            });\n                            $loc.__getattr__ = new Sk.builtin.func(function(gradientPy, name) {\n                              switch(name) {\n                                case METHOD_ADD_COLOR_STOP: {\n                                  return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                                    $loc.__init__ = new Sk.builtin.func(function(self) {\n                                      self.tp$name = METHOD_ADD_COLOR_STOP;\n                                    });\n                                    $loc.__call__ = new Sk.builtin.func(function(self, offset, color) {\n                                      offset = Sk.ffi.remapToJs(offset);\n                                      color = Sk.ffi.remapToJs(color);\n                                      gradient[METHOD_ADD_COLOR_STOP](offset, color);\n                                    });\n                                    $loc.__str__ = new Sk.builtin.func(function(self) {\n                                      return new Sk.builtin.str(METHOD_ADD_COLOR_STOP);\n                                    });\n                                    $loc.__repr__ = new Sk.builtin.func(function(self) {\n                                      return new Sk.builtin.str(METHOD_ADD_COLOR_STOP);\n                                    });\n                                  }, METHOD_ADD_COLOR_STOP, []));\n                                }\n                              }\n                            })\n                            $loc.__setattr__ = new Sk.builtin.func(function(gradientPy, name, valuePy) {\n                              var value = Sk.ffi.remapToJs(valuePy);\n                              switch(name) {\n                                default: {\n                                  throw new Sk.builtin.AssertionError(name + \" is not a writeable attribute of \" + CANVAS_GRADIENT_CLASS);\n                                }\n                              }\n                            })\n                            $loc.__str__ = new Sk.builtin.func(function(self) {\n                              return new Sk.builtin.str(CANVAS_GRADIENT_CLASS);\n                            });\n                            $loc.__repr__ = new Sk.builtin.func(function(self) {\n                              return new Sk.builtin.str(CANVAS_GRADIENT_CLASS);\n                            });\n                          }, CANVAS_GRADIENT_CLASS, []));\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_CREATE_LINEAR_GRADIENT);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_CREATE_LINEAR_GRADIENT);\n                        });\n                      }, METHOD_CREATE_LINEAR_GRADIENT, []));\n                    }\n                    case METHOD_FILL: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_FILL;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self) {\n                          context[METHOD_FILL]();\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_FILL);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_FILL);\n                        });\n                      }, METHOD_FILL, []));\n                    }\n                    case METHOD_FILL_RECT: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_FILL_RECT;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x, y, w, h) {\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          w = Sk.ffi.remapToJs(w);\n                          h = Sk.ffi.remapToJs(h);\n                          context[METHOD_FILL_RECT](x, y, w, h);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_FILL_RECT);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_FILL_RECT);\n                        });\n                      }, METHOD_FILL_RECT, []));\n                    }\n                    case METHOD_FILL_TEXT: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_FILL_TEXT;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, text, x, y, maxWidthPy) {\n                          text = Sk.ffi.remapToJs(text);\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          var maxWidth = Sk.ffi.remapToJs(maxWidthPy);\n                          if (typeof maxWidth === 'undefined') {\n                            context[METHOD_FILL_TEXT](text, x, y);\n                          }\n                          else if (typeof maxWidth === 'number') {\n                            context[METHOD_FILL_TEXT](text, x, y, maxWidth);\n                          }\n                          else {\n                            throw new Sk.builtin.TypeError(\"maxWidth\");\n                          }\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_FILL_TEXT);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_FILL_TEXT);\n                        });\n                      }, METHOD_FILL_TEXT, []));\n                    }\n                    case METHOD_LINE_TO: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_LINE_TO;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x, y) {\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          context[METHOD_LINE_TO](x, y);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_LINE_TO);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_LINE_TO);\n                        });\n                      }, METHOD_LINE_TO, []));\n                    }\n                    case METHOD_MOVE_TO: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_MOVE_TO;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x, y) {\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          context[METHOD_MOVE_TO](x, y);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_MOVE_TO);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_MOVE_TO);\n                        });\n                      }, METHOD_MOVE_TO, []));\n                    }\n                    case METHOD_QUADRATIC_CURVE_TO: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_QUADRATIC_CURVE_TO;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, cpx, cpy, x, y) {\n                          cpx = Sk.ffi.remapToJs(cpx);\n                          cpy = Sk.ffi.remapToJs(cpy);\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          context[METHOD_QUADRATIC_CURVE_TO](cpx, cpy, x, y);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_QUADRATIC_CURVE_TO);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_QUADRATIC_CURVE_TO);\n                        });\n                      }, METHOD_QUADRATIC_CURVE_TO, []));\n                    }\n                    case METHOD_RECT: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_RECT;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x, y, w, h) {\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          w = Sk.ffi.remapToJs(w);\n                          h = Sk.ffi.remapToJs(h);\n                          context[METHOD_RECT](x, y, w, h);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_RECT);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_RECT);\n                        });\n                      }, METHOD_RECT, []));\n                    }\n                    case METHOD_RESTORE: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_RESTORE;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self) {\n                          context[METHOD_RESTORE]();\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_RESTORE);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_RESTORE);\n                        });\n                      }, METHOD_RESTORE, []));\n                    }\n                    case METHOD_ROTATE: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_ROTATE;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n                          angle = Sk.ffi.remapToJs(angle);\n                          context[METHOD_ROTATE](angle);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_ROTATE);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_ROTATE);\n                        });\n                      }, METHOD_ROTATE, []));\n                    }\n                    case METHOD_SAVE: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_SAVE;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self) {\n                          context[METHOD_SAVE]();\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_SAVE);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_SAVE);\n                        });\n                      }, METHOD_SAVE, []));\n                    }\n                    case METHOD_SCALE: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_SCALE;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x, y) {\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          context[METHOD_SCALE](x, y);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_SCALE);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_SCALE);\n                        });\n                      }, METHOD_SCALE, []));\n                    }\n                    case METHOD_SET_TRANSFORM: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_SET_TRANSFORM;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, a, b, c, d, e, f) {\n                          a = Sk.ffi.remapToJs(a);\n                          b = Sk.ffi.remapToJs(b);\n                          c = Sk.ffi.remapToJs(c);\n                          d = Sk.ffi.remapToJs(d);\n                          e = Sk.ffi.remapToJs(e);\n                          f = Sk.ffi.remapToJs(f);\n                          context[METHOD_SET_TRANSFORM](a, b, c, d, e, f);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_SET_TRANSFORM);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_SET_TRANSFORM);\n                        });\n                      }, METHOD_SET_TRANSFORM, []));\n                    }\n                    case METHOD_STROKE: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_STROKE;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self) {\n                          context[METHOD_STROKE]();\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_STROKE);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_STROKE);\n                        });\n                      }, METHOD_STROKE, []));\n                    }\n                    case METHOD_STROKE_RECT: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_STROKE_RECT;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x, y, w, h) {\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          w = Sk.ffi.remapToJs(w);\n                          h = Sk.ffi.remapToJs(h);\n                          context[METHOD_STROKE_RECT](x, y, w, h);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_STROKE_RECT);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_STROKE_RECT);\n                        });\n                      }, METHOD_STROKE_RECT, []));\n                    }\n                    case METHOD_STROKE_TEXT: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_STROKE_TEXT;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, text, x, y, maxWidthPy) {\n                          text = Sk.ffi.remapToJs(text);\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          var maxWidth = Sk.ffi.remapToJs(maxWidthPy);\n                          if (typeof maxWidth === 'undefined') {\n                            context[METHOD_STROKE_TEXT](text, x, y);\n                          }\n                          else if (typeof maxWidth === 'number') {\n                            context[METHOD_STROKE_TEXT](text, x, y, maxWidth);\n                          }\n                          else {\n                            throw new Sk.builtin.TypeError(\"maxWidth\");\n                          }\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_STROKE_TEXT);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_STROKE_TEXT);\n                        });\n                      }, METHOD_STROKE_TEXT, []));\n                    }\n                    case METHOD_TRANSFORM: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_TRANSFORM;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, a, b, c, d, e, f) {\n                          a = Sk.ffi.remapToJs(a);\n                          b = Sk.ffi.remapToJs(b);\n                          c = Sk.ffi.remapToJs(c);\n                          d = Sk.ffi.remapToJs(d);\n                          e = Sk.ffi.remapToJs(e);\n                          f = Sk.ffi.remapToJs(f);\n                          context[METHOD_TRANSFORM](a, b, c, d, e, f);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_TRANSFORM);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_TRANSFORM);\n                        });\n                      }, METHOD_TRANSFORM, []));\n                    }\n                    case METHOD_TRANSLATE: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_TRANSLATE;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, x, y) {\n                          x = Sk.ffi.remapToJs(x);\n                          y = Sk.ffi.remapToJs(y);\n                          context[METHOD_TRANSLATE](x, y);\n                        });\n                        $loc.__str__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_TRANSLATE);\n                        });\n                        $loc.__repr__ = new Sk.builtin.func(function(self) {\n                          return new Sk.builtin.str(METHOD_TRANSLATE);\n                        });\n                      }, METHOD_TRANSLATE, []));\n                    }\n                  }\n                })\n                $loc.__setattr__ = new Sk.builtin.func(function(contextPy, name, valuePy) {\n                  var context = Sk.ffi.remapToJs(contextPy);\n                  var value = Sk.ffi.remapToJs(valuePy);\n                  switch(name) {\n                    case PROP_FILL_STYLE: {\n                      context[PROP_FILL_STYLE] = value;\n                    }\n                    break;\n                    case PROP_FONT: {\n                      context[PROP_FONT] = value;\n                    }\n                    break;\n                    case PROP_LINE_CAP: {\n                      context[PROP_LINE_CAP] = value;\n                    }\n                    break;\n                    case PROP_LINE_JOIN: {\n                      context[PROP_LINE_JOIN] = value;\n                    }\n                    break;\n                    case PROP_LINE_WIDTH: {\n                      context[PROP_LINE_WIDTH] = value;\n                    }\n                    break;\n                    case PROP_SHADOW_BLUR: {\n                      context[PROP_SHADOW_BLUR] = value;\n                    }\n                    break;\n                    case PROP_SHADOW_COLOR: {\n                      context[PROP_SHADOW_COLOR] = value;\n                    }\n                    break;\n                    case PROP_SHADOW_OFFSET_X: {\n                      context[PROP_SHADOW_OFFSET_X] = value;\n                    }\n                    break;\n                    case PROP_SHADOW_OFFSET_Y: {\n                      context[PROP_SHADOW_OFFSET_Y] = value;\n                    }\n                    break;\n                    case PROP_STROKE_STYLE: {\n                      context[PROP_STROKE_STYLE] = value;\n                    }\n                    break;\n                    case PROP_TEXT_ALIGN: {\n                      context[PROP_TEXT_ALIGN] = value;\n                    }\n                    break;\n                    case PROP_TEXT_BASELINE: {\n                      context[PROP_TEXT_BASELINE] = value;\n                    }\n                    break;\n                    default: {\n                      throw new Sk.builtin.AssertionError(name + \" is not a writeable attribute of \" + CANVAS_RENDERING_CONTEXT_2D);\n                    }\n                  }\n                })\n                $loc.__str__ = new Sk.builtin.func(function(self) {\n                  return new Sk.builtin.str(CANVAS_RENDERING_CONTEXT_2D);\n                });\n                $loc.__repr__ = new Sk.builtin.func(function(self) {\n                  return new Sk.builtin.str(CANVAS_RENDERING_CONTEXT_2D);\n                });\n              }, CANVAS_RENDERING_CONTEXT_2D, []));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CONTEXT);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CONTEXT);\n            });\n          }, METHOD_GET_CONTEXT, []));\n        }\n        case METHOD_INSERT_BEFORE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_INSERT_BEFORE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, newNode, refNode) {\n              return wrapNode(node.insertBefore(nodeFromArg(newNode), nodeFromArg(refNode)));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_INSERT_BEFORE)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_INSERT_BEFORE)\n            })\n          }, METHOD_INSERT_BEFORE, []));\n        }\n        case METHOD_REMOVE_CHILD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_REMOVE_CHILD;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, childNode) {\n              return wrapNode(node.removeChild(nodeFromArg(childNode)));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_REMOVE_CHILD);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_REMOVE_CHILD);\n            });\n          }, METHOD_REMOVE_CHILD, []));\n        }\n        case METHOD_SET_ATTRIBUTE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_ATTRIBUTE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, name, value) {\n              node.setAttribute(stringFromArg(name), stringFromArg(value));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_ATTRIBUTE)\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_ATTRIBUTE);\n            });\n          }, METHOD_SET_ATTRIBUTE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(nodePy, name, valuePy) {\n      var node = Sk.ffi.remapToJs(nodePy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_DIR: {\n          node[PROP_DIR] = value;\n        }\n        break;\n        case 'id': {\n          node.setAttribute(name, value);\n        }\n        break;\n        case PROP_HEIGHT: {\n          node[PROP_HEIGHT] = value;\n        }\n        break;\n        case PROP_WIDTH: {\n          node[PROP_WIDTH] = value;\n        }\n        break;\n        default: {\n          node.setAttribute(name, stringFromArg(value));\n        }\n      }\n    });\n    $loc.getCSS = new Sk.builtin.func(function(self,key) {\n      return new Sk.builtin.str(self.v.style[key.v]);\n    });\n    $loc.setCSS = new Sk.builtin.func(function(self, attr, value) {\n      self.v.style[attr.v] = value.v\n    });\n    $loc.getAttribute = new Sk.builtin.func(function(self, key) {\n      var res = self.v.getAttribute(key.v)\n      if (res) {\n        return new Sk.builtin.str(res)\n      }\n      else {\n        return null;\n      }\n    });\n    $loc.setAttribute = new Sk.builtin.func(function(self, attr, value) {\n      self.v.setAttribute(attr.v,value.v)\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(self.v.tagName)\n    })\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(NODE)\n    })\n  }, NODE, []);\n\n  mod[PROP_WINDOW] = Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = WINDOW_CLASS;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_ANIMATION_TIME: {\n          return wrapNumber(window[PROP_ANIMATION_TIME]);\n        }\n        case PROP_DOCUMENT: {\n          return mod[PROP_DOCUMENT];\n        }\n        case \"innerHeight\": {\n          return wrapNumber(window[name]);\n        }\n        case \"innerWidth\": {\n          return wrapNumber(window[name]);\n        }\n        case PROP_DEVICE_PIXEL_RATIO: {\n          return Sk.builtin.assk$(window[PROP_DEVICE_PIXEL_RATIO], Sk.builtin.nmber.int$);\n        }\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ADD_EVENT_LISTENER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, typePy, listenerPy, useCapture) {\n              var type = Sk.ffi.remapToJs(typePy);\n              var listener = function(event) {\n                var eventPy = Sk.misceval.callsim(mod[EVENT], Sk.ffi.referenceToPy(event), EVENT);\n                Sk.misceval.callsim(listenerPy, eventPy);\n              };\n              winListeners[type] = listener;\n              window[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_ADD_EVENT_LISTENER)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_ADD_EVENT_LISTENER)\n            })\n          }, METHOD_ADD_EVENT_LISTENER, []));\n        }\n        case METHOD_REMOVE_EVENT_LISTENER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_REMOVE_EVENT_LISTENER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, typePy, listener, useCapture) {\n              var type = Sk.ffi.remapToJs(typePy);\n              var listener = winListeners[type];\n              delete winListeners[type];\n              window[METHOD_REMOVE_EVENT_LISTENER](type, listener, useCapture);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_REMOVE_EVENT_LISTENER)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_REMOVE_EVENT_LISTENER)\n            })\n          }, METHOD_REMOVE_EVENT_LISTENER, []));\n        }\n        case METHOD_CANCEL_ANIMATION_FRAME: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CANCEL_ANIMATION_FRAME;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, requestID) {\n              if (requestID) {\n                window[METHOD_CANCEL_ANIMATION_FRAME](numberFromArg(requestID));\n              }\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CANCEL_ANIMATION_FRAME)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CANCEL_ANIMATION_FRAME)\n            })\n          }, METHOD_CANCEL_ANIMATION_FRAME, []));\n        }\n        case METHOD_REQUEST_ANIMATION_FRAME: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_REQUEST_ANIMATION_FRAME;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, callback) {\n              var requestID = window[METHOD_REQUEST_ANIMATION_FRAME](function(timestamp) {\n                Sk.misceval.callsim(callback, wrapNumber(timestamp));\n              });\n              return wrapNumber(requestID);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_REQUEST_ANIMATION_FRAME)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_REQUEST_ANIMATION_FRAME)\n            })\n          }, METHOD_REQUEST_ANIMATION_FRAME, []));\n        }\n        case METHOD_SET_TIMEOUT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_TIMEOUT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, funcPy, delayPy, paramsPy) {\n              var delay = Sk.ffi.remapToJs(delayPy);\n              var params = Sk.ffi.remapToJs(paramsPy);\n              var timeoutID = window[METHOD_SET_TIMEOUT](function() {\n                Sk.misceval.callsim(funcPy);\n              }, delay, params);\n              return wrapNumber(timeoutID);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_TIMEOUT)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_TIMEOUT)\n            })\n          }, METHOD_SET_TIMEOUT, []));\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(WINDOW_CLASS)\n    })\n    $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n      return new Sk.builtin.str(WINDOW_CLASS)\n    })\n  }, WINDOW_CLASS, []));\n\n  mod[PROP_DOCUMENT] = Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = DOCUMENT_CLASS;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_BODY: {\n          return Sk.misceval.callsim(mod[NODE], document[PROP_BODY]);\n        }\n        case PROP_WEBKIT_HIDDEN: {\n          return document[PROP_WEBKIT_HIDDEN];\n        }\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ADD_EVENT_LISTENER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, typePy, listenerPy, useCapture) {\n              var type = Sk.ffi.remapToJs(typePy);\n              var listener = function(event) {\n                var eventPy = Sk.misceval.callsim(mod[EVENT], Sk.ffi.referenceToPy(event), EVENT);\n                Sk.misceval.callsim(listenerPy, eventPy);\n              };\n              docListeners[type] = listener;\n              document[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_ADD_EVENT_LISTENER)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_ADD_EVENT_LISTENER)\n            })\n          }, METHOD_ADD_EVENT_LISTENER, []));\n        }\n        case METHOD_REMOVE_EVENT_LISTENER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_REMOVE_EVENT_LISTENER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, typePy, listener, useCapture) {\n              var type = Sk.ffi.remapToJs(typePy);\n              var listener = docListeners[type];\n              delete docListeners[type];\n              document[METHOD_REMOVE_EVENT_LISTENER](type, listener, useCapture);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_REMOVE_EVENT_LISTENER)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_REMOVE_EVENT_LISTENER)\n            })\n          }, METHOD_REMOVE_EVENT_LISTENER, []));\n        }\n        case METHOD_CREATE_ELEMENT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CREATE_ELEMENT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, tagName, attributes) {\n              var element = document.createElement(stringFromArg(tagName));\n              if (attributes instanceof Sk.builtin.dict) {\n                for (var iter = attributes.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n                  var v = attributes.mp$subscript(k);\n                  if (v === undefined) {\n                    v = null;\n                  }\n                  var kAsJs = Sk.ffi.remapToJs(k);\n                  var vAsJs = Sk.ffi.remapToJs(v);\n                  element.setAttribute(kAsJs, vAsJs);\n                }\n              }\n              return wrapNode(element);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CREATE_ELEMENT)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CREATE_ELEMENT)\n            })\n          }, METHOD_CREATE_ELEMENT, []));\n        }\n        case METHOD_GET_ELEMENT_BY_ID: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_ELEMENT_BY_ID;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, id) {\n              return wrapNode(document.getElementById(stringFromArg(id)));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_ELEMENT_BY_ID)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_ELEMENT_BY_ID)\n            })\n          }, METHOD_GET_ELEMENT_BY_ID, []));\n        }\n        case METHOD_GET_ELEMENTS_BY_TAG_NAME: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_ELEMENTS_BY_TAG_NAME;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, tagName) {\n              var elements = document.getElementsByTagName(stringFromArg(tagName))\n              var xs = [];\n              for (var i = elements.length - 1; i >= 0; i--) {\n                xs.push(wrapNode(elements[i]));\n              }\n              return new Sk.builtin.list(xs);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_ELEMENTS_BY_TAG_NAME)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_ELEMENTS_BY_TAG_NAME)\n            })\n          }, METHOD_GET_ELEMENTS_BY_TAG_NAME, []));\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(DOCUMENT_CLASS)\n    })\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(DOCUMENT_CLASS)\n    })\n  }, DOCUMENT_CLASS, []));\n\n  return mod;\n}\n", "src/lib/pythonds/basic/__init__.py": "\n#__all__ = [\"stack\"]\n\n\n#from .stack import Stack\n#from .queue import Queue\n\n\n\n", "src/lib/c2ga/__init__.js": "/**\n * Geometric Algebra (c2ga) module for DaVinci Python.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n  /**\n   * Symbolic constants representing the Python classes or functions that are exported by this module.\n   * These are captured here for both consistency and self-documentation.\n   */\n  var CONFORMAL_2    = \"Conformal2\";    // Multivector of 4-dimensional Conformal space to represent Euclidean 2D Motions.\n\n  // The following symbolic constant simulates a zero scalar argument for convenience functions.\n  var ARG_ZERO      = Sk.builtin.assk$(0, Sk.builtin.nmber.float$);\n\n  var mod = {};\n\n  function isNumber(x)    { return typeof x === 'number'; }\n  function isString(x)    { return typeof x === 'string'; }\n  function isBoolean(x)   { return typeof x === 'boolean'; }\n  function isNull(x)      { return typeof x === 'object' && x === null; }\n  function isUndefined(x) { return typeof x === 'undefined'; }\n  function isDefined(x)   { return typeof x !== 'undefined'; }\n\n  function remapC3ToPy(x0, x1, x2, x3) {\n    return Sk.misceval.callsim(mod[CONFORMAL_2],\n      Sk.builtin.assk$(x0, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x1, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x2, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x3, Sk.builtin.nmber.float$));\n  }\n\n  mod[CONFORMAL_2] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, x0, x1, x2, x3) {\n      x0 = Sk.ffi.remapToJs(x0);\n      x1 = Sk.ffi.remapToJs(x1);\n      x2 = Sk.ffi.remapToJs(x2);\n      x3 = Sk.ffi.remapToJs(x3);\n      self.tp$name = CONFORMAL_2;\n      self.v = [x0, x1, x2, x3];\n    });\n    $loc.__add__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" + \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.addE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" - \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" * \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__xor__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rxor__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" ^ \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__ixor__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__lshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rlshift__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" << \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__ilshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__rshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        var x0 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var a3 = a[3];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        var b3 = b[3];\n        var x0 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n    });\n    $loc.__rrshift__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        var a0 = lhs;\n        var a1 = 0;\n        var a2 = 0;\n        var a3 = 0;\n        var b0 = rhs[0];\n        var b1 = rhs[1];\n        var b2 = rhs[2];\n        var b3 = rhs[3];\n        var x0 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        var x1 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        var x2 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        var x3 = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return remapC3ToPy(x0, x1, x2, x3);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" >> \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__irshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other;\n        var b1 = 0;\n        var b2 = 0;\n        var b3 = 0;\n        self[0] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n      else {\n        var a0 = self[0];\n        var a1 = self[1];\n        var a2 = self[2];\n        var a3 = self[3];\n        var b0 = other[0];\n        var b1 = other[1];\n        var b2 = other[2];\n        var b3 = other[3];\n        self[0] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);\n        self[1] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);\n        self[2] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);\n        self[3] = bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);\n        return selfPy;\n      }\n    });\n    $loc.__or__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      throw new Error(\"Under construction or\");\n    });\n    $loc.nb$negative = function() {\n      var self = Sk.ffi.remapToJs(this);\n      return remapC3ToPy(-self[0], -self[1], -self[2], -self[3]);\n    };\n    $loc.nb$positive = function() {\n      return this;\n    };\n    $loc.nb$invert = function() {\n      var self = Sk.ffi.remapToJs(this);\n      return remapC3ToPy(self[0], self[1], self[2], -self[3]);\n    };\n    $loc.__div__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      throw new Error(\"Under construction\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      return new Sk.builtin.str(CONFORMAL_2 + \"(\" + mv.join(\", \") + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      if (isDefined(mv)) {\n        return new Sk.builtin.str(bladeSTR.stringFromCoordinates([mv[0], mv[1], mv[2], mv[3]], [\"1\", \"i\", \"j\", \"I\"]));\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + CONFORMAL_2 + \"'>\");\n      }\n    });\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      throw new Error(\"Under construction eq\");\n    });\n\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      throw new Error(\"Under construction ne\");\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(selfPy, key) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      if (key === 'w') {\n        return Sk.builtin.assk$(self[0], Sk.builtin.nmber.float$);\n      }\n      else if (key === 'x') {\n        return Sk.builtin.assk$(self[1], Sk.builtin.nmber.float$);\n      }\n      else if (key === 'y') {\n        return Sk.builtin.assk$(self[2], Sk.builtin.nmber.float$);\n      }\n      else if (key === 'xy') {\n        return Sk.builtin.assk$(self[3], Sk.builtin.nmber.float$);\n      }\n      else {\n        throw new Error(key + \" is not a valid \" + CONFORMAL_2 + \" attribute.\");\n      }\n    });\n  }, CONFORMAL_2, []);\n\n  return mod;\n}\n", "src/lib/sprite/__init__.js": "//\n//\n// Sprite Graphics Module for DaVinci.\n//\n// Based on the turtle module by Brad Miller.\n//\n// Dependencies:\n//   jQuery\n//\n//\n\nvar SpriteGraphics; // the single identifier needed in the global scope\n\nif (! SpriteGraphics) {\n  SpriteGraphics = {};\n}\n\n\n(function () {\n\n  var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians.\n  var Rad2Degree = 180.0 / Math.PI; // conversion factor for radians to degrees.\n\n  function SpriteCanvas(options) {\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n\n    this.canvas = document.getElementById(this.canvasID);\n    this.context = this.canvas.getContext('2d');\n    $(this.canvas).fadeIn();\n\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.setup(this.canvas.width,this.canvas.height);\n    SpriteGraphics.canvasInit = true;\n    this.tlist = []\n\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n    this.segmentLength = 10;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    SpriteGraphics.canvasLib[this.canvasID] = this;\n    //  This can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    Sk.tg.fadeOnExit = true;\n  }\n\n  SpriteCanvas.prototype.setup = function(width, height) {\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n\n    if (SpriteGraphics.canvasInit == false) {\n      this.context.save();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      SpriteGraphics.canvasInit = true;\n      SpriteGraphics.eventCount = 0;\n      SpriteGraphics.renderClock = 0;\n      SpriteGraphics.renderTime = 0;\n    }\n    else {\n      this.context.restore();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  SpriteCanvas.prototype.addToCanvas = function(t) {\n    this.tlist.push(t);\n  }\n\n  SpriteCanvas.prototype.onCanvas = function(t) {\n    return (this.tlist.indexOf(t) >= 0);\n  }\n\n  SpriteCanvas.prototype.isAnimating = function() {\n    return (this.tlist.length > 0);\n  }\n\n  SpriteCanvas.prototype.startAnimating = function(t) {\n    if (! this.isAnimating()) {\n      this.intervalId = setTimeout(render, this.delay);\n    }\n    // Added in case startAnimating is called after it's already been added.\n    if (!this.onCanvas(t)) {\n      this.addToCanvas(t);\n    }\n    Sk.isSpriteProgram = true;\n  }\n\n  SpriteCanvas.prototype.doneAnimating = function(t) {\n    this.tlist.splice(0,this.tlist.length);\n    clearTimeout(this.intervalId);\n    $(Sk.runButton).removeAttr('disabled');\n  }\n\n  SpriteCanvas.prototype.cancelAnimation = function() {\n    if (this.intervalId) {\n      clearTimeout(this.intervalId);\n    }\n\n    for (var t in this.tlist) {\n      this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n    }\n    render();\n  }\n\n  SpriteCanvas.prototype.setSpeedDelay = function(s) {\n    var df = 10 - (s % 11) + 1;\n    this.delay = df * this.timeFactor;\n  }\n\n  SpriteCanvas.prototype.setDelay = function(d) {\n    this.delay = d;\n  }\n\n  SpriteCanvas.prototype.getDelay = function(s) {\n    return this.delay;\n  }\n\n  SpriteCanvas.prototype.setCounter = function(s) {\n    if (!s || s <= 0) {\n      s = 1;\n    }\n    this.renderCounter = s;\n  }\n\n  SpriteCanvas.prototype.getCounter = function() {\n    return this.renderCounter;\n  }\n\n  SpriteCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.context.restore();\n    this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n    if (lly == 0) {\n      this.context.translate(-llx, lly - (ury - lly));\n    }\n    else if (lly > 0) {\n      this.context.translate(-llx, -lly * 2);\n    }\n    else {\n      this.context.translate(-llx, -ury);\n    }\n\n    var xlinescale = (urx - llx) / this.canvas.width;\n    var ylinescale = (ury - lly) / this.canvas.height;\n    this.xptscale = xlinescale;\n    this.yptscale = ylinescale;\n    this.lineScale = Math.min(xlinescale,ylinescale);\n    this.context.save();\n\n    this.llx = llx;\n    this.lly = lly;\n    this.urx = urx;\n    this.ury = ury;\n\n  }\n\n  SpriteCanvas.prototype.window_width = function() {\n    return this.canvas.width;\n  }\n\n  SpriteCanvas.prototype.window_height = function() {\n    return this.canvas.height;\n  }\n\n  SpriteCanvas.prototype.bgcolor = function(c) {\n    this.background_color = c;\n    $(this.canvas).css(\"background-color\",c.v);\n  }\n\n  SpriteCanvas.prototype.setSegmentLength = function(s) {\n    this.segmentLength = s;\n  }\n\n  SpriteCanvas.prototype.getSegmentLength = function() {\n    return this.segmentLength;\n  }\n\n  // todo: if animating, this should be deferred until the proper time\n  SpriteCanvas.prototype.exitonclick = function () {\n    var canvas_id = this.canvasID;\n    var theCanvas = this;\n    $(this.canvas).click(function() {\n      if (! theCanvas.isAnimating()) {\n        if (Sk.tg.fadeOnExit) {\n         $(\"#\"+canvas_id).hide();\n       }\n       $(\"#\"+canvas_id).unbind('click');\n       Sk.tg.canvasInit = false;\n       delete Sk.tg.canvasLib[canvas_id];\n     }\n   });\n  }\n\n  SpriteCanvas.prototype.sprites = function() {\n    return SpriteGraphics.spriteList;\n  }\n\n /**\n  * New version NOT attached to a sprite (as per real sprite)\n  */\n  SpriteCanvas.prototype.tracer = function(t, d) {\n    this.setCounter(t);\n    if (t == 0) {\n      for (var i in this.spriteList) {\n        this.spriteList[i].animate = false;\n      }\n      this.cancelAnimation();\n    }\n    if (d !== undefined) {\n      this.setDelay(d);\n    }\n  }\n\n  // check if all sprites are done\n  allDone = function() {\n    var allDone = true;\n    for (var tix in SpriteGraphics.spriteList) {\n      var theT = SpriteGraphics.spriteList[tix];\n      allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n    }\n    return allDone;\n  }\n\n  //\n  //  This is the function that provides the animation\n  //\n  render = function () {\n    var context = document.getElementById(SpriteGraphics.defaults.canvasID).getContext('2d');\n    with (context) {\n      with (SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID]) {\n        clearRect(llx, lly, (urx - llx), (ury - lly));\n      }\n      var incr = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID].getCounter();\n      var lastCanvas = null;\n\n      SpriteGraphics.renderClock += incr;\n\n      for (var tix in SpriteGraphics.spriteList) {\n        var t = SpriteGraphics.spriteList[tix]\n        lastCanvas = t.spriteCanvas \n        if (t.aCount >= t.drawingEvents.length) {\n          t.aCount = t.drawingEvents.length - 1;\n        }\n        moveTo(0, 0);\n        var currentPos = new Vector(0,0,0);\n        var currentHead = new Vector(1,0,0);\n        lineWidth = t.get_pen_width();\n        lineCap = 'round';\n        lineJoin = 'round';\n        strokeStyle = 'black';\n        var filling = false;\n        if (isNaN(t.spriteCanvas.delay)) {\n          t.spriteCanvas.delay = 0\n        }\n        for (var i = t.clearPoint; (i <= t.aCount || t.spriteCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n          if (i > t.aCount) {\n            // If se jump past aCount, jump it ahead\n            t.aCount = i\n          }\n          var oper = t.drawingEvents[i];\n          var ts = oper[oper.length-1];\n          if (ts <= SpriteGraphics.renderClock || t.spriteCanvas.delay == 0) {\n            if (ts > SpriteGraphics.renderClock) {\n              // If we go past the render clock, jump it ahead\n              SpriteGraphics.renderClock = ts\n            }\n            if (oper[0] == \"LT\") {  //  line to\n              if (! filling) {\n                beginPath();\n                moveTo(oper[1], oper[2]);\n              }\n              lineTo(oper[3], oper[4]);\n              strokeStyle = oper[5];\n              stroke();\n              currentPos = new Vector(oper[3],oper[4],0);\n              if (! filling)\n                closePath();\n            }\n            else if (oper[0] == \"MT\") {  // move to\n              moveTo(oper[3], oper[4]);\n              currentPos = new Vector(oper[3],oper[4],0);\n            }\n            else if (oper[0] == \"BF\") {  // begin fill\n              beginPath();\n              moveTo(oper[1], oper[2]);\n              filling = true;\n            }\n            else if (oper[0] == \"EF\") {  // end fill\n              fillStyle = oper[3];\n              stroke();\n              fill();\n              closePath();\n              filling = false;\n            }\n            else if (oper[0] == \"FC\") {  // fill color\n              fillStyle = oper[1];\n            }\n            else if (oper[0] == \"TC\") {  // sprite color\n              strokeStyle = oper[1];\n            }\n            else if (oper[0] == \"PW\") {  // Pen width\n              lineWidth = oper[1];\n            }\n            else if (oper[0] == \"DT\") {  // Dot\n              var col = fillStyle;\n              fillStyle = oper[2];\n              var size = oper[1];\n              fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n              fillStyle = col;\n            }\n            else if (oper[0] == \"CI\") {  // Circle\n              if (!filling)\n                beginPath();\n              arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n              currentPos = new Vector(oper[1]+Math.cos(oper[5])*oper[3],\n                oper[2]+Math.sin(oper[5])*oper[3],0);\n              stroke();\n              if (! filling) {\n                closePath();\n              }\n            }\n            else if (oper[0] == \"WT\") { // write\n              if (font)\n                font = oper[2];\n              scale(1, -1);\n              fillText(oper[1], oper[3], -oper[4]);\n              scale(1, -1);\n            } else if (oper[0] == \"ST\") {  // stamp\n              t.drawSprite(oper[3], new Vector(oper[1], oper[2], 0));\n            } else if (oper[0] == \"HT\") { // hide sprite\n              t.visible = false;\n            } else if (oper[0] == \"SH\") { // show sprite\n              t.visible = true;\n            } else if (oper[0] == \"TT\") {\n              currentHead = oper[1];\n            } else if (oper[0] == \"CL\") { // RNL clear\n              clear_canvas(t.canvasID);\n              t.clearPoint = i; // Different from reset that calls clear because it leaves the sprites where they are\n            } else if (oper[0] == \"DL\") { // RNL delay\n              var df = oper[1];\n              t.spriteCanvas.delay = df\n            } else if (oper[0] == \"SC\") { // RNL speed change\n              var s = oper[1]\n              if (s < 0)\n                s = 0\n              if (s > 10)\n                s = 10\n              var df = (10 - (s % 11) + 1) * t.spriteCanvas.timeFactor  //  10\n              if (s == 0) {\n                df = 0\n              }\n              // t.spriteCanvas.intervalId = clearInterval(t.spriteCanvas.intervalId);\n              t.spriteCanvas.delay = df;\n              // t.spriteCanvas.intervalId = setInterval(render, t.spriteCanvas.delay)\n              if (oper[2]) {\n                t.spriteCanvas.setSegmentLength(oper[2]);\n              }\n            } else if (oper[0] == \"NO\") {\n              // RNL no op\n            } else {\n            } // end of oper[0] test\n          } // end of if ts < render clock\n        } // end of for\n        t.aCount += incr;\n        if (t.visible) {\n          // draw the sprite\n          t.drawSprite(currentHead.toAngle(), currentPos); // just use currentHead\n        }\n      }\n      // if (t.aCount >= t.drawingEvents.length) {\n      if (SpriteGraphics.renderClock > SpriteGraphics.eventCount ){ // && allDone() ){\n        // t.spriteCanvas.doneAnimating(t);\n        if (lastCanvas) lastCanvas.doneAnimating(t);\n      }\n      else {\n        // t.spriteCanvas.intervalId = setTimeout(render, t.spriteCanvas.delay)\n        if (lastCanvas) {\n          lastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n        }\n      }\n    }\n  }\n\n  // Constructor for Sprite objects\n  function Sprite() {\n    if (arguments.length >= 1) {\n      this.initialize(arguments[0]);\n    }\n    else {\n      this.initialize();\n    }\n    SpriteGraphics.spriteList.push(this);\n  }\n\n  Sprite.prototype.go_home = function () {\n    // Put sprite in initial state\n    // sprite is headed to the right\n    // with position 0,0,0 in the middle of the canvas.\n    // x grows to the right\n    // y grows towards the top of the canvas\n    with (this) {\n      position = home;\n      context.moveTo(home[0], home[1]);\n      heading = new Vector([1.0, 0.0, 0.0]); // to the right; in sprite space x+ direction\n      normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n    }\n  };\n\n  Sprite.prototype.initialize = function () {\n    // Initialize the sprite.\n    var options = { };\n\n    if (arguments.length >= 1) {\n      options = arguments[0];\n    }\n\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n    this.context = document.getElementById(this.canvasID).getContext('2d');\n\n    this.animate = SpriteGraphics.defaults.animate;\n\n    with (this.context) {\n      if (SpriteGraphics.canvasInit == false) {\n        save();\n        translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n        scale(1, -1); // scaling like this flips the y axis the right way.\n        if (! SpriteGraphics.canvasLib[this.canvasID]) {\n          SpriteGraphics.canvasLib[this.canvasID] = new SpriteCanvas(options);\n        }\n        SpriteGraphics.canvasInit = true;\n      }\n      else {\n        clear_canvas(this.canvasID);\n      }\n\n      this.spriteCanvas = SpriteGraphics.canvasLib[this.canvasID];\n      this.home = new Vector([0.0, 0.0, 0.0]);\n      this.visible = true;\n      this.shapeStore = {};\n      this.shapeStore['turtle'] = turtleShapePoints();\n      this.shapeStore['arrow'] = defaultShapePoints();\n      this.shapeStore['circle'] = circleShapePoints();\n      this.shapeStore['classic'] = classicShapePoints();\n      this.currentShape = 'classic';\n      this.drawingEvents = [];\n\n      this.filling = false;\n      this.pen = true;\n      this.penStyle = 'black';\n      this.penWidth = 2;\n      this.fillStyle = 'black';\n      this.position = [ ];\n      this.heading = [ ];\n      this.normal = [ ];\n      this.go_home();\n      this.aCount = 0;\n      this.clearPoint = 0;\n    }\n  }\n\n  function turtleShapePoints() {\n    var pl = [\n    [0,16],\n    [-2,14],\n    [-1,10],\n    [-4,7],\n    [-7,9],\n    [-9,8],\n    [-6,5],\n    [-7,1],\n    [-5,-3],\n    [-8,-6],\n    [-6,-8],\n    [-4,-5],\n    [0,-7],\n    [4,-5],\n    [6,-8],\n    [8,-6],\n    [5,-3],\n    [7,1],\n    [6,5],\n    [9,8],\n    [7,9],\n    [4,7],\n    [1,10],\n    [2,14]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function defaultShapePoints() {\n    var pl = [\n    [-10,0],\n    [10,0],\n    [0,10]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function circleShapePoints() {\n    var pl = [\n    [10,0],\n    [9.51,3.09],\n    [8.09,5.88],\n    [5.88,8.09],\n    [3.09,9.51],\n    [0,10],\n    [-3.09,9.51],\n    [-5.88,8.09],\n    [-8.09,5.88],\n    [-9.51,3.09],\n    [-10,0],\n    [-9.51,-3.09],\n    [-8.09,-5.88],\n    [-5.88,-8.09],\n    [-3.09,-9.51],\n    [-0.00,-10.00],\n    [3.09,-9.51],\n    [5.88,-8.09],\n    [8.09,-5.88],\n    [9.51,-3.09]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function classicShapePoints() {\n    var pl = [\n    [0,0],\n    [-5,-9],\n    [0,-7],\n    [5,-9]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  Sprite.prototype.clean = function () {\n    // Clean the canvas\n    // Optional second argument is color\n    with (this) {\n      if (arguments.length >= 1) {\n        clear_canvas(canvasID, arguments[0]);\n      }\n      else {\n        clear_canvas(canvasID);\n      }\n      initialize();\n    }\n  }\n\n  Sprite.prototype.addDrawingEvent = function(eventList) {\n    SpriteGraphics.eventCount += 1;\n    eventList.push(SpriteGraphics.eventCount);\n    this.drawingEvents.push(eventList);\n  }\n\n  //  \n  //  Drawing Functions\n  //\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n      var head = ep.sub(sp).normalize();\n      var numSegs = Math.floor(ep.sub(sp).len() / sL);\n      var res = [];\n      var oldp = sp;\n      var newp;\n      var op = \"\"\n      if (pen)\n        op = \"LT\"\n      else\n        op = \"MT\"\n      for (var i = 0; i < numSegs; i++) {\n        newp = oldp.linear(1, sL, head);\n        res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n        oldp = newp;\n      }\n      if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n        res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n      return res;\n    }\n\n    Sprite.prototype.draw_line = function(newposition) {\n      with (this) {\n        with (context) {\n          if (! animate) {\n            if (! filling) {\n              beginPath();\n              moveTo(position[0], position[1]);\n            }\n            lineCap = 'round';\n            lineJoin = 'round';\n            lineWidth = get_pen_width();\n            strokeStyle = penStyle;\n            lineTo(newposition[0], newposition[1]);\n            stroke();\n            if (! filling)\n              closePath();\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r) {\n              r[s].push(penStyle);\n              addDrawingEvent(r[s]);\n            }\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n      }\n    }\n\n    Sprite.prototype.forward = function (d) {\n      with (this) {\n        var newposition = position.linear(1, d, heading);\n        goto(newposition);\n      }\n    }\n\n    Sprite.prototype.backward = function(d) {\n      this.forward(-d);\n    }\n\n    // This is an internal function that sets the position without doing any drawing\n    Sprite.prototype.teleport_to = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      this.context.moveTo(newposition[0], newposition[1]);\n      this.position = newposition;\n    }\n\n    Sprite.prototype.goto = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      with (this) {\n        if (pen) {\n          draw_line(newposition);\n        } else {\n          if (! animate) {\n            context.moveTo(newposition[0], newposition[1]);\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r)\n              addDrawingEvent(r[s]);\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n        position = newposition;\n      }\n    }\n\n    Sprite.prototype.delay = function(d) {\n      if (d != null) {\n        if (d < 0) {\n          d = -d;\n        }\n        if (!this.animate) {\n          this.spriteCanvas.setDelay(d);\n        } \n        else {\n          this.spriteCanvas.setDelay(d);\n          this.addDrawingEvent([\"DL\", d]);\n          this.addDrawingEvent([\"NO\"]);\n        }\n      }\n      return this.spriteCanvas.getDelay();\n    }\n\n    Sprite.prototype.speed = function(s,t) {\n      if (s > 0 && !this.animate) {\n        this.animate = true;\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else if (s == 0 && !this.animate) {\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else {\n        // this.animate = false;\n        // this.spriteCanvas.cancelAnimation();\n        this.addDrawingEvent([\"SC\", s, t]);\n        this.addDrawingEvent([\"NO\"]);\n      }\n      if (t) {\n        this.spriteCanvas.setSegmentLength(t);\n        // set the number of units to divide a segment into\n      }\n      else {\n        this.spriteCanvas.setSegmentLength(10);\n      }\n    }\n\n    Sprite.prototype.tracer = function(t, d) {\n      this.spriteCanvas.setCounter(t);\n      if (t == 0) {\n       this.animate=false;\n       this.spriteCanvas.cancelAnimation();\n     }\n     if (d !== undefined)\n       this.spriteCanvas.setDelay(d);\n   }\n\n   Sprite.prototype.getRenderCounter = function() {\n    return this.spriteCanvas.getCounter();\n  }\n\n  Sprite.prototype.turn = function (phi) {\n    with (this) {\n      var alpha = phi * Degree2Rad;\n      var left = normal.cross(heading);\n      var newheading = heading.rotateNormal(left, normal, alpha);\n      heading = newheading;\n\n      if (animate) {\n        addDrawingEvent([\"TT\",heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.right = Sprite.prototype.turn;\n\n  Sprite.prototype.left = function(phi) {\n    this.turn(-phi);\n  }\n\n  Sprite.prototype.get_heading = function () {\n    if (SpriteGraphics.defaults.degrees)\n      return this.heading.toAngle()\n    else\n      return this.heading\n  }\n\n  Sprite.prototype.get_position = function () {\n    return this.position;\n  }\n\n  Sprite.prototype.getx = function () {\n    return this.position[0];\n  }\n\n  Sprite.prototype.gety = function () {\n    return this.position[1];\n  }\n\n  Sprite.prototype.set_heading = function(newhead) {\n    if ((typeof(newhead)).toLowerCase() === 'number') {\n      this.heading = Vector.angle2vec(newhead);\n    } else {\n      this.heading = newhead;\n    }\n  }\n\n  Sprite.prototype.towards = function(to, y) {\n    // set heading vector to point towards another point.\n    if ((typeof(to)).toLowerCase() === 'number')\n      to = new Vector(to, y, 0);\n    else if (! (to instanceof Vector)) {\n      to = new Vector(to);\n    }\n    var res = to.sub(this.position);\n    res = res.normalize();\n    if (SpriteGraphics.defaults.degrees)\n      return res.toAngle();\n    else\n      return res;\n  }\n\n  Sprite.prototype.distance = function(to, y) {\n    if ((typeof(to)).toLowerCase() === 'number')\n      to = new Vector(to, y, 0);\n    return this.position.sub(new Vector(to)).len();\n  }\n\n  Sprite.prototype.dot = function() {\n    var size = 2;\n    if (arguments.length >= 1) size = arguments[0];\n    size = size * this.spriteCanvas.lineScale;\n    with (this) {\n      with (context) {\n        var color = penStyle;\n        var nc = arguments[1] || color;\n        if (! animate) {\n          fillStyle = nc;\n          fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n          fillStyle = color;\n        } else {\n          addDrawingEvent([\"DT\", size, nc, position[0], position[1]]);\n        }\n      }\n    }\n  }\n\n  Sprite.prototype.circle = function(radius, extent) {\n    if (extent === undefined) {\n      extent = 360\n    }\n    if (this.animate) {\n     var arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n     var segLen = this.spriteCanvas.getSegmentLength();\n     if (arcLen <= segLen)\n      this.arc(radius,extent);\n    else {\n        //  Break the arc into segments for animation\n        var extentPart = (segLen / arcLen) * extent;\n        var extentLeft = extent;\n        while (Math.abs(extentLeft) > Math.abs(extentPart)) {\n          this.arc(radius, extentPart);\n          extentLeft = extentLeft - extentPart;\n        }\n        if (Math.abs(extentLeft) > 0.01)\n          this.arc(radius, extentLeft);\n      }\n    } else {\n      this.arc(radius,extent);\n    }\n  }\n  \n  Sprite.prototype.arc = function(radius, extent) {\n    //  Figure out where the sprite is and which way it's facing\n    var spriteHeading = this.get_heading()\n    var tx = this.position[0]\n    var ty = this.position[1]\n\n    //  Figure out the circle center\n    var cx = tx + (radius * Math.cos((spriteHeading + 90) * Degree2Rad));\n    var cy = ty + (radius * Math.sin((spriteHeading + 90) * Degree2Rad));\n\n    //  Canvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Sprite\n\n    //  Figure out our arc angles\n    var startAngleDeg;\n    if (radius >= 0)\n      startAngleDeg = spriteHeading - 90;\n    else\n      startAngleDeg = spriteHeading + 90;\n\n    var endAngleDeg;\n    if (extent) {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + extent;\n      else\n        endAngleDeg = startAngleDeg - extent;\n    }\n    else {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + 360;\n      else\n        endAngleDeg = startAngleDeg - 360;\n    }\n\n    //  Canvas angles are opposite\n    startAngleDeg = 360 - startAngleDeg\n    endAngleDeg   = 360 - endAngleDeg\n\n    //  Becuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n    startAngleDeg = -startAngleDeg\n    endAngleDeg   = -endAngleDeg\n\n    //  Convert to radians\n    var startAngle = startAngleDeg * Degree2Rad;\n    var endAngle   = endAngleDeg   * Degree2Rad;\n\n\n    //  Do the drawing\n    if (! this.animate) {\n      if (!this.filling)\n        this.context.beginPath();\n      this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n      this.context.stroke();\n      if (!this.filling)\n        this.context.closePath();\n    }\n    else {\n      this.addDrawingEvent([\"CI\", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n    }\n\n    //  Move the sprite only if we have to\n    if (extent && (extent % 360) != 0) {\n      var turtleArc;\n      if (radius >= 0)\n        turtleArc = extent;\n      else \n        turtleArc = -extent;\n      var newHeading = (spriteHeading + turtleArc) % 360;\n      if (newHeading < 0)\n        newHeading = newHeading + 360;\n\n      var nx = cx + (radius * Math.cos((newHeading - 90) * Degree2Rad));\n      var ny = cy + (radius * Math.sin((newHeading - 90) * Degree2Rad));  //  y coord is inverted in sprite\n\n      //  Move it internally\n      this.set_heading(newHeading);\n      this.teleport_to(nx,ny);\n\n      //  If we're animating the sprite, move it on the screen\n      if (this.animate) {\n        this.addDrawingEvent([\"TT\", this.heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.write = function(theText, move, align, font) {\n    if (! this.animate) {\n      if (font)\n        this.context.font = font.v;\n      this.context.scale(1, -1);\n      this.context.fillText(theText, this.position[0], -this.position[1]);\n      this.context.scale(1, -1);\n    } else {\n      var fontspec;\n      if (font)\n        fontspec = font.v\n      this.addDrawingEvent([\"WT\", theText, fontspec, this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.spriteCanvas.setworldcoordinates(llx, lly, urx, ury);\n  }\n\n  //\n  // Pen and Style functions\n  //\n  Sprite.prototype.pen_down = function () {\n    this.pen = true;\n  }\n\n  Sprite.prototype.down = Sprite.prototype.pen_down;\n\n  Sprite.prototype.pen_up = function () {\n    this.pen = false;\n  }\n\n  Sprite.prototype.up = Sprite.prototype.pen_up;\n\n  Sprite.prototype.get_pen = function () {\n    return this.pen;\n  }\n\n  Sprite.prototype.set_pen_width = function (w) {\n    if (this.animate)\n      this.addDrawingEvent([\"PW\", w * this.spriteCanvas.lineScale]);\n    else\n      this.penWidth = w;\n  }\n\n  Sprite.prototype.get_pen_width = function() {\n    return this.penWidth * this.spriteCanvas.lineScale;\n  }\n\n  Sprite.prototype.set_pen_color = function (c, g, b) {\n    if (typeof(c) == \"string\") {\n      this.penStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == \"object\" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      }\n      else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16);\n      gs = c1.toString(16);\n      bs = c2.toString(16);\n      while (rs.length < 2) rs = \"0\" + rs;\n      while (gs.length < 2) gs = \"0\" + gs;\n      while (bs.length < 2) bs = \"0\" + bs;\n      c = \"#\" + rs + gs + bs;\n      this.penStyle = c;\n    }\n\n    this.context.strokeStyle = c;\n    if (this.animate)\n      this.addDrawingEvent([\"TC\", c]);\n  }\n\n  Sprite.prototype.set_fill_color = function (c, g, b) {\n    if (typeof(c) == \"string\") {\n      this.fillStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == \"object\" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      } else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16)\n      gs = c1.toString(16)\n      bs = c2.toString(16)\n      while (rs.length < 2) rs = \"0\" + rs;\n      while (gs.length < 2) gs = \"0\" + gs;\n      while (bs.length < 2) bs = \"0\" + bs;\n      c = \"#\" + rs + gs + bs;\n      this.fillStyle = c;\n    }\n\n    this.context.fillStyle = c;\n    if (this.animate)\n      this.addDrawingEvent([\"FC\", c]);\n  }\n\n  Sprite.prototype.begin_fill = function () {\n    if (! this.animate) {\n      this.filling = true;\n      this.context.beginPath();\n      this.context.moveTo(this.position[0], this.position[1]);\n    }\n    else {\n      this.addDrawingEvent([\"BF\", this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.end_fill = function () {\n    if (! this.animate) {\n      this.context.stroke();\n      this.context.fill();\n      this.context.closePath();\n      this.filling = false;\n    } else\n    this.addDrawingEvent([\"EF\", this.position[0], this.position[1], this.fillStyle]);\n  }\n\n  Sprite.prototype.showturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent([\"SH\"]);\n    }\n    this.visible = true;\n  }\n\n  Sprite.prototype.hideturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent([\"HT\"]);\n    }\n    this.visible = false;\n  }\n\n  Sprite.prototype.isvisible = function() {\n    return this.visible;\n  }\n\n  // \n  // Appearance\n  //\n\n  Sprite.prototype.shape = function(s) {\n    if (this.shapeStore[s])\n      this.currentShape = s;\n    else {\n    }\n  }\n\n  Sprite.prototype.drawSprite = function(heading, position) {\n    var rtPoints = [];\n    var plist = this.shapeStore[this.currentShape];\n    var head;\n    if (! (heading === undefined))\n      head = heading - 90.0;\n    else\n      head = this.heading.toAngle() - 90.0;\n    if (! position)\n      position = this.position\n    for (p in plist) {\n      rtPoints.push(plist[p].scale(this.spriteCanvas.xptscale,this.spriteCanvas.yptscale).rotate(head).add(position));\n    }\n    this.context.beginPath();\n    this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n    for (var i = 1; i < rtPoints.length; i++) {\n      this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n    }\n    this.context.closePath();\n    this.context.stroke();\n    if (this.fillStyle) {\n      this.context.fill();\n    }\n  }\n\n  Sprite.prototype.stamp = function() {\n    // either call drawSprite or just add a DT with current position and heading to the drawingEvents list.\n    if (this.animate) {\n      this.addDrawingEvent([\"ST\",this.position[0],this.position[1],this.heading.toAngle()]);\n    } else\n    this.drawSprite();\n  }\n\n  Sprite.prototype.clear = function () {\n    if (this.animate) {\n      this.addDrawingEvent([\"CL\"])\n    }\n    else {\n      clear_canvas(this.canvasID);\n    }\n  }\n\n  function clear_canvas(canId) {\n    with (document.getElementById(canId).getContext('2d')) {\n      if (arguments.length >= 2) {\n        // fillStyle = arguments[1];\n        // fillRect(0, 0, canvas.width, canvas.height);\n      }\n      clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n    }\n  }\n\n\n  // Create a 3d Vector class for manipulating sprite heading, and position.\n\n  function Vector(x, y, z) {\n    if ((typeof(x)).toLowerCase() === 'number') {\n      Array.prototype.push.call(this, x);\n      Array.prototype.push.call(this, y);\n      Array.prototype.push.call(this, z);\n    }\n    else {\n      for (var i in x) {\n        Array.prototype.push.call(this, x[i]);\n      }\n    }\n  }\n\n\n  // Create a vector object given a direction as an angle.\n  Vector.angle2vec = function(phi) {\n    var res = new Vector([0.0,0.0,0.0]);\n    phi = phi * Degree2Rad;\n    res[0] = Math.cos(phi);\n    res[1] = Math.sin(phi);\n    return res.normalize();\n  }\n\n  // This trick allows you to access a Vector object like an array\n  // myVec[0] == x\n  // myVec[1] == y\n  // myVec[2] == z\n  // we really only need the z for the convenience of rotating!\n  // If we were using Geometric Algebra we wouldn't need it at all and could stay in the plane.\n  Vector.prototype.addItem = function(item) {\n    Array.prototype.push.call(this, item);\n  }\n\n  Vector.prototype.linear = function(a, b, v) {\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = a * this[c] + b * v[c];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.cross = function(v) {\n    // Return cross product of this and v\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.rotate = function(angle) {\n    // Rotate this counter clockwise by angle.\n    var perp = new Vector(-this[1], this[0], 0);\n    angle = angle * Degree2Rad;\n    var c = Math.cos(angle);\n    var s = Math.sin(angle);\n    return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n  }\n\n  Vector.prototype.rotateNormal = function(v, w, alpha) {\n    // Return rotation of this in direction of v about w over alpha\n    // Requires: v, w are vectors; alpha is angle in radians\n    //   this, v, w are orthonormal\n    return this.linear(Math.cos(alpha), Math.sin(alpha), v);\n  }\n\n  Vector.prototype.normalize = function() {\n    var n = this.len();\n    var res = this.div(n);\n    return res;\n  }\n\n  Vector.prototype.toAngle = function() {\n    // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n    if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n    if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n    var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n    var deg = rads * Rad2Degree;\n    if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n    else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n    else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n    return deg;\n  }\n\n  // divide all vector components by the same value\n  Vector.prototype.div = function(n) {\n    res = []\n    res[0] = this[0] / n;\n    res[1] = this[1] / n;\n    res[2] = this[2] / n;\n    return new Vector(res);\n  }\n\n  // subtract one vector from another\n  Vector.prototype.sub = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] - v[0];\n    res[1] = this[1] - v[1];\n    res[2] = this[2] - v[2];\n    return res;\n  }\n\n  Vector.prototype.add = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] + v[0];\n    res[1] = this[1] + v[1];\n    res[2] = this[2] + v[2];\n    return res;\n  }\n\n  Vector.prototype.smul = function(k) {  // scalar multiplication\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] * k;\n    res[1] = this[1] * k;\n    res[2] = this[2] * k;\n    return res;\n  }\n\n  Vector.prototype.scale = function(xs,ys) {\n    res = new Vector(0,0,0);\n    res[0] =  this[0] * ys;\n    res[1] =  this[1] * xs;\n    res[2] = 1.0;\n    return res;\n  }\n\n  Vector.prototype.len = function() {\n    return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n  }\n\n  SpriteGraphics.defaults = {canvasID: 'mycanvas', degrees: true, animate: true};\n  SpriteGraphics.spriteList = [];\n  SpriteGraphics.Sprite = Sprite;\n  SpriteGraphics.SpriteCanvas = SpriteCanvas;\n  SpriteGraphics.canvasLib = {};\n  SpriteGraphics.clear_canvas = clear_canvas;\n  SpriteGraphics.Vector = Vector;\n  SpriteGraphics.canvasInit = false;\n  SpriteGraphics.eventCount = 0;\n  SpriteGraphics.renderClock = 0;\n  SpriteGraphics.renderTime  = 0;\n\n})();\n\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  // The exported name of the SPRITE class.\n  var SPRITE = \"Sprite\";\n\n  // First we create an object, this will end up being the class\n  Sk.tg = SpriteGraphics;\n\n  var checkArgs = function(expected, actual, func) {\n    if (actual != expected ) {\n      throw new Sk.builtin.TypeError(func + \" takes exactly \" + expected + \" positional argument (\" + actual + \" given)\");\n    }\n  }\n\n  var sprite = function($gbl, $loc) {\n\n    $loc.__init__ = new Sk.builtin.func(function(self, options) {\n      SpriteGraphics.defaults = {\"canvasID\": Sk.canvas, \"animate\": true, \"degrees\": true};\n      self.skType = SPRITE;\n      self.tp$name = SPRITE;\n      self.v = new SpriteGraphics.Sprite();\n      if (options instanceof Sk.builtin.dict) {\n        for (var iter = options.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n          var v = options.mp$subscript(k);\n          if (v === undefined) {\n            v = null;\n          }\n          var kAsJs = Sk.ffi.remapToJs(k);\n          var vAsJs = Sk.ffi.remapToJs(v);\n          Sk.misceval.callsim(self['__setattr__'], self, kAsJs, v);\n        }\n      }\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n\n      var BACKWARD = \"backward\";\n      var BEGIN_FILL = \"begin_fill\";\n      // color is implemented as a callable attribute for compatibility.\n      var COLOR = \"color\";\n      var DOWN = \"down\";\n      var END_FILL = \"end_fill\";\n      // FILL_COLOR is implemented as a callable attribute for backwcompatibility.\n      var FILL_COLOR = \"fillcolor\";\n      var FORWARD = \"forward\";\n      var GOTO = \"goto\";\n      var LEFT = \"left\";\n      var POSITION = \"position\";\n      var RIGHT = \"right\";\n      // shape is implemented as a callable attribute for compatibility.\n      var SHAPE = \"shape\";\n      var STAMP = \"stamp\";\n      var UP = \"up\";\n      // Capture the target of the attribute operation.\n      var target = self.v;\n\n      switch(key) {\n        case BACKWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BACKWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, BACKWARD);\n              target.forward(-distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n          }, BACKWARD, []));\n        }\n        case BEGIN_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BEGIN_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, BEGIN_FILL);\n              target.begin_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n          }, BEGIN_FILL, []));\n        }\n        case COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if(color) {\n                if (blue) {\n                  target.set_pen_color(color, green, blue);\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_pen_color(color);\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return [target.penStyle, target.fillStyle];\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n          }, COLOR, []));\n        }\n        case DOWN: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = DOWN;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, DOWN);\n              target.pen_down();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(DOWN)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(DOWN)\n            })\n\n          }, DOWN, []));\n        }\n        case END_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = END_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, END_FILL);\n              target.end_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n          }, END_FILL, []));\n        }\n        case FILL_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FILL_COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if (color) {\n                if (blue) {\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return target.fillStyle;\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n          }, FILL_COLOR, []));\n        }\n        case FORWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FORWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, FORWARD);\n              target.forward(distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n          }, FORWARD, []));\n        }\n        case GOTO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = GOTO;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, nx, ny) {\n              nx = Sk.builtin.asnum$(nx);\n              ny = Sk.builtin.asnum$(ny);\n              checkArgs(3, arguments.length, GOTO);\n              target.goto(nx, ny);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n          }, GOTO, []));\n        }\n        case LEFT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = LEFT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, LEFT);\n              target.turn(-angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n          }, LEFT, []));\n        }\n        case POSITION: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = POSITION;\n              checkArgs(1, arguments.length, POSITION);\n            });\n\n            $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n              switch(key) {\n                case \"x\": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[0], Sk.builtin.nmber.float$);\n                }\n                break;\n                case \"y\": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[1], Sk.builtin.nmber.float$);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__setattr__ = new Sk.builtin.func(function(self, key, value) {\n              switch(key) {\n                case \"x\": {\n                  var nx = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(nx, target.gety());\n                }\n                break;\n                case \"y\": {\n                  var ny = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(target.getx(), ny);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n          }, POSITION, []));\n        }\n        case RIGHT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = RIGHT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, RIGHT);\n              target.turn(angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n          }, RIGHT, []));\n        }\n        case SHAPE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = SHAPE;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, shape) {\n              checkArgs(2, arguments.length, SHAPE);\n              target.shape(shape.v);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n          }, SHAPE, []));\n        }\n        case STAMP: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = STAMP;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, STAMP);\n              target.stamp();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n          }, STAMP, []));\n        }\n        case UP: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = UP;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, UP);\n              target.pen_up();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UP)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(UP)\n            })\n\n          }, UP, []));\n        }\n        default: {\n          // Do nothing\n        }\n      }\n    });\n\n    $loc.__setattr__ = new Sk.builtin.func(function(self, name, value) {\n\n      var COLOR = \"color\";\n      var FILL_COLOR = \"fillcolor\";\n      var POSITION = \"position\";\n      var SHAPE = \"shape\";\n\n      switch(name) {\n        case COLOR: {\n          if(value) {\n            var color = value.v || self.v.context.fillStyle;\n            self.v.set_pen_color(color);\n            self.v.set_fill_color(color);\n          }\n        }\n        break;\n        case FILL_COLOR: {\n          if (value) {\n            self.v.set_fill_color(value.v || self.v.context.fillStyle);\n          }\n        }\n        break;\n        case POSITION: {\n          if (value) {\n            checkArgs(3, arguments.length, SHAPE);\n            self.v.goto(value.v[1], value.v[2]);\n          }\n        }\n        break;\n        case SHAPE: {\n          if (value) {\n            checkArgs(3, arguments.length, SHAPE);\n            self.v.shape(value.v);\n          }\n        }\n        break;\n        default: {\n//          throw new Sk.builtin.AttributeError(\"'\" + SPRITE + \"' object has no attribute setter '\" + name + \"'.\");\n        }\n      }\n    });\n\n    $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n      nx = Sk.builtin.asnum$(nx);\n      ny = Sk.builtin.asnum$(ny);\n      checkArgs(3,arguments.length,\"setposition()\");\n      self.v.up();\n      self.v.goto(nx,ny);\n      self.v.down();\n    });\n\n    $loc.setpos = $loc.setposition;\n\n    $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n      newhead = Sk.builtin.asnum$(newhead);\n      checkArgs(2,arguments.length,\"setheading()\");\n      return self.v.set_heading(newhead);\n    });\n\n    $loc.seth = $loc.setheading;\n\n    $loc.home = new Sk.builtin.func(function(self) {\n      self.v.go_home();\n    });\n\n    $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n      size = Sk.builtin.asnum$(size);\n      size = size || 1;\n      if (color) {\n        color = color.v || self.v.penStyle;\n      }\n      self.v.dot(size, color);\n    });\n\n    $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n      radius = Sk.builtin.asnum$(radius);\n      extent = Sk.builtin.asnum$(extent);\n      self.v.circle(radius, extent);\n    });\n\n    $loc.delay = new Sk.builtin.func(function(self, d) {\n      d = Sk.builtin.asnum$(d);\n      return self.v.delay(d);\n    });\n\n    $loc.speed = new Sk.builtin.func(function(self, s, t) {\n      s = Sk.builtin.asnum$(s);\n      t = Sk.builtin.asnum$(t);\n      self.v.speed(s,t);\n    });\n\n    $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n      t = Sk.builtin.asnum$(t);\n      d = Sk.builtin.asnum$(d);\n      self.v.tracer(t, d);\n    });\n\n    $loc.update = new Sk.builtin.func(function(self) {\n      //  Dummy function to emulate update... when not animating, we don't save the drawing operations, so this is pointless for us\n    });\n\n    $loc.heading = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,\"heading()\");\n      return self.v.get_heading();\n    });\n\n    $loc.xcor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,\"xcor()\");\n      var res = self.v.getx();\n      return res;\n    });\n\n    $loc.ycor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,\"ycor()\");\n      var res = self.v.gety();\n      return res;\n    });\n\n    $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === 'number')\n        tx = [tx, ty, 0];\n      return self.v.towards(tx);\n    });\n\n    // tx can be either a number or a vector position.\n    // tx can not be a sprite at this time as multiple sprites have not been implemented yet.\n    $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === 'number') {\n        tx = [tx, ty, 0];\n      }\n      else {\n        tx = [tx.v.getx(), tx.v.gety(), 0];\n      }\n      return self.v.distance(tx);\n    });\n\n    //\n    // Setting and Measurement\n    //\n\n    $loc.width = new Sk.builtin.func(function(self, w) {\n     w = Sk.builtin.asnum$(w);\n     checkArgs(2,arguments.length,\"width()\");\n     self.v.set_pen_width(w);\n   });\n\n    $loc.pensize = $loc.width;\n\n    $loc.isdown = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,\"isdown()\");\n      return self.v.get_pen();\n    });\n\n    $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n      if (color) {\n        if (blue) {\n          color = Sk.builtin.asnum$(color);\n          green = Sk.builtin.asnum$(green);\n          blue = Sk.builtin.asnum$(blue);\n          self.v.set_pen_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n        }\n      }\n      else {\n        return self.v.penStyle;\n      }\n    });\n\n    $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n      if(color) {\n        if (blue) {\n          self.v.set_pen_color(color, green, blue);\n          self.v.set_fill_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n          self.v.set_fill_color(color);\n        }\n      }\n      else {\n        return [self.v.penStyle, self.v.fillStyle];\n      }\n    });\n\n    $loc.fill = new Sk.builtin.func(function(self, fillt) {\n      if (fillt === undefined)\n        return self.v.filling;\n      if (fillt)\n        self.v.begin_fill();\n      else\n        self.v.end_fill();\n    });\n\n    //\n    // More drawing control\n    //\n\n    $loc.reset = new Sk.builtin.func(function(self) {\n      self.v.clean();\n    });\n\n    $loc.showturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,\"showturtle()\");\n      self.v.showturtle();\n    });\n\n    $loc.st = $loc.showturtle;\n\n    $loc.hideturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,\"hideturtle()\");\n      self.v.hideturtle();\n    });\n\n    $loc.ht = $loc.hideturtle;\n\n    $loc.isvisible = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,\"isvisible()\");\n      self.v.isvisible()\n    });\n\n    // todo the move, align, and font parameters should be kwargs...\n    $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n      self.v.write(mystr.v, move, align, font);\n    });\n\n    // todo clean  -- again multiple sprites\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n      llx = Sk.builtin.asnum$(llx);\n      lly = Sk.builtin.asnum$(lly);\n      urx = Sk.builtin.asnum$(urx);\n      ury = Sk.builtin.asnum$(ury);\n      self.v.setworldcoordinates(llx, lly, urx, ury);\n    });\n\n    $loc.clear = new Sk.builtin.func(function(self) {\n      self.v.clear()\n    });\n  }\n\n  mod[SPRITE] = Sk.misceval.buildClass(mod, sprite, SPRITE, []);\n\n  var screen = function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      SpriteGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n      var currentCanvas = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID];\n      if (currentCanvas === undefined) {\n        self.theScreen = new SpriteGraphics.SpriteCanvas(SpriteGraphics.defaults);\n      } else {\n        self.theScreen = currentCanvas;\n      }\n    });\n\n    $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n      self.theScreen.bgcolor(c);\n    });\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n     llx = Sk.builtin.asnum$(llx);\n     lly = Sk.builtin.asnum$(lly);\n     urx = Sk.builtin.asnum$(urx);\n     ury = Sk.builtin.asnum$(ury);\n     self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n   });\n\n    $loc.exitonclick = new Sk.builtin.func(function(self) {\n      self.theScreen.exitonclick();\n    });\n\n    $loc.title = new Sk.builtin.func(function(self,titlestring) {\n      // no op....\n    });\n\n    $loc.window_width = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_width();\n    });\n\n    $loc.window_height = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_height();\n    });\n\n    $loc.sprites = new Sk.builtin.func(function(self) {\n      return self.theScreen.sprites();\n    });\n\n    $loc.colormode = new Sk.builtin.func(function(self) {\n      //  Empty function to emulate compatibility\n    });\n\n    var myfunc = function(self, width, height, startx, starty) {\n      width = Sk.builtin.asnum$(width);\n      height = Sk.builtin.asnum$(height);\n      self.theScreen.setup(width,height);\n    }\n    // this should allow for named parameters\n    myfunc.co_varnames = ['self','width','height','startx','starty'];\n    myfunc.$defaults = [null,500,500,0,0];\n    $loc.setup = new Sk.builtin.func(myfunc);\n  }\n\n  mod.Screen = Sk.misceval.buildClass(mod, screen, 'Screen', []);\n\n  mod.tracer = new Sk.builtin.func(function(t, d) {\n    t = Sk.builtin.asnum$(t);\n    d = Sk.builtin.asnum$(d);\n    for (var i in Sk.tg.canvasLib) {\n      Sk.tg.canvasLib[i].tracer(t, d);\n    }\n  });\n\n  mod.update = new Sk.builtin.func(function(self) {\n    //  Dummy function to emulate update... when not animating, we don't save the drawing operations, so this is pointless for us\n  });\n\n  return mod\n}\n", "src/lib/unittestgui/__init__.py": "__author__ = 'bmiller'\n\nimport document\n\n\nclass unittest:\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.divid = document.currentDiv()\n        self.mydiv = document.getElementById(self.divid)\n        res = document.getElementById(self.divid+'_unit_results')\n        if res:\n            self.resdiv = res\n            res.innerHTML = ''\n        else:\n            self.resdiv = document.createElement('div')\n            self.resdiv.setAttribute('id',self.divid+'_unit_results')\n            self.resdiv.setAttribute('class','unittest-results')\n        self.mydiv.appendChild(self.resdiv)\n\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == 'test' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setup(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def main(self):\n        l = document.createElement('ul')\n        self.resdiv.appendChild(l)\n        self.resList = l\n\n        for func in self.tlist:\n            try:\n                self.setup()\n                func()\n                self.tearDown()\n            except:\n                self.appendResult('Error')\n                self.numFailed += 1\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=\"\"):\n        res = actual==expected\n        self.appendResult(res,str(actual)+' to be equal to ',expected, feedback)\n\n    def assertNotEqual(actual, expected, feedback=\"\"):\n        res = actual != expected\n        self.appendResult(res,str(actual)+' to not equal ',expected,feedback)\n\n    def assertTrue(self,x, feedback=\"\"):\n        res = x\n        self.appendResult(res,str(x)+' to be ',True,feedback)\n\n    def assertFalse(self,x, feedback=\"\"):\n        res = not x\n        self.appendResult(res,str(x)+' to be ',False,feedback)\n\n    def assertIs(self,a,b, feedback=\"\"):\n        res = a is b\n        self.appendResult(res,str(a)+' to be the same object as ',b,feedback)\n\n    def assertIsNot(self,a,b, feedback=\"\"):\n        res = a is not b\n        self.appendResult(res,str(a)+' to not be the same object as ',b,feedback)\n\n    def assertIsNone(self,x, feedback=\"\"):\n        res = x is None\n        self.appendResult(res,x,None,feedback)\n\n    def assertIsNotNone(self,x, feedback=\"\"):\n        res = x is not None\n        self.appendResult(res,str(x)+' to not be ',None,feedback)\n\n    def assertIn(self,a,b, feedback=\"\"):\n        res = a in b\n        self.appendResult(res,str(a)+' to be in ',b,feedback)\n\n    def assertNotIn(self,a,b, feedback=\"\"):\n        res = a not in b\n        self.appendResult(res,str(a)+' to not be in ',b,feedback)\n\n    def assertIsInstance(self,a,b, feedback=\"\"):\n        res = isinstance(a,b)\n        self.appendResult(res,str(a)+' to be an instance of ',b,feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=\"\"):\n        res = not isinstance(a,b)\n        self.appendResult(res,str(a)+' to not be an instance of ',b,feedback)\n\n    def assertAlmostEqual(self,a,b, feedback=\"\"):\n        res = round(a-b,7) == 0\n        self.appendResult(res,str(a)+' to equal ',b,feedback)\n\n    def assertNotAlmostEqual(self,a,b, feedback=\"\"):\n        res = round(a-b,7) != 0\n        self.appendResult(res,str(a)+' to not equal ',b,feedback)\n\n    def assertGreater(self,a,b, feedback=\"\"):\n        res = a > b\n        self.appendResult(res,str(a)+' to be greater than ',b,feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=\"\"):\n        res = a >= b\n        self.appendResult(res,str(a)+' to be greater than or equal to ',b,feedback)\n\n    def assertLess(self,a,b, feedback=\"\"):\n        res = a < b\n        self.appendResult(res,str(a)+' to be less than ',b,feedback)\n\n    def assertLessEqual(self,a,b, feedback=\"\"):\n        res = a <= b\n        self.appendResult(res,str(a)+' to be less than or equal to ',b,feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res == 'Error':\n            msg = 'Error'\n        elif res:\n            msg = 'Pass'\n            self.numPassed += 1\n        else:\n            msg = 'Fail: expected %s  %s ' % (str(actual),str(expected)) + feedback\n            self.numFailed += 1\n\n        pTag = document.createElement('li')\n        pTag.innerHTML = msg\n        self.resList.appendChild(pTag)\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        pTag = document.createElement('p')\n        pTag.innerHTML = \"You passed: \" + str(pct) + \"% of the tests\"\n        self.resdiv.appendChild(pTag)\n        if pct < 90:\n            self.resdiv.setCSS('background-color','#de8e96')\n        else:\n            self.resdiv.setCSS('background-color','#83d382')\n\n\n\n", "src/lib/webgl/matrix4.js": "// more from 'tdl'\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var temp0v3_ = new Float32Array(3);\n    var temp1v3_ = new Float32Array(3);\n    var temp2v3_ = new Float32Array(3);\n\n    var temp0v4_ = new Float32Array(4);\n    var temp1v4_ = new Float32Array(4);\n    var temp2v4_ = new Float32Array(4);\n\n    var temp0m4_ = new Float32Array(16);\n    var temp1m4_ = new Float32Array(16);\n    var temp2m4_ = new Float32Array(16);\n\n    var normalize = function(dst, a) {\n        var n = 0.0;\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            n += a[i] * a[i];\n        n = Math.sqrt(n);\n        if (n > 0.00001) {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = a[i] / n;\n        } else {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = 0;\n        }\n        return dst;\n    };\n\n    var cross = function(dst, a, b) {\n        dst[0] = a[1] * b[2] - a[2] * b[1];\n        dst[1] = a[2] * b[0] - a[0] * b[2];\n        dst[2] = a[0] * b[1] - a[1] * b[0];\n        return dst;\n    };\n\n    var subVector = function(dst, a, b) {\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            dst[i] = a[i] - b[i];\n        return dst;\n    };\n\n    var dot = function(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    };\n\n    mod.lookAt = new Sk.builtin.func(function(view, eye, target, up)\n            {\n                var t0 = temp0v3_;\n                var t1 = temp1v3_;\n                var t2 = temp2v3_;\n\n                var vz = normalize(t0, subVector(t0, eye.v, target.v));\n                var vx = normalize(t1, cross(t1, up.v, vz));\n                var vy = cross(t2, vz, vx);\n\n                var dst = view.v;\n                dst[ 0] = vx[0];\n                dst[ 1] = vy[0];\n                dst[ 2] = vz[0];\n                dst[ 3] = 0;\n                dst[ 4] = vx[1];\n                dst[ 5] = vy[1];\n                dst[ 6] = vz[1];\n                dst[ 7] = 0;\n                dst[ 8] = vx[2];\n                dst[ 9] = vy[2];\n                dst[10] = vz[2];\n                dst[11] = 0;\n                dst[12] = -dot(vx, eye.v);\n                dst[13] = -dot(vy, eye.v);\n                dst[14] = -dot(vz, eye.v);\n                dst[15] = 1;\n\n                return view;\n            });\n\n    mod.perspective = new Sk.builtin.func(function(proj, angle, aspect, near, far)\n            {\n                var f = Math.tan(Math.PI * 0.5 - 0.5 * (angle * Math.PI / 180));\n                var rangeInv = 1.0 / (near - far);\n\n                var dst = proj.v;\n\n                dst[0]  = f / aspect;\n                dst[1]  = 0;\n                dst[2]  = 0;\n                dst[3]  = 0;\n\n                dst[4]  = 0;\n                dst[5]  = f;\n                dst[6]  = 0;\n                dst[7]  = 0;\n\n                dst[8]  = 0;\n                dst[9]  = 0;\n                dst[10] = (near + far) * rangeInv;\n                dst[11] = -1;\n\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = near * far * rangeInv * 2;\n                dst[15] = 0;\n\n                return proj;\n            });\n\n    // builds, not appending\n    mod.rotationY = new Sk.builtin.func(function(target, angle)\n            {\n                var dst = target.v;\n                var c = Math.cos(angle * Math.PI / 180);\n                var s = Math.sin(angle * Math.PI / 180);\n\n                dst[ 0] = c;\n                dst[ 1] = 0;\n                dst[ 2] = -s;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = s;\n                dst[ 9] = 0;\n                dst[10] = c;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n\n                return target;\n            });\n\n    mod.identity = new Sk.builtin.func(function(target)\n            {\n                var dst = target.v;\n                dst[ 0] = 1;\n                dst[ 1] = 0;\n                dst[ 2] = 0;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = 0;\n                dst[ 9] = 0;\n                dst[10] = 1;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n                return target;\n            });\n\n    // row major\n    mod.mul = new Sk.builtin.func(function(target, x, y)\n            {\n                var dst = target.v;\n                var a = x.v;\n                var b = y.v;\n                var a00 = a[0];\n                var a01 = a[1];\n                var a02 = a[2];\n                var a03 = a[3];\n                var a10 = a[ 4 + 0];\n                var a11 = a[ 4 + 1];\n                var a12 = a[ 4 + 2];\n                var a13 = a[ 4 + 3];\n                var a20 = a[ 8 + 0];\n                var a21 = a[ 8 + 1];\n                var a22 = a[ 8 + 2];\n                var a23 = a[ 8 + 3];\n                var a30 = a[12 + 0];\n                var a31 = a[12 + 1];\n                var a32 = a[12 + 2];\n                var a33 = a[12 + 3];\n                var b00 = b[0];\n                var b01 = b[1];\n                var b02 = b[2];\n                var b03 = b[3];\n                var b10 = b[ 4 + 0];\n                var b11 = b[ 4 + 1];\n                var b12 = b[ 4 + 2];\n                var b13 = b[ 4 + 3];\n                var b20 = b[ 8 + 0];\n                var b21 = b[ 8 + 1];\n                var b22 = b[ 8 + 2];\n                var b23 = b[ 8 + 3];\n                var b30 = b[12 + 0];\n                var b31 = b[12 + 1];\n                var b32 = b[12 + 2];\n                var b33 = b[12 + 3];\n                dst[ 0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n                dst[ 1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n                dst[ 2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n                dst[ 3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n                dst[ 4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n                dst[ 5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n                dst[ 6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n                dst[ 7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n                dst[ 8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n                dst[ 9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n                dst[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n                dst[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n                dst[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n                dst[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n                dst[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n                dst[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n                return target;\n            });\n\n    mod.invert = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                var m00 = m[0 * 4 + 0];\n                var m01 = m[0 * 4 + 1];\n                var m02 = m[0 * 4 + 2];\n                var m03 = m[0 * 4 + 3];\n                var m10 = m[1 * 4 + 0];\n                var m11 = m[1 * 4 + 1];\n                var m12 = m[1 * 4 + 2];\n                var m13 = m[1 * 4 + 3];\n                var m20 = m[2 * 4 + 0];\n                var m21 = m[2 * 4 + 1];\n                var m22 = m[2 * 4 + 2];\n                var m23 = m[2 * 4 + 3];\n                var m30 = m[3 * 4 + 0];\n                var m31 = m[3 * 4 + 1];\n                var m32 = m[3 * 4 + 2];\n                var m33 = m[3 * 4 + 3];\n                var tmp_0  = m22 * m33;\n                var tmp_1  = m32 * m23;\n                var tmp_2  = m12 * m33;\n                var tmp_3  = m32 * m13;\n                var tmp_4  = m12 * m23;\n                var tmp_5  = m22 * m13;\n                var tmp_6  = m02 * m33;\n                var tmp_7  = m32 * m03;\n                var tmp_8  = m02 * m23;\n                var tmp_9  = m22 * m03;\n                var tmp_10 = m02 * m13;\n                var tmp_11 = m12 * m03;\n                var tmp_12 = m20 * m31;\n                var tmp_13 = m30 * m21;\n                var tmp_14 = m10 * m31;\n                var tmp_15 = m30 * m11;\n                var tmp_16 = m10 * m21;\n                var tmp_17 = m20 * m11;\n                var tmp_18 = m00 * m31;\n                var tmp_19 = m30 * m01;\n                var tmp_20 = m00 * m21;\n                var tmp_21 = m20 * m01;\n                var tmp_22 = m00 * m11;\n                var tmp_23 = m10 * m01;\n\n                var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\n                    (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\n                var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\n                    (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\n                var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\n                    (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\n                var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\n                    (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\n\n                var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n\n                dst[ 0] = d * t0;\n                dst[ 1] = d * t1;\n                dst[ 2] = d * t2;\n                dst[ 3] = d * t3;\n                dst[ 4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\n                        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\n                dst[ 5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\n                        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\n                dst[ 6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\n                        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\n                dst[ 7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\n                        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\n                dst[ 8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\n                        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\n                dst[ 9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\n                        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\n                dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\n                        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\n                dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\n                        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\n                dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\n                        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\n                dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\n                        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\n                dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\n                        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\n                dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\n                        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\n                return target;\n            });\n\n    mod.transpose = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                for (var j = 0; j < 4; ++j) {\n                    for (var i = 0; i < 4; ++i)\n                    dst[j * 4 + i] = m[i * 4 + j];\n                }\n                return dst;\n            });\n\n    return mod;\n};\n", "src/lib/webgl/__init__.js": "var $builtinmodule = function(name)\n{\n  var mod = {};\n\n  var makeFailHTML = function(msg) {\n    return '' +\n      '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n      '<td align=\"center\">' +\n      '<div style=\"display: table-cell; vertical-align: middle;\">' +\n      '<div style=\"\">' + msg + '</div>' +\n      '</div>' +\n      '</td></tr></table>';\n  };\n\n  var GET_A_WEBGL_BROWSER = '' +\n    'This page requires a browser that supports WebGL.<br/>' +\n    '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n\n  var NEED_HARDWARE = '' +\n    \"It doesn't appear your computer can support WebGL.<br/>\" +\n    '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n  \n  var create3DContext = function(canvas) {\n    var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n    var gl = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        gl = canvas.getContext(names[ii]);\n      }\n      catch(e) {\n      }\n      if (gl) {\n          break;\n      }\n    }\n    if (gl) {\n      // Disallow selection by default. This keeps the cursor from changing to an\n      // I-beam when the user clicks and drags. It's easier on the eyes.\n      function returnFalse() {\n        return false;\n      }\n\n      canvas.onselectstart = returnFalse;\n      canvas.onmousedown = returnFalse;\n    }\n    return gl;\n  };\n\n  var setupWebGL = function(canvasContainerId, opt_canvas) {\n    var container = document.getElementById(canvasContainerId);\n    var context;\n    if (!opt_canvas) {\n      opt_canvas = container.getElementsByTagName(\"canvas\")[0];\n    }\n    if (!opt_canvas) {\n        // this browser doesn't support the canvas tag at all. Not even 2d.\n      container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      return;\n    }\n\n    var gl = create3DContext(opt_canvas);\n    if (!gl) {\n      // TODO(gman): fix to official way to detect that it's the user's machine, not the browser.\n      var browserStrings = navigator.userAgent.match(/(\\w+\\/.*? )/g);\n      var browsers = {};\n      try {\n        for (var b = 0; b < browserStrings.length; ++b) {\n          var parts = browserStrings[b].match(/(\\w+)/g);\n          var bb = [];\n          for (var ii = 1; ii < parts.length; ++ii) {\n            bb.push(parseInt(parts[ii]));\n          }\n          browsers[parts[0]] = bb;\n        }\n      }\n      catch (e) {\n      }\n      if (browsers.Chrome &&\n           (browsers.Chrome[0] > 7 ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] > 0) ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] == 0 && browsers.Chrome[2] >= 521))) {\n        container.innerHTML = makeFailHTML(NEED_HARDWARE);\n      }\n      else {\n        container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      }\n    }\n    return gl;\n  };\n\n  /**\n   * The Context encapsulates the underlying WebGL native JavaScript API.\n   */\n  mod.Context = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(\n      function(self, canvasid) {\n        var canvas = document.getElementById(canvasid.v);\n        var gl = setupWebGL(canvasid.v, canvas)\n        if (!gl) {\n          throw new Error(\"Your browser does not appear to support WebGL.\");\n        }\n\n        self.gl = gl;\n\n        // Copy symbolic constants and functions from native WebGL, encapsulating where necessary.       \n        for (var k in gl.__proto__) {\n          if (typeof gl.__proto__[k] === 'number') {\n            Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str(k), gl.__proto__[k]);\n          }\n          else if (typeof gl.__proto__[k] === \"function\") {\n            switch(k) {\n              case 'bufferData': {\n              }\n              break;\n              case 'clearColor': {\n              }\n              break;\n              case 'drawArrays': {\n              }\n              break;\n              case 'getAttribLocation': {\n              }\n              break;\n              case 'getUniformLocation': {\n              }\n              break;\n              case 'shaderSource': {\n              }\n              break;\n              case 'uniformMatrix4fv': {\n              }\n              break;\n              case 'vertexAttribPointer': {\n              }\n              break;\n              case 'viewport': {\n              }\n              break;\n              default: {\n                (function(key) {\n                  Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str(k), new Sk.builtin.func(function() {\n                    var f = gl.__proto__[key];\n                    return f.apply(gl, arguments);\n                  }));\n                 }(k));\n              }\n            }\n          }\n        }\n\n        gl.clearColor(100.0/255.0, 149.0/255.0, 237.0/255.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      }\n    );\n\n    $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n    $loc.bufferData = new Sk.builtin.func(\n      function(self, target, data, usage) {\n        self.gl.bufferData(target, data.v, usage);\n      }\n    );\n\n    $loc.clearColor = new Sk.builtin.func(\n      function(self, red, green, blue, alpha) {\n        self.gl.clearColor(Sk.builtin.asnum$(red), Sk.builtin.asnum$(green), Sk.builtin.asnum$(blue), Sk.builtin.asnum$(alpha));\n      }\n    );\n\n    $loc.getAttribLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getAttribLocation(program, name.v);\n      }\n    );\n\n    $loc.getUniformLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getUniformLocation(program, name.v);\n      }\n    );\n\n    $loc.shaderSource = new Sk.builtin.func(\n      function(self, shader, src) {\n        self.gl.shaderSource(shader, src.v);\n      }\n    );\n\n    $loc.drawArrays = new Sk.builtin.func(\n      function(self, mode, first, count) {\n        self.gl.drawArrays(Sk.builtin.asnum$(mode), Sk.builtin.asnum$(first), Sk.builtin.asnum$(count));\n      }\n    );\n\n    $loc.vertexAttribPointer = new Sk.builtin.func(\n      function(self, index, size, type, normalized, stride, dunno) {\n        self.gl.vertexAttribPointer(index, Sk.builtin.asnum$(size), Sk.builtin.asnum$(type), normalized, Sk.builtin.asnum$(stride), Sk.builtin.asnum$(dunno));\n      }\n    );\n\n    $loc.viewport = new Sk.builtin.func(\n      function(self, x, y, width, height) {\n        self.gl.viewport(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y), Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n      }\n    );\n\n    $loc.uniformMatrix4fv = new Sk.builtin.func(\n      function(self, location, transpose, values) {\n//        console.log(\"location  \" + (typeof location));\n//        console.log(\"transpose \" + (typeof transpose));\n//        console.log(\"values.v  \" + (typeof values.v));\n        self.gl.uniformMatrix4fv(Sk.builtin.asnum$(location), transpose, values.v);\n      }\n    );\n\n    $loc.setDrawFunc = new Sk.builtin.func(function(self, func) {\n      var startTime = (new Date()).getTime();\n      var intervalId = setInterval(\n        function() {\n          Sk.misceval.callsim(func, self, (new Date()).getTime() - startTime);\n        }, 1000.0 / 60.0); // 60 fps\n    });\n\n  }, 'Context', []);\n\n  mod.Float32Array = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      if (typeof data === \"number\") {\n        self.v = new Float32Array(data);\n      }\n      else {\n        self.v = new Float32Array(Sk.ffi.remapToJs(data));\n      }\n    });\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str(\"[\" + copy.join(', ') + \"]\");\n     });\n  }, 'Float32Array', []);\n\n  /**\n   * A 4x4 (mutable) matrix suitable for OpenGL.\n   *\n   * Mutability is chosen for performance.\n   * The inderlying implementation is Float32Array.\n   * The indexing of the elements is\n   * 0 4  8 12\n   * 1 5  9 13\n   * 2 6 10 14\n   * 3 7 11 15\n   */\n  mod.Matrix4x4 = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      self.v = new Float32Array(Sk.ffi.remapToJs(data));\n    });\n\n    $loc.identity = new Sk.builtin.func(\n      function(self) {\n\n        var m = self.v;\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n      }\n    );\n\n    $loc.perspective = new Sk.builtin.func(\n      function(self, fov, aspect, near, far) {\n        \n        var t = Math.tan(Math.PI * 0.5 - 0.5 * (Sk.builtin.asnum$(fov) * Math.PI / 180));\n        var a = Sk.builtin.asnum$(aspect)\n        var n = Sk.builtin.asnum$(near)\n        var f = Sk.builtin.asnum$(far)\n        var k = 1.0 / (n - f);\n\n        var m = self.v;\n\n        m[0]  = t / a;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = t;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = (n + f) * k;\n        m[11] = -1;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = n * f * k * 2;\n        m[15] = 0;\n      }\n    );\n\n    $loc.translate = new Sk.builtin.func(\n      function(self, translation) {\n\n        var m = self.v;\n        var t = Sk.ffi.remapToJs(translation);\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = t[0];\n        m[13] = t[1];\n        m[14] = t[2];\n        m[15] = 1;\n      }\n    );\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str(\"[\" + copy.join(', ') + \"]\");\n     });\n  }, 'Matrix4x4', []);\n\n  return mod;\n};", "src/builtin/sys.js": "var $builtinmodule = function(name)\n{\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (var i = 0; i < argv.length; ++i)\n        args.push(new Sk.builtin.str(argv[i]));\n    sys.argv = new Sk.builtins['list'](args);\n\n    sys.copyright = Sk.builtin['str'](\"Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n\");\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.getExecutionLimit = new Sk.builtin.func(function() {\n        return Sk.execLimit\n    });\n\n    sys.setExecutionLimit = new Sk.builtin.func(function(t) {\n        if (t !==  undefined) {\n            Sk.execLimit = t\n        }\n    });\n\n    sys.resetTimeout = new Sk.builtin.func(function() {\n        Sk.execStart = new Date();\n    });\n\n    sys.debug = new Sk.builtin.func(function() {\n        debugger;\n    });\n\n    return sys;\n};\n", "src/lib/pythonds/trees/balance.py": "#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    '''\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n", "src/lib/urllib/request/__init__.js": "var $builtinmodule = function(name)\n{\n  var request = {};\n\n\n  //~ Classes .................................................................\n\n  // Response class\n  //\n  // Response objects are returned by the request, get, post, etc.\n  // methods, allowing the user to access the response text, status\n  // code, and other information.\n\n  // ------------------------------------------------------------\n  var response = function($gbl, $loc) {\n\n    // ------------------------------------------------------------\n    $loc.__init__ = new Sk.builtin.func(function(self, xhr) {\n      self.data$ = xhr.responseText;\n      self.lineList = self.data$.split(\"\\n\");\n      self.lineList = self.lineList.slice(0,-1);\n      for(var i =0 ; i < self.lineList.length; i++) {\n        self.lineList[i] = self.lineList[i]+'\\n';\n      }\n      self.currentLine = 0;\n      self.pos$ = 0;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return Sk.ffi.remapToPy('<Response>');\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__iter__ = new Sk.builtin.func(function(self) {\n      var allLines = self.lineList;\n\n      return Sk.builtin.makeGenerator(function() {\n          if (this.$index >= this.$lines.length) return undefined;\n          return new Sk.builtin.str(this.$lines[this.$index++]);\n        }, {\n          $obj: self,\n          $index: 0,\n          $lines: allLines\n        });\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.read = new Sk.builtin.func(function(self, size) {\n      if (self.closed) throw new Sk.builtin.ValueError(\"I/O operation on closed file\");\n      var len = self.data$.length;\n      if (size === undefined) size = len;\n      var ret = new Sk.builtin.str(self.data$.substr(self.pos$, size));\n      self.pos$ += size;\n      if (self.pos$ >= len) self.pos$ = len;\n      return ret;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readline = new Sk.builtin.func(function(self, size) {\n      var line = \"\";\n      if (self.currentLine < self.lineList.length) {\n        line = self.lineList[self.currentLine];\n        self.currentLine++;\n      }\n      return new Sk.builtin.str(line);\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readlines = new Sk.builtin.func(function(self, sizehint) {\n      var arr = [];\n      for(var i = self.currentLine; i < self.lineList.length; i++) {\n        arr.push(new Sk.builtin.str(self.lineList[i]));\n      }\n      return new Sk.builtin.list(arr);\n    });\n\n  };\n\n  request.Response =\n    Sk.misceval.buildClass(request, response, 'Response', []);\n\n\n  //~ Module functions ........................................................\n\n  // ------------------------------------------------------------\n  /**\n   * Constructs and sends a Request. Returns Response object.\n   *\n   * http://docs.python-requests.org/en/latest/api/#requests.request\n   *\n   * For now, this implementation doesn't actually construct a Request\n   * object; it just makes the request through jQuery.ajax and then\n   * constructs a Response.\n   */\n  request.urlopen = new Sk.builtin.func(function(url, data, timeout) {\n    var xmlhttp = new XMLHttpRequest();\n    xmlhttp.open(\"GET\",url.v,false);\n    xmlhttp.send(null);\n\n    return Sk.misceval.callsim(request.Response,xmlhttp)\n  });\n\n\n  return request;\n};\n", "src/lib/pythonds/basic/queue.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#queue.py\r\n\r\nclass Queue:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def enqueue(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def dequeue(self):\r\n        return self.items.pop()\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n", "src/lib/pythonds/graphs/adjGraph.py": "#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = 'white'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + \":color \" + self.color + \":disc \" + str(self.disc) + \":fin \" + str(self.fin) + \":dist \" + str(self.dist) + \":pred \\n\\t[\" + str(self.pred)+ \"]\\n\"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open(\"test.dat\")\n        for line in gFile:\n            fVertex, tVertex = line.split('|')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == '__main__':\n    unittest.main()\n              \n", "src/lib/easel/__init__.js": "/**\n * Geometric Algebra (e2ga) module.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n\n  var CONTAINER                 = \"Container\";\n  var EASE                      = \"Ease\";\n  var EUCLIDEAN_2               = \"Euclidean2\";\n  var EVENT                     = \"Event\";\n  var GRAPHICS                  = \"Graphics\";\n  var MOVIE_CLIP                = \"MovieClip\";\n  var POINT                     = \"Point\";\n  var SHAPE                     = \"Shape\";\n  var STAGE                     = \"Stage\";\n  var TEXT                      = \"Text\";\n  var TICKER                    = \"Ticker\";\n  var TWEEN                     = \"Tween\";\n\n  var PROP_ALPHA                = \"alpha\";\n  var PROP_AUTO_CLEAR           = \"autoClear\";\n  var PROP_BOUNCE_OUT           = \"bounceOut\";\n  var PROP_CANVAS               = \"canvas\";\n  var PROP_GRAPHICS             = \"graphics\";\n  var PROP_MOUSE_IN_BOUNDS      = \"mouseInBounds\";\n  var PROP_MOUSE_MOVE_OUTSIDE   = \"mouseMoveOutside\";\n  var PROP_MOUSE_X              = \"mouseX\";\n  var PROP_MOUSE_Y              = \"mouseY\";\n  var PROP_NAME                 = \"name\";\n  var PROP_ROTATION             = \"rotation\";\n  var PROP_TEXT                 = \"text\";\n  var PROP_TEXT_ALIGN           = \"textAlign\";\n  var PROP_TIMELINE             = \"timeline\";\n  var PROP_W                    = \"w\";\n  var PROP_X                    = \"x\";\n  var PROP_Y                    = \"y\";\n  var PROP_XY                   = \"xy\";\n\n  var METHOD_ADD_CHILD          = \"addChild\";\n  var METHOD_ADD_EVENT_LISTENER = \"addEventListener\";\n  var METHOD_ADD_TWEEN          = \"addTween\";\n  var METHOD_BEGIN_FILL         = \"beginFill\";\n  var METHOD_BEGIN_STROKE       = \"beginStroke\";\n  var METHOD_CALL               = \"onComplete\";\n  var METHOD_CLONE              = \"clone\";\n  var METHOD_DRAW_CIRCLE        = \"drawCircle\";\n  var METHOD_DRAW_RECT          = \"drawRect\";\n  var METHOD_ENABLE_MOUSE_OVER  = \"enableMouseOver\";\n  var METHOD_END_FILL           = \"endFill\";\n  var METHOD_END_STROKE         = \"endStroke\";\n  var METHOD_GET                = \"get\";\n  var METHOD_GET_CHILD_AT       = \"getChildAt\";\n  var METHOD_GET_NUM_CHILDREN   = \"getNumChildren\";\n  var METHOD_GLOBAL_TO_LOCAL    = \"globalToLocal\";\n  var METHOD_GOTO_AND_PLAY      = \"gotoAndPlay\";\n  var METHOD_HIT_TEST           = \"hitTest\";\n  var METHOD_LENGTH             = \"length\";\n  var METHOD_LOCAL_TO_LOCAL     = \"localToLocal\";\n  var METHOD_LINE_TO            = \"lineTo\";\n  var METHOD_MOVE_TO            = \"moveTo\";\n  var METHOD_SET_STROKE_STYLE   = \"setStrokeStyle\";\n  var METHOD_TO                 = \"to\";\n  var METHOD_UPDATE             = \"update\";\n  var METHOD_WAIT               = \"wait\";\n\n  var mod = {};\n\n  function isNumber(x)    { return typeof x === 'number'; }\n\n  function remapE2ToPy(x00, x01, x10, x11) {\n    return Sk.misceval.callsim(mod[EUCLIDEAN_2],\n      Sk.builtin.assk$(x00, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x01, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x10, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x11, Sk.builtin.nmber.float$));\n  }\n\n  function stringFromCoordinates(coordinates, labels, multiplier) {\n    var append, i, sb, str, _i, _ref;\n    sb = [];\n    append = function(number, label) {\n      var n;\n      if (number !== 0) {\n        if (number >= 0) {\n          if (sb.length > 0) {\n            sb.push(\"+\");\n          }\n        } else {\n          sb.push(\"-\");\n        }\n        n = Math.abs(number);\n        if (n === 1) {\n          return sb.push(label);\n        } else {\n          sb.push(n.toString());\n          if (label !== \"1\") {\n            sb.push(multiplier);\n            return sb.push(label);\n          }\n        }\n      }\n    };\n    for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n      append(coordinates[i], labels[i]);\n    }\n    if (sb.length > 0) {\n      str = sb.join(\"\");\n    } else {\n      str = \"0\";\n    }\n    return str;\n  }\n\n  function divide(a00, a01, a10, a11, b00, b01, b10, b11, x) {\n    // r = ~b\n    var r00 = +b00;\n    var r01 = +b01;\n    var r10 = +b10;\n    var r11 = -b11;\n    // m = b * r\n    var m00 = b00 * r00 + b01 * r01 + b10 * r10 - b11 * r11;\n    var m01 = 0;\n    var m10 = 0;\n    var m11 = 0;\n    // c = cliffordConjugate(m)\n    var c00 = +m00;\n    var c01 = -m01;\n    var c10 = -m10;\n    var c11 = -m11;\n    // s = r * c\n    var s00 = r00 * c00 + r01 * c01 + r10 * c10 - r11 * c11;\n    var s01 = r00 * c01 + r01 * c00 - r10 * c11 + r11 * c10;\n    var s10 = r00 * c10 + r01 * c11 + r10 * c00 - r11 * c01;\n    var s11 = r00 * c11 + r01 * c10 - r10 * c01 + r11 * c00;\n    // k = b * s\n    var k00 = b00 * s00 + b01 * s01 + b10 * s10 - b11 * s11;\n    // i = inverse(b)\n    var i00 = s00/k00;\n    var i01 = s01/k00;\n    var i10 = s10/k00;\n    var i11 = s11/k00;\n    // x = a * inverse(b)\n    var x00 = a00 * i00 + a01 * i01 + a10 * i10 - a11 * i11;\n    var x01 = a00 * i01 + a01 * i00 - a10 * i11 + a11 * i10;\n    var x10 = a00 * i10 + a01 * i11 + a10 * i00 - a11 * i01;\n    var x11 = a00 * i11 + a01 * i10 - a10 * i01 + a11 * i00;\n    if (typeof x !== 'undefined') {\n      x[0] = x00;\n      x[1] = x01;\n      x[2] = x10;\n      x[3] = x11;\n    }\n    else {\n      return remapE2ToPy(x00, x01, x10, x11);\n    }\n  }\n\n  mod[EVENT] = Sk.builtin.event(mod);\n\n  mod[GRAPHICS] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, graphicsPy) {\n      self.tp$name = GRAPHICS;\n      var graphics = Sk.ffi.remapToJs(graphicsPy);\n      if (graphics) {\n        self.v = graphics;\n      }\n      else {\n        if (typeof createjs[GRAPHICS] === 'undefined') {\n          throw new Error(\"Missing \" + GRAPHICS + \" JavaScript implementation.\");\n        }\n        self.v = new createjs[GRAPHICS]();\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(graphicsPy, name) {\n      var graphics = Sk.ffi.remapToJs(graphicsPy);\n      switch(name) {\n        case METHOD_BEGIN_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_BEGIN_FILL;\n              self.v = graphics[METHOD_BEGIN_FILL];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color) {\n              color = Sk.ffi.remapToJs(color);\n              graphics[METHOD_BEGIN_FILL](color);\n              return graphicsPy;\n            });\n          }, METHOD_BEGIN_FILL, []));\n        }\n        case METHOD_BEGIN_STROKE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_BEGIN_STROKE;\n              self.v = graphics[METHOD_BEGIN_STROKE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color) {\n              color = Sk.ffi.remapToJs(color);\n              graphics[METHOD_BEGIN_STROKE](color);\n              return graphicsPy;\n            });\n          }, METHOD_BEGIN_STROKE, []));\n        }\n        case METHOD_DRAW_CIRCLE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_DRAW_CIRCLE;\n              self.v = graphics[METHOD_DRAW_CIRCLE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y, radius) {\n              x = Sk.ffi.remapToJs(x);\n              y = Sk.ffi.remapToJs(y);\n              radius = Sk.ffi.remapToJs(radius);\n              graphics[METHOD_DRAW_CIRCLE](x, y, radius);\n              return graphicsPy;\n            });\n          }, METHOD_DRAW_CIRCLE, []));\n        }\n        case METHOD_DRAW_RECT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_DRAW_RECT;\n              self.v = graphics[METHOD_DRAW_RECT];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y, w, h) {\n              x = Sk.ffi.remapToJs(x);\n              y = Sk.ffi.remapToJs(y);\n              w = Sk.ffi.remapToJs(w);\n              h = Sk.ffi.remapToJs(h);\n              graphics[METHOD_DRAW_RECT](x, y, w, h);\n              return graphicsPy;\n            });\n          }, METHOD_DRAW_RECT, []));\n        }\n        case METHOD_END_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_END_FILL;\n              self.v = graphics[METHOD_END_FILL];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              graphics[METHOD_END_FILL]();\n              return graphicsPy;\n            });\n          }, METHOD_END_FILL, []));\n        }\n        case METHOD_END_STROKE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_END_STROKE;\n              self.v = graphics[METHOD_END_STROKE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              graphics[METHOD_END_STROKE]();\n              return graphicsPy;\n            });\n          }, METHOD_END_STROKE, []));\n        }\n        case METHOD_LINE_TO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LINE_TO;\n              self.v = graphics[METHOD_LINE_TO];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y) {\n              x = Sk.ffi.remapToJs(x);\n              y = Sk.ffi.remapToJs(y);\n              graphics[METHOD_LINE_TO](x, y);\n              return graphicsPy;\n            });\n          }, METHOD_LINE_TO, []));\n        }\n        case METHOD_MOVE_TO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_MOVE_TO;\n              self.v = graphics[METHOD_MOVE_TO];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y) {\n              x = Sk.ffi.remapToJs(x);\n              y = Sk.ffi.remapToJs(y);\n              graphics[METHOD_MOVE_TO](x, y);\n              return graphicsPy;\n            });\n          }, METHOD_MOVE_TO, []));\n        }\n        case METHOD_SET_STROKE_STYLE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_STROKE_STYLE;\n              self.v = graphics[METHOD_SET_STROKE_STYLE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, thickness, caps, joints, miterLimit, ignoreScale) {\n              thickness = Sk.ffi.remapToJs(thickness);\n              caps = Sk.ffi.remapToJs(caps);\n              joints = Sk.ffi.remapToJs(joints);\n              miterLimit = Sk.ffi.remapToJs(miterLimit);\n              ignoreScale = Sk.ffi.remapToJs(ignoreScale);\n              graphics[METHOD_SET_STROKE_STYLE](thickness, caps, joints, miterLimit, ignoreScale);\n              return graphicsPy;\n            });\n          }, METHOD_SET_STROKE_STYLE, []));\n        }\n      }\n    });\n  }, GRAPHICS, []);\n\n  mod[MOVIE_CLIP] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, modePy, startPositionPy, loopPy, labelsPy) {\n      var mode = (modePy !== null) ? Sk.ffi.remapToJs(modePy) : null;\n      var startPosition = Sk.ffi.remapToJs(startPositionPy);\n      var loop = Sk.ffi.remapToJs(loopPy);\n      var labels = Sk.ffi.remapToJs(labelsPy);\n      self.tp$name = MOVIE_CLIP;\n      if (typeof createjs[MOVIE_CLIP] === 'undefined') {\n        throw new Error(\"Missing \" + MOVIE_CLIP + \" JavaScript implementation.\");\n      }\n      self.v = new createjs[MOVIE_CLIP](mode, startPosition, loop, labels);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(movieClipPy, name) {\n      var movieClip = Sk.ffi.remapToJs(movieClipPy);\n      switch(name) {\n        case PROP_TIMELINE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = PROP_TIMELINE;\n              self.v = movieClip.timeline;\n            });\n            $loc.__getattr__ = new Sk.builtin.func(function(timelinePy, name) {\n              var timeline = Sk.ffi.remapToJs(timelinePy);\n              switch(name) {\n                case METHOD_ADD_TWEEN: {\n                  return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                    $loc.__init__ = new Sk.builtin.func(function(self) {\n                      self.tp$name = METHOD_ADD_TWEEN;\n                      self.v = timeline[METHOD_ADD_TWEEN];\n                    });\n                    $loc.__call__ = new Sk.builtin.func(function(self, tweenPy) {\n                      var tween = Sk.ffi.remapToJs(tweenPy);\n                      timeline.addTween(tween);\n                    });\n                  }, METHOD_ADD_TWEEN, []));\n                }\n                break;\n              }\n            });\n          }, PROP_TIMELINE, []));\n        }\n        break;\n        case METHOD_GOTO_AND_PLAY: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GOTO_AND_PLAY;\n              self.v = movieClip[METHOD_GOTO_AND_PLAY];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, labelPy) {\n              var label = Sk.ffi.remapToJs(labelPy);\n              movieClip[METHOD_GOTO_AND_PLAY](label);\n            });\n          }, METHOD_GOTO_AND_PLAY, []));\n        }\n        break;\n       }\n    });\n  }, MOVIE_CLIP, []);\n\n  mod[SHAPE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(shapePy, argPy) {\n      shapePy.tp$name = SHAPE;\n      if (typeof argPy === 'undefined') {\n        shapePy.v = new createjs[SHAPE]();\n      }\n      else {\n        var name = argPy.tp$name;\n        if (typeof name === 'string') {\n          switch(name) {\n            case SHAPE: {\n              shapePy.v = Sk.ffi.remapToJs(argPy);\n            }\n            break;\n            case GRAPHICS: {\n              shapePy.v = new createjs[SHAPE](Sk.ffi.remapToJs(argPy));\n            }\n            break;\n            default: {\n              throw new Error(name);\n            }\n          }\n        }\n        else {\n          throw new Error(typeof name);\n        }\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(shapePy, name) {\n      var shape = Sk.ffi.remapToJs(shapePy);\n      switch(name) {\n        case PROP_ALPHA: {\n          return Sk.builtin.assk$(shape[PROP_ALPHA], Sk.builtin.nmber.float$);\n        }\n        case PROP_GRAPHICS: {\n          return Sk.misceval.callsim(mod[GRAPHICS], Sk.ffi.referenceToPy(shape.graphics, GRAPHICS));\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(shape[PROP_NAME]);\n        }\n        case PROP_X: {\n          return Sk.builtin.assk$(shape[PROP_X], Sk.builtin.nmber.int$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(shape[PROP_Y], Sk.builtin.nmber.int$);\n        }\n        case PROP_ROTATION: {\n          return Sk.builtin.assk$(shape[PROP_ROTATION], Sk.builtin.nmber.float$);\n        }\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.builtin.addEventListener(mod, shape);\n        }\n        case METHOD_GLOBAL_TO_LOCAL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GLOBAL_TO_LOCAL;\n              self.v = shape[METHOD_GLOBAL_TO_LOCAL];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, x, y) {\n              var point = shape[METHOD_GLOBAL_TO_LOCAL](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y));\n              return Sk.misceval.callsim(mod[POINT], Sk.ffi.referenceToPy(point, POINT));\n            });\n          }, METHOD_GLOBAL_TO_LOCAL, []));\n        }\n        case METHOD_HIT_TEST: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_HIT_TEST;\n              self.v = shape[METHOD_HIT_TEST];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, x, y) {\n              return Sk.ffi.remapToPy(shape[METHOD_HIT_TEST](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y)));\n            });\n          }, METHOD_HIT_TEST, []));\n        }\n        case METHOD_LOCAL_TO_LOCAL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOCAL_TO_LOCAL;\n              self.v = shape[METHOD_LOCAL_TO_LOCAL];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, x, y, target) {\n              var point = shape[METHOD_LOCAL_TO_LOCAL](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y), Sk.ffi.remapToJs(target));\n              return Sk.misceval.callsim(mod[POINT], Sk.ffi.referenceToPy(point, POINT));\n            });\n          }, METHOD_LOCAL_TO_LOCAL, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(shapePy, name, valuePy) {\n      var shape = Sk.ffi.remapToJs(shapePy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_ALPHA: {\n          shape[PROP_ALPHA] = value;\n        }\n        break;\n        case PROP_NAME: {\n          shape[PROP_NAME] = value;\n        }\n        break;\n        case PROP_X: {\n          shape[PROP_X] = value;\n        }\n        break;\n        case PROP_Y: {\n          shape[PROP_Y] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          shape[PROP_ROTATION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not a writeable attribute of \" + SHAPE);\n        }\n      }\n    });\n  }, SHAPE, []);\n\n  mod[STAGE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, canvasPy) {\n      var canvas = Sk.ffi.remapToJs(canvasPy);\n      self.tp$name = STAGE;\n      if (typeof createjs[STAGE] === 'undefined') {\n        throw new Error(\"Missing \" + STAGE + \" JavaScript implementation.\");\n      }\n      self.v = new createjs[STAGE](canvas);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(stagePy, name) {\n      var stage = Sk.ffi.remapToJs(stagePy);\n      switch(name) {\n        case PROP_CANVAS: {\n          return Sk.builtin.assk$(5, Sk.builtin.nmber.int$);\n        }\n        case PROP_MOUSE_IN_BOUNDS: {\n          return Sk.ffi.remapToPy(stage[PROP_MOUSE_IN_BOUNDS]);\n        }\n        case PROP_MOUSE_MOVE_OUTSIDE: {\n          return Sk.ffi.remapToPy(stage[PROP_MOUSE_MOVE_OUTSIDE]);\n        }\n        case PROP_MOUSE_X: {\n          return Sk.builtin.assk$(stage[PROP_MOUSE_X], Sk.builtin.nmber.int$);\n        }\n        case PROP_MOUSE_Y: {\n          return Sk.builtin.assk$(stage[PROP_MOUSE_Y], Sk.builtin.nmber.int$);\n        }\n        case METHOD_ADD_CHILD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ADD_CHILD;\n              self.v = stage[METHOD_ADD_CHILD];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, childPy) {\n              var child = stage.addChild(Sk.ffi.remapToJs(childPy));\n              return Sk.misceval.callsim(mod[childPy.tp$name], Sk.ffi.referenceToPy(child, childPy.tp$name));\n            });\n          }, METHOD_ADD_CHILD, []));\n        }\n        case METHOD_ENABLE_MOUSE_OVER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ENABLE_MOUSE_OVER;\n              self.v = stage[METHOD_ENABLE_MOUSE_OVER];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(updatePy) {\n              stage[METHOD_ENABLE_MOUSE_OVER]();\n            });\n          }, METHOD_ENABLE_MOUSE_OVER, []));\n        }\n        case METHOD_UPDATE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_UPDATE;\n              self.v = stage[METHOD_UPDATE];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(updatePy) {\n              stage[METHOD_UPDATE]();\n            });\n          }, METHOD_UPDATE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(stagePy, name, valuePy) {\n      var stage = Sk.ffi.remapToJs(stagePy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          stage[PROP_AUTO_CLEAR] = value;\n        }\n        break;\n        case PROP_MOUSE_MOVE_OUTSIDE: {\n          stage[PROP_MOUSE_MOVE_OUTSIDE] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not a writeable attribute of \" + STAGE);\n        }\n      }\n    });\n  }, STAGE, []);\n\n  mod[TEXT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(selfPy, textPy, fontPy, colorPy) {\n      selfPy.tp$name = TEXT;\n      var text = Sk.ffi.remapToJs(textPy);\n      var font = Sk.ffi.remapToJs(fontPy);\n      var color = Sk.ffi.remapToJs(colorPy);\n      selfPy.v = new createjs[TEXT](text, font, color);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(textPy, name) {\n      var text = Sk.ffi.remapToJs(textPy);\n      switch(name) {\n        case PROP_X: {\n          return Sk.builtin.assk$(text[PROP_X], Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(text[PROP_Y], Sk.builtin.nmber.float$);\n        }\n        case PROP_ROTATION: {\n          return Sk.builtin.assk$(text[PROP_ROTATION], Sk.builtin.nmber.float$);\n        }\n        case PROP_TEXT: {\n          return new Sk.builtin.str(text[PROP_TEXT]);\n        }\n        case PROP_TEXT_ALIGN: {\n          return new Sk.builtin.str(text[PROP_TEXT_ALIGN]);\n        }\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.builtin.addEventListener(mod, text);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(textPy, name, valuePy) {\n      var text = Sk.ffi.remapToJs(textPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_X: {\n          text[PROP_X] = value;\n        }\n        break;\n        case PROP_Y: {\n          text[PROP_Y] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          text[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_TEXT: {\n          text[PROP_TEXT] = value;\n        }\n        break;\n        case PROP_TEXT_ALIGN: {\n          text[PROP_TEXT_ALIGN] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not a writeable attribute of \" + TEXT);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(selfPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      return new Sk.builtin.str(TEXT + \"(\" + self.x + \", \" + self.y + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(selfPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      return new Sk.builtin.str(\"[\" + self.x + \", \" + self.y + \"]\");\n    });\n  }, TEXT, []);\n\n  mod[TICKER] = Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = TICKER;\n      self.v = createjs[TICKER];\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(tickerPy, name) {\n      var ticker = Sk.ffi.remapToJs(tickerPy);\n      switch(name) {\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ADD_EVENT_LISTENER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, typePy, listenerPy, useCapture) {\n              var type = Sk.ffi.remapToJs(typePy);\n              var listener = Sk.ffi.remapToJs(listenerPy);\n              if (typeof listener === 'object') {\n                ticker[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);\n              }\n              else {\n                var listener = function(event) {\n                  Sk.misceval.callsim(listenerPy);\n                };\n                ticker[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);\n              }\n            });\n          }, METHOD_ADD_EVENT_LISTENER, []));\n        }\n        break;\n      }\n    });\n  }, TICKER, []));\n\n  mod[TWEEN] = Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = TWEEN;\n      self.v = createjs[TWEEN];\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(entryPointPy, name) {\n      var entryPoint = Sk.ffi.remapToJs(entryPointPy);\n      switch(name) {\n        case METHOD_GET: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, target, props, pluginData, override) {\n              target = Sk.ffi.remapToJs(target);\n              props = Sk.ffi.remapToJs(props);\n              pluginData = Sk.ffi.remapToJs(pluginData);\n              override = Sk.ffi.remapToJs(override);\n              var tween = entryPoint[METHOD_GET](target, props, pluginData, override);\n              return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                $loc.__init__ = new Sk.builtin.func(function(self) {\n                  self.tp$name = TWEEN;\n                  self.v = tween;\n                });\n                $loc.__getattr__ = new Sk.builtin.func(function(tweenPy, name) {\n                  var tween = Sk.ffi.remapToJs(tweenPy);\n                  switch(name) {\n                    case METHOD_TO: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_TO;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, props, duration, ease) {\n                          props = Sk.ffi.remapToJs(props);\n                          duration = Sk.ffi.remapToJs(duration);\n                          ease = Sk.ffi.remapToJs(ease);\n                          tween[METHOD_TO](props, duration, ease);\n                          return tweenPy;\n                        });\n                      }, METHOD_TO, []));\n                    }\n                    break;\n                    case METHOD_CALL: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_CALL;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, callbackPy, argsPy) {\n                          var callbackJS = function(argsJs) {\n                            Sk.misceval.callsim(callbackPy, Sk.ffi.remapToPy(argsJs));\n                          };\n                          var argsJs = Sk.ffi.remapToJs(argsPy);\n                          tween.call(callbackJS, argsJs);\n                          return tweenPy;\n                        });\n                      }, METHOD_CALL, []));\n                    }\n                    break;\n                    case METHOD_WAIT: {\n                      return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n                        $loc.__init__ = new Sk.builtin.func(function(self) {\n                          self.tp$name = METHOD_WAIT;\n                        });\n                        $loc.__call__ = new Sk.builtin.func(function(self, duration) {\n                          duration = Sk.ffi.remapToJs(duration);\n                          tween[METHOD_WAIT](duration);\n                          return tweenPy;\n                        });\n                      }, METHOD_WAIT, []));\n                    }\n                    break;\n                  }\n                });\n              }, TWEEN, []));\n            });\n          }, METHOD_GET, []));\n        }\n        break;\n      }\n    });\n  }, TWEEN, []));\n\n  mod[CONTAINER] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(containerPy, argPy) {\n      containerPy.tp$name = CONTAINER;\n      if (typeof argPy === 'undefined') {\n        containerPy.v = new createjs[CONTAINER]();\n      }\n      else {\n        var name = argPy.tp$name;\n        if (typeof name === 'string') {\n          switch(name) {\n            case CONTAINER: {\n              containerPy.v = Sk.ffi.remapToJs(argPy);\n            }\n            break;\n            default: {\n              throw new Error(name);\n            }\n          }\n        }\n        else {\n          throw new Error(typeof name);\n        }\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(containerPy, name) {\n      var container = Sk.ffi.remapToJs(containerPy);\n      switch(name) {\n        case PROP_NAME: {\n          return new Sk.builtin.str(container[PROP_NAME]);\n        }\n        case PROP_X: {\n          return Sk.builtin.assk$(container[PROP_X], Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(container[PROP_Y], Sk.builtin.nmber.float$);\n        }\n        case PROP_ROTATION: {\n          return Sk.builtin.assk$(container[PROP_ROTATION], Sk.builtin.nmber.float$);\n        }\n        case METHOD_ADD_CHILD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_ADD_CHILD;\n              methodPy.v = container[METHOD_ADD_CHILD];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, childPy) {\n              var child = container.addChild(Sk.ffi.remapToJs(childPy));\n              return Sk.misceval.callsim(mod[childPy.tp$name], Sk.ffi.referenceToPy(child, childPy.tp$name));\n            });\n          }, METHOD_ADD_CHILD, []));\n        }\n        case METHOD_ADD_EVENT_LISTENER: {\n          return Sk.builtin.addEventListener(mod, container);\n        }\n        case METHOD_GET_CHILD_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_GET_CHILD_AT;\n              methodPy.v = container[METHOD_GET_CHILD_AT];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, indexPy) {\n              var child = container[METHOD_GET_CHILD_AT](Sk.ffi.remapToJs(indexPy));\n              return Sk.misceval.callsim(mod[SHAPE], Sk.ffi.referenceToPy(child, SHAPE));\n            });\n          }, METHOD_GET_CHILD_AT, []));\n        }\n        case METHOD_GET_NUM_CHILDREN: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_GET_NUM_CHILDREN;\n              methodPy.v = container[METHOD_GET_NUM_CHILDREN];\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy, childPy) {\n              return Sk.builtin.assk$(container[METHOD_GET_NUM_CHILDREN](), Sk.builtin.nmber.int$);\n            });\n          }, METHOD_GET_NUM_CHILDREN, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(containerPy, name, valuePy) {\n      var container = Sk.ffi.remapToJs(containerPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_NAME: {\n          container[PROP_NAME] = value;\n        }\n        break;\n        case PROP_X: {\n          container[PROP_X] = value;\n        }\n        break;\n        case PROP_Y: {\n          container[PROP_Y] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          container[PROP_ROTATION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not a writeable attribute of \" + CONTAINER);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(selfPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      return new Sk.builtin.str(CONTAINER + \"(\" + self.x + \", \" + self.y + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(selfPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      return new Sk.builtin.str(\"[\" + self.x + \", \" + self.y + \"]\");\n    });\n  }, CONTAINER, []);\n\n  mod[EASE] = Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = EASE;\n      self.v = createjs[EASE];\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_BOUNCE_OUT: {\n          var fn = createjs[EASE][PROP_BOUNCE_OUT];\n          return {\"v\": fn};\n        }\n      }\n    });\n  }, EASE, []));\n\n  mod[POINT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, x, y) {\n      Sk.builtin.pyCheckArgs(POINT, arguments, 1, 3);\n      self.tp$name = POINT;\n      switch(arguments.length) {\n        case 1: {\n          self.v = new createjs.Point();\n        }\n        break;\n        case 2: {\n          x = Sk.ffi.remapToJs(x);\n          self.tp$name = POINT;\n          self.v = x;\n        }\n        break;\n        case 3: {\n          Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n          Sk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n          x = Sk.ffi.remapToJs(x);\n          y = Sk.ffi.remapToJs(y);\n          self.tp$name = POINT;\n          self.v = new createjs.Point(x, y);\n        }\n        break;\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(pointPy, name) {\n      var point = Sk.ffi.remapToJs(pointPy);\n      switch(name) {\n        case PROP_X: {\n          return Sk.builtin.assk$(point.x, Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(point.y, Sk.builtin.nmber.float$);\n        }\n        case METHOD_CLONE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_CLONE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy) {\n              return Sk.misceval.callsim(mod[POINT], Sk.ffi.remapToPy(point.x), Sk.ffi.remapToPy(point.y));\n            });\n          }, METHOD_CLONE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(pointPy, name, valuePy) {\n      var point = Sk.ffi.remapToJs(pointPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_X: {\n          point.x = value;\n        }\n        break;\n        case PROP_Y: {\n          point.y = value;\n        }\n        break;\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(pointPy) {\n      var point = Sk.ffi.remapToJs(pointPy);\n      return new Sk.builtin.str(POINT + \"(\" + point.x + \", \" + point.y + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(pointPy) {\n      var point = Sk.ffi.remapToJs(pointPy);\n      return new Sk.builtin.str(\"[\" + point.x + \", \" + point.y + \"]\");\n    });\n  }, POINT, []);\n\n  mod[EUCLIDEAN_2] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, x00, x01, x10, x11) {\n      x00 = Sk.ffi.remapToJs(x00);\n      x01 = Sk.ffi.remapToJs(x01);\n      x10 = Sk.ffi.remapToJs(x10);\n      x11 = Sk.ffi.remapToJs(x11);\n      self.tp$name = EUCLIDEAN_2;\n      self.v = [x00, x01, x10, x11];\n    });\n    $loc.__add__ = new Sk.builtin.func(function(lhs, rhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(rhs)) {\n        return remapE2ToPy(lhs[0] + rhs, lhs[1], lhs[2], lhs[3]);\n      }\n      else {\n        return remapE2ToPy(lhs[0] + rhs[0], lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3]);\n      }\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs + rhs[0], rhs[1], rhs[2], rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" + \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] += other;\n        return selfPy;\n      }\n      else {\n        self[0] += other[0];\n        self[1] += other[1];\n        self[2] += other[2];\n        self[3] += other[3];\n        return selfPy;\n      }\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(lhs, rhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(rhs)) {\n        return remapE2ToPy(lhs[0] - rhs, lhs[1], lhs[2], lhs[3]);\n      }\n      else {\n        return remapE2ToPy(lhs[0] - rhs[0], lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3]);\n      }\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs - rhs[0], -rhs[1], -rhs[2], -rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" - \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] -= other;\n        return selfPy;\n      }\n      else {\n        self[0] -= other[0];\n        self[1] -= other[1];\n        self[2] -= other[2];\n        self[3] -= other[3];\n        return selfPy;\n      }\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE2ToPy(a[0] * b, a[1] * b, a[2] * b, a[3] * b);\n      }\n      else {\n        var a00 = a[0];\n        var a01 = a[1];\n        var a10 = a[2];\n        var a11 = a[3];\n        var b00 = b[0];\n        var b01 = b[1];\n        var b10 = b[2];\n        var b11 = b[3];\n        var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        var x01 = a00 * b01 + a01 * b00 - a10 * b11 + a11 * b10;\n        var x10 = a00 * b10 + a01 * b11 + a10 * b00 - a11 * b01;\n        var x11 = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;\n        return remapE2ToPy(x00, x01, x10, x11);\n      }\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs * rhs[0], lhs * rhs[1], lhs * rhs[2], lhs * rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" * \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] *= other;\n        self[1] *= other;\n        self[2] *= other;\n        self[3] *= other;\n        return selfPy;\n      }\n      else {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other[0];\n        var b01 = other[1];\n        var b10 = other[2];\n        var b11 = other[3];\n        self[0] = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        self[1] = a00 * b01 + a01 * b00 - a10 * b11 + a11 * b10;\n        self[2] = a00 * b10 + a01 * b11 + a10 * b00 - a11 * b01;\n        self[3] = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;\n        return selfPy;\n      }\n    });\n    $loc.__div__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return divide(a[0], a[1], a[2], a[3], b, 0, 0, 0);\n      }\n      else {\n        return divide(a[0], a[1], a[2], a[3], b[0], b[1], b[2], b[3]);\n      }\n    });\n    $loc.__rdiv__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return divide(lhs, 0, 0, 0, rhs[0], rhs[1], rhs[2], rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" / \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__idiv__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        divide(self[0], self[1], self[2], self[3], other, 0, 0, 0, self);\n        return selfPy;\n      }\n      else {\n        divide(self[0], self[1], self[2], self[3], other[0], other[1], other[2], other[3], self);\n        return selfPy;\n      }\n    });\n    $loc.__xor__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE2ToPy(a[0] * b, a[1] * b, a[2] * b, a[3] * b);\n      }\n      else {\n        var a00 = a[0];\n        var a01 = a[1];\n        var a10 = a[2];\n        var a11 = a[3];\n        var b00 = b[0];\n        var b01 = b[1];\n        var b10 = b[2];\n        var b11 = b[3];\n        var x00 = a00 * b00;\n        var x01 = a00 * b01 + a01 * b00;\n        var x10 = a00 * b10             + a10 * b00;\n        var x11 = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;\n        return remapE2ToPy(x00, x01, x10, x11);\n      }\n    });\n    $loc.__rxor__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs * rhs[0], lhs * rhs[1], lhs * rhs[2], lhs * rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" ^ \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__ixor__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] *= other;\n        self[1] *= other;\n        self[2] *= other;\n        self[3] *= other;\n        return selfPy;\n      }\n      else {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other[0];\n        var b01 = other[1];\n        var b10 = other[2];\n        var b11 = other[3];\n        self[0] = a00 * b00;\n        self[1] = a00 * b01 + a01 * b00;\n        self[2] = a00 * b10             + a10 * b00;\n        self[3] = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;\n        return selfPy;\n      }\n    });\n    $loc.__lshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE2ToPy(a[0] * b, 0, 0, 0);\n      }\n      else {\n        var a00 = a[0];\n        var a01 = a[1];\n        var a10 = a[2];\n        var a11 = a[3];\n        var b00 = b[0];\n        var b01 = b[1];\n        var b10 = b[2];\n        var b11 = b[3];\n        var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        var x01 = a00 * b01             - a10 * b11;\n        var x10 = a00 * b10 + a01 * b11;\n        var x11 = a00 * b11;\n        return remapE2ToPy(x00, x01, x10, x11);\n      }\n    });\n    $loc.__rlshift__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs * rhs[0], lhs * rhs[1], lhs * rhs[2], lhs * rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" << \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__ilshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] *= other;\n        self[1] = 0;\n        self[2] = 0;\n        self[3] = 0;\n        return selfPy;\n      }\n      else {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other[0];\n        var b01 = other[1];\n        var b10 = other[2];\n        var b11 = other[3];\n        self[0] = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        self[1] = a00 * b01             - a10 * b11;\n        self[2] = a00 * b10 + a01 * b11;\n        self[3] = a00 * b11;\n        return selfPy;\n      }\n    });\n    $loc.__rshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE2ToPy(a[0] * b, -a[1] * b, -a[2] * b, a[3] * b);\n      }\n      else {\n        var a00 = a[0];\n        var a01 = a[1];\n        var a10 = a[2];\n        var a11 = a[3];\n        var b00 = b[0];\n        var b01 = b[1];\n        var b10 = b[2];\n        var b11 = b[3];\n        var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        var x01 =           + a01 * b00             + a11 * b10;\n        var x10 =                       + a10 * b00 - a11 * b01;\n        var x11 =                                     a11 * b00;\n        return remapE2ToPy(x00, x01, x10, x11);\n      }\n    });\n    $loc.__rrshift__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs * rhs[0], 0, 0, 0);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" >> \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__irshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other;\n        var b01 = 0;\n        var b10 = 0;\n        var b11 = 0;\n        self[0] *=  other;\n        self[1] *= -other;\n        self[2] *= -other;\n        self[3] *=  other;\n        return selfPy;\n      }\n      else {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other[0];\n        var b01 = other[1];\n        var b10 = other[2];\n        var b11 = other[3];\n        self[0] = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        self[1] =           + a01 * b00             + a11 * b10;\n        self[2] =                       + a10 * b00 - a11 * b01;\n        self[3] =                                     a11 * b00;\n        return selfPy;\n      }\n    });\n    $loc.nb$negative = function() {\n      var self = Sk.ffi.remapToJs(this);\n      return remapE2ToPy(-self[0], -self[1], -self[2], -self[3]);\n    };\n    $loc.nb$positive = function() {\n      return this;\n    };\n    $loc.nb$invert = function() {\n      var self = Sk.ffi.remapToJs(this);\n      return remapE2ToPy(self[0], self[1], self[2], -self[3]);\n    };\n    $loc.__getitem__ = new Sk.builtin.func(function(mv, index) {\n      mv = Sk.ffi.remapToJs(mv);\n      index = Sk.builtin.asnum$(index);\n      switch(index) {\n        case 0: {\n          return remapE2ToPy(mv[0], 0, 0, 0);\n        }\n        case 1: {\n          return remapE2ToPy(0, mv[1], mv[2], 0);\n        }\n        case 2: {\n          return remapE2ToPy(0, 0, 0, mv[3]);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      return new Sk.builtin.str(EUCLIDEAN_2 + \"(\" + mv.join(\", \") + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      if (typeof mv !== 'undefined') {\n        return new Sk.builtin.str(stringFromCoordinates([mv[0], mv[1], mv[2], mv[3]], [\"1\", \"i\", \"j\", \"I\"], \"*\"));\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + EUCLIDEAN_2 + \"'>\");\n      }\n    });\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return (a[0] === b[0]) && (a[1] === b[1]) && (a[2] === b[2]) && (a[3] === b[3]);\n    });\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return (a[0] !== b[0]) || (a[1] !== b[1]) || (a[2] !== b[2]) || (a[3] !== b[3]);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(mvPy, name) {\n      var mv = Sk.ffi.remapToJs(mvPy);\n      switch(name) {\n        case PROP_W: {\n          return Sk.builtin.assk$(mv[0], Sk.builtin.nmber.float$);\n        }\n        case PROP_X: {\n          return Sk.builtin.assk$(mv[1], Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(mv[2], Sk.builtin.nmber.float$);\n        }\n        case PROP_XY: {\n          return Sk.builtin.assk$(mv[3], Sk.builtin.nmber.float$);\n        }\n        case METHOD_CLONE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_CLONE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy) {\n              return remapE2ToPy(mv[0], mv[1], mv[2], mv[3]);\n            });\n          }, METHOD_CLONE, []));\n        }\n        case METHOD_LENGTH: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(4, Sk.builtin.nmber.int$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n          }, METHOD_LENGTH, []));\n        }\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not a readable attribute of \" + EUCLIDEAN_2);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(selfPy, name, valuePy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_W: {\n          self[0] = value;\n        }\n        break;\n        case PROP_X: {\n          self[1] = value;\n        }\n        break;\n        case PROP_Y: {\n          self[2] = value;\n        }\n        break;\n        case PROP_XY: {\n          self[3] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not a writeable attribute of \" + EUCLIDEAN_2);\n        }\n      }\n    });\n  }, EUCLIDEAN_2, []);\n\n  mod['getHSL'] = new Sk.builtin.func(function(hue, saturation, lightness, alpha) {\n    hue = Sk.ffi.remapToJs(hue);\n    saturation = Sk.ffi.remapToJs(saturation);\n    lightness = Sk.ffi.remapToJs(lightness);\n    alpha = Sk.ffi.remapToJs(alpha);\n    return new Sk.builtin.str(createjs[GRAPHICS].getHSL(hue, saturation, lightness, alpha));\n  });\n\n  return mod;\n}\n", "src/lib/turtle/__init__.js": "//\n//\n// Turtle Graphics Module for Skulpt\n//\n// Brad Miller\n//\n//\n//\n\n\nvar TurtleGraphics; // the single identifier needed in the global scope\n\nif (! TurtleGraphics) {\n    TurtleGraphics = { };\n}\n\n\n(function () {\n\n    // Define private constants\n\n    var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians\n    var Rad2Degree = 180.0 / Math.PI\n\n    //\n    // Define TurtleCanvas\n    // \n\n    function TurtleCanvas(options) {\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n\n        this.canvas = document.getElementById(this.canvasID);\n        this.context = this.canvas.getContext('2d');\n        //this.canvas.style.display = 'block';\n        $(this.canvas).fadeIn();\n\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.setup(this.canvas.width,this.canvas.height);\n        TurtleGraphics.canvasInit = true;\n        this.tlist = []\n\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n        this.segmentLength = 10;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n        TurtleGraphics.canvasLib[this.canvasID] = this;\n\t\tSk.tg.fadeOnExit = true;\t//\tThis can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    }\n\n    TurtleCanvas.prototype.setup = function(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0;\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate ) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n\n        if (TurtleGraphics.canvasInit == false) {\n            this.context.save();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            TurtleGraphics.canvasInit = true;\n            TurtleGraphics.eventCount = 0;\n            TurtleGraphics.renderClock = 0;\n            TurtleGraphics.renderTime = 0;\t// RNL\n        } else {\n            this.context.restore();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2,\n                                    this.canvas.width, this.canvas.height);\n        }\n    }\n    TurtleCanvas.prototype.addToCanvas = function(t) {\n\t        this.tlist.push(t);\n    }\n\n    TurtleCanvas.prototype.onCanvas = function(t) {\n        return (this.tlist.indexOf(t) >= 0);\n    }\n\n    TurtleCanvas.prototype.isAnimating = function() {\n        return (this.tlist.length > 0)\n    }\n\n    TurtleCanvas.prototype.startAnimating = function(t) {\n\t\tif (! this.isAnimating()) {\n        \tthis.intervalId = setTimeout(render, this.delay);\t//\tsetInterval(render, this.delay);\n\t\t}\n    \tif (!this.onCanvas(t))\t//\tAdded by RNL in case startAnimating is called after it's already been added\n       \t\tthis.addToCanvas(t);\n        Sk.isTurtleProgram = true;\n    }\n\n    TurtleCanvas.prototype.doneAnimating = function(t) {\n        this.tlist.splice(0,this.tlist.length)\n        clearTimeout(this.intervalId)   \n        $(Sk.runButton).removeAttr('disabled');\n    }\n\n    TurtleCanvas.prototype.cancelAnimation = function() {\n        if (this.intervalId) {\n            clearTimeout(this.intervalId)\t//\tclearInterval(this.intervalId);\n        }\n\n        for (var t in this.tlist) {\n            this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n        }\n        render();\n    }\n\n    TurtleCanvas.prototype.setSpeedDelay = function(s) {\t// RNL\n        var df = 10 - (s % 11) + 1;\n        this.delay = df * this.timeFactor;\t//\tRNL was 10;\n    }\n\n    TurtleCanvas.prototype.setDelay = function(d) {\n        this.delay = d;\n    }\n\n    TurtleCanvas.prototype.getDelay = function(s) { // RNL\n        return this.delay;\n    }\n\n    TurtleCanvas.prototype.setCounter = function(s) {\n\t\tif (!s || s <= 0)\t//\tDon't let this be less than 1\n\t\t\ts = 1;\n        this.renderCounter = s;\n    }\n\n    TurtleCanvas.prototype.getCounter = function() {\n        return this.renderCounter;\n    }\n\n    TurtleCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.context.restore();\n        this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n        if (lly == 0)\n            this.context.translate(-llx, lly - (ury - lly));\n        else if (lly > 0)\n            this.context.translate(-llx, -lly * 2);\n        else\n            this.context.translate(-llx, -ury);\n\n        var xlinescale = (urx - llx) / this.canvas.width;\n        var ylinescale = (ury - lly) / this.canvas.height;\n        this.xptscale = xlinescale;\n        this.yptscale = ylinescale;\n        this.lineScale = Math.min(xlinescale,ylinescale)\n        this.context.save();\n\n        this.llx = llx;\n        this.lly = lly;\n        this.urx = urx;\n        this.ury = ury;\n\n    }\n\n    TurtleCanvas.prototype.window_width = function() {\n        return this.canvas.width;\n    }\n\n    TurtleCanvas.prototype.window_height = function() {\n        return this.canvas.height;\n    }\n\n    TurtleCanvas.prototype.bgcolor = function(c) {\n        this.background_color = c;\n        //this.canvas.style.setProperty(\"background-color\", c.v);\n        $(this.canvas).css(\"background-color\",c.v);\n    }\n\n    TurtleCanvas.prototype.setSegmentLength = function(s) {\n        this.segmentLength = s;\n    }\n\n    TurtleCanvas.prototype.getSegmentLength = function() {\n        return this.segmentLength;\n    }\n    \n    // todo: if animating, this should be deferred until the proper time\n    TurtleCanvas.prototype.exitonclick = function () {\n        var canvas_id = this.canvasID;\n        var theCanvas = this;\n        $(this.canvas).click(function() {\n            if (! theCanvas.isAnimating()) {\n\t\t\t\tif (Sk.tg.fadeOnExit)\t//\tLet's this be configurable\n                \t$(\"#\"+canvas_id).hide();\n                $(\"#\"+canvas_id).unbind('click');\n                Sk.tg.canvasInit = false;\n                delete Sk.tg.canvasLib[canvas_id];\n            }\n        });\n    }\n\n    TurtleCanvas.prototype.turtles = function() {\n        return TurtleGraphics.turtleList;\n    }\n\n\tTurtleCanvas.prototype.tracer = function(t, d) {\t//\tNew version NOT attached to a turtle (as per real turtle)\n        this.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tfor (var i in this.turtleList)\n\t\t\t\tthis.turtleList[i].animate = false;\n\t\t\tthis.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.setDelay(d);\n\t}\n\n    // check if all turtles are done\n    allDone = function() {\n        var allDone = true;\n        for (var tix in TurtleGraphics.turtleList) {\n            var theT = TurtleGraphics.turtleList[tix];\n            allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n        }\n        return allDone;\n    }\n    //\n    //  This is the function that provides the animation\n    //\n    render = function () {\n        var context = document.getElementById(TurtleGraphics.defaults.canvasID).getContext('2d');\n        with (context) {\n            with (TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID]) {\n                clearRect(llx, lly, (urx - llx), (ury - lly));\n                //canvas.style.setProperty(\"background-color\",TurtleGraphics.turtleCanvas.bgcolor.v);\n            }\n            var incr = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID].getCounter();\n            var lastCanvas = null\n\n            TurtleGraphics.renderClock += incr;\n\n            for (var tix in TurtleGraphics.turtleList) {\n                var t = TurtleGraphics.turtleList[tix]\n                lastCanvas = t.turtleCanvas \n                if (t.aCount >= t.drawingEvents.length)\n                    t.aCount = t.drawingEvents.length - 1;\n                moveTo(0, 0);\n                var currentPos = new Vector(0,0,0);\n                var currentHead = new Vector(1,0,0);\n                lineWidth = t.get_pen_width();\n                lineCap = 'round';\n                lineJoin = 'round';\n                strokeStyle = 'black';\n                var filling = false;\n                if (isNaN(t.turtleCanvas.delay))\n                \tt.turtleCanvas.delay = 0\n//\t\t\t\tconsole.log(tix + \" : \" + t.clearPoint + \" to \" + t.aCount)\n                for (var i = t.clearPoint; (i <= t.aCount || t.turtleCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n                \tif (i > t.aCount)\t//\tIf se jump past aCount, jump it ahead\n                \t\tt.aCount = i\n                    var oper = t.drawingEvents[i];\n                    var ts = oper[oper.length-1];\n//\t\t\t\t\tconsole.log(i + \"/\" + ts + oper [0] + \"{\" + oper [1] + \"}\" + t.turtleCanvas.delay)\n                    if (ts <= TurtleGraphics.renderClock || t.turtleCanvas.delay == 0) {\n                    \tif (ts > TurtleGraphics.renderClock)\t//\tIf we go past the render clock, jump it ahead\n                    \t\tTurtleGraphics.renderClock = ts\n//\t\t\t\t\t\tconsole.log(\"<==\")\n                        if (oper[0] == \"LT\") {  //  line to\n                            if (! filling) {\n                                beginPath();\n                                moveTo(oper[1], oper[2]);\n                            }\n                            lineTo(oper[3], oper[4]);\n                            strokeStyle = oper[5];\n                            stroke();\n                            currentPos = new Vector(oper[3],oper[4],0);\n                            if (! filling)\n                                closePath();\n                        }\n                        else if (oper[0] == \"MT\") {  // move to\n                            moveTo(oper[3], oper[4]);\n                            currentPos = new Vector(oper[3],oper[4],0);\n                        }\n                        else if (oper[0] == \"BF\") {  // begin fill\n                            beginPath();\n                            moveTo(oper[1], oper[2]);\n                            filling = true;\n                        }\n                        else if (oper[0] == \"EF\") {  // end fill\n                            fillStyle = oper[3];\n                            stroke();\n                            fill();\n                            closePath();\n                            filling = false;\n                        }\n                        else if (oper[0] == \"FC\") {  // fill color\n                            fillStyle = oper[1];\n                        }\n                        else if (oper[0] == \"TC\") {  // turtle color\n                            strokeStyle = oper[1];\n                        }\n                        else if (oper[0] == \"PW\") {  // Pen width\n                            lineWidth = oper[1];\n                        }\n                        else if (oper[0] == \"DT\") {  // Dot\n                            var col = fillStyle;\n                            fillStyle = oper[2];\n                            var size = oper[1];\n                            fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n                            fillStyle = col;\n                        }\n                        else if (oper[0] == \"CI\") {  // Circle\n                            if (!filling)\n\t\t\t\t\t\t\t\tbeginPath();\n                            arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n                            currentPos = new Vector(oper[1]+Math.cos(oper[5])*oper[3],\n                                oper[2]+Math.sin(oper[5])*oper[3],0);\n                            stroke();\n                            if (! filling) {\n                                closePath();\n                            }\n                        }\n                        else if (oper[0] == \"WT\") { // write\n                            if (font)\n                                font = oper[2];\n                            scale(1, -1);\n                            fillText(oper[1], oper[3], -oper[4]);\n                            scale(1, -1);\n                        } else if (oper[0] == \"ST\") {  // stamp\n                            t.drawturtle(oper[3], new Vector(oper[1], oper[2], 0));\n                        } else if (oper[0] == \"HT\") { // hide turtle\n                            t.visible = false;\n                        } else if (oper[0] == \"SH\") { // show turtle\n                            t.visible = true;\n                        } else if (oper[0] == \"TT\") {\n                            currentHead = oper[1];\n                        } else if (oper[0] == \"CL\") { // RNL clear\n                        \tclear_canvas(t.canvasID);\n                        \tt.clearPoint = i;\t// Different from reset that calls clear because it leaves the turtles where they are\n                        } else if (oper[0] == \"DL\") { // RNL delay\n                        \tvar df = oper[1]\n//                      \tconsole.log(\"animated delay set \" + df)\n                        \tt.turtleCanvas.delay = df\n                        } else if (oper[0] == \"SC\") { // RNL speed change\n                        \tvar s = oper[1]\n                        \tif (s < 0)\n                        \t\ts = 0\n                        \tif (s > 10)\n                        \t\ts = 10\n       \t\t\t\t\t\tvar df = (10 - (s % 11) + 1) * t.turtleCanvas.timeFactor\t//\t10\n       \t\t\t\t\t\tif (s == 0) {\n       \t\t\t\t\t\t\tdf = 0\n       \t\t\t\t\t\t}\n\t                        //\tt.turtleCanvas.intervalId = clearInterval(t.turtleCanvas.intervalId);\n\t       \t\t\t\t\tt.turtleCanvas.delay = df;\n\t       \t\t\t\t\t//\tt.turtleCanvas.intervalId = setInterval(render, t.turtleCanvas.delay)\n       \t\t\t\t\t\tif (oper[2]) {\n       \t\t\t\t\t\t\tt.turtleCanvas.setSegmentLength(oper[2]);\n       \t\t\t\t\t\t}\n       \t\t\t\t\t} else if (oper[0] == \"NO\") { // RNL no op                \t\n                        } else {\n\t\t\t\t\t\t\tconsole.log(\"unknown op: \" + oper[0]);\n                        } // end of oper[0] test\n                    } // end of if ts < render clock\n                } // end of for\n//\t\t\t\tconsole.log(TurtleGraphics.renderClock + \" / \" + t.aCount)\n//\t\t\t\tconsole.log(\"------------------------------\")\n                t.aCount += incr;\n                if (t.visible) {\n                    // draw the turtle\n                    t.drawturtle(currentHead.toAngle(), currentPos); // just use currentHead\n                }\n            }\n            //if (t.aCount >= t.drawingEvents.length) {\n            if (TurtleGraphics.renderClock > TurtleGraphics.eventCount ){ // && allDone() ){\n//              t.turtleCanvas.doneAnimating(t);\n//\t\t\t\tconsole.log(\"done animating\")\n                if (lastCanvas) lastCanvas.doneAnimating(t);\n            } else {\n//    \t\t\tt.turtleCanvas.intervalId = setTimeout(render, t.turtleCanvas.delay)\n    \t\t\tif (lastCanvas) {\n    \t\t\t\tlastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n    \t\t\t}\n            }\n        }\n    }\n\n\n\n    // Constructor for Turtle objects\n    function Turtle() {\n        if (arguments.length >= 1) {\n            this.initialize(arguments[0]);\n        }\n        else {\n            this.initialize();\n        }\n        TurtleGraphics.turtleList.push(this);\n    }\n\n\n    Turtle.prototype.go_home = function () {\n        // Put turtle in initial state\n        // turtle is headed to the right\n        // with location 0,0,0 in the middle of the canvas.\n        // x grows to the right\n        // y grows towards the top of the canvas\n        with (this) {\n            position = home;\n            context.moveTo(home[0], home[1]);\n            heading = new Vector([1.0, 0.0, 0.0]); // to the right; in turtle space x+ direction\n            normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n        }\n    };\n\n    Turtle.prototype.initialize = function () {\n        // Initialize the turtle.\n        var options = { };\n\n        if (arguments.length >= 1) {\n            options = arguments[0];\n        }\n\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n        this.context = document.getElementById(this.canvasID).getContext('2d');\n\n        this.animate = TurtleGraphics.defaults.animate;\n\n        with (this.context) {\n            if (TurtleGraphics.canvasInit == false) {   // This is a workaround until I understand skulpt re-running better\n                // the downside is that this limits us to a single turtle...\n                save();\n                translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n                scale(1, -1); // scaling like this flips the y axis the right way.\n                if (! TurtleGraphics.canvasLib[this.canvasID]) {\n                    TurtleGraphics.canvasLib[this.canvasID] = new TurtleCanvas(options);\n                }\n                TurtleGraphics.canvasInit = true;\n            } else {\n                clear_canvas(this.canvasID);\n            }\n\n            this.turtleCanvas = TurtleGraphics.canvasLib[this.canvasID];\n            this.home = new Vector([0.0, 0.0, 0.0]);\n            this.visible = true;\n            this.shapeStore = {};\n            this.shapeStore['turtle'] = turtleShapePoints();\n            this.shapeStore['arrow'] = defaultShapePoints();\n            this.shapeStore['circle'] = circleShapePoints();\n            this.shapeStore['square'] = squareShapePoints();\n            this.shapeStore['triangle'] = triangleShapePoints();\n            this.shapeStore['blank'] = [new Vector(0,0)];\n            this.shapeStore['classic'] = classicShapePoints();\n            this.currentShape = 'classic';\n            this.drawingEvents = [];\n\n            this.filling = false;\n            this.pen = true;\n            this.penStyle = 'black';\n            this.penWidth = 2;\n            this.fillStyle = 'black';\n            this.position = [ ];\n            this.heading = [ ];\n            this.normal = [ ];\n            this.go_home();\n            this.aCount = 0;\n            this.clearPoint = 0;\t// RNL for clear/clearScreen\n        }\n    }\n    function turtleShapePoints() {\n        var pl = [\n            [0,16],\n            [-2,14],\n            [-1,10],\n            [-4,7],\n            [-7,9],\n            [-9,8],\n            [-6,5],\n            [-7,1],\n            [-5,-3],\n            [-8,-6],\n            [-6,-8],\n            [-4,-5],\n            [0,-7],\n            [4,-5],\n            [6,-8],\n            [8,-6],\n            [5,-3],\n            [7,1],\n            [6,5],\n            [9,8],\n            [7,9],\n            [4,7],\n            [1,10],\n            [2,14]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function defaultShapePoints() {\n        var pl = [\n            [-10,0],\n            [10,0],\n            [0,10]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function circleShapePoints() {\n        var pl = [\n            [10,0],\n            [9.51,3.09],\n            [8.09,5.88],\n            [5.88,8.09],\n            [3.09,9.51],\n            [0,10],\n            [-3.09,9.51],\n            [-5.88,8.09],\n            [-8.09,5.88],\n            [-9.51,3.09],\n            [-10,0],\n            [-9.51,-3.09],\n            [-8.09,-5.88],\n            [-5.88,-8.09],\n            [-3.09,-9.51],\n            [-0.00,-10.00],\n            [3.09,-9.51],\n            [5.88,-8.09],\n            [8.09,-5.88],\n            [9.51,-3.09]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function triangleShapePoints() {\n        var pl = [\n            [10,-5.77],\n            [0,11.55],\n            [-10,-5.77]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function squareShapePoints() {\n        var pl = [\n            [10,-10],\n            [10,10],\n            [-10,10],\n            [-10,-10]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function classicShapePoints() {\n        var pl = [\n            [0,0],\n            [-5,-9],\n            [0,-7],\n            [5,-9]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    Turtle.prototype.clean = function () {\n        // Clean the canvas\n        // Optional second argument is color\n        with (this) {\n            if (arguments.length >= 1) {\n                clear_canvas(canvasID, arguments[0]);\n            }\n            else {\n                clear_canvas(canvasID);\n            }\n            initialize();\n        }\n    }\n\n    Turtle.prototype.addDrawingEvent = function(eventList) {\n        TurtleGraphics.eventCount += 1;\n        eventList.push(TurtleGraphics.eventCount);\n        this.drawingEvents.push(eventList);\n    }\n//  \n//  Drawing Functions\n//\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n        var head = ep.sub(sp).normalize();\n        var numSegs = Math.floor(ep.sub(sp).len() / sL);\n        var res = [];\n        var oldp = sp;\n        var newp;\n        var op = \"\"\n        if (pen)\n            op = \"LT\"\n        else\n            op = \"MT\"\n        for (var i = 0; i < numSegs; i++) {\n            newp = oldp.linear(1, sL, head);\n            res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n            oldp = newp;\n        }\n        if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n            res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n        return res;\n    }\n\n    Turtle.prototype.draw_line = function(newposition) {\n        with (this) {\n            with (context) {\n                if (! animate) {\n                    if (! filling) {\n                        beginPath();\n                        moveTo(position[0], position[1]);\n                    }\n                    lineCap = 'round';\n                    lineJoin = 'round';\n                    lineWidth = get_pen_width();\n                    strokeStyle = penStyle;\n                    lineTo(newposition[0], newposition[1]);\n                    stroke();\n                    if (! filling)\n                        closePath();\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r) {\n                        r[s].push(penStyle);\n                        addDrawingEvent(r[s]);\n                    }\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    Turtle.prototype.forward = function (d) {\n        with (this) {\n            var newposition = position.linear(1, d, heading);\n            goto(newposition);\n        }\n    }\n\n    Turtle.prototype.backward = function(d) {\n        this.forward(-d);\n    }\n\n//\tThis is an internal function that sets the position without doing any drawing\n    Turtle.prototype.teleport_to = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        this.context.moveTo(newposition[0], newposition[1]);\n\t\tthis.position = newposition;\n\t}\n\n    Turtle.prototype.goto = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        with (this) {\n            if (pen) {\n                draw_line(newposition);\n            } else {\n                if (! animate) {\n                    context.moveTo(newposition[0], newposition[1]);\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r)\n                        addDrawingEvent(r[s]);\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n            position = newposition;\n\n        }\n    }\n\n    Turtle.prototype.delay = function(d) {\t// RNL\n    \tif (d != null) {\n    \t\tif (d < 0)\n    \t\t\td = -d\n    \t\tif (!this.animate) \n    \t\t\tthis.turtleCanvas.setDelay(d)\n    \t\telse {\n    \t\t\tthis.turtleCanvas.setDelay(d)\n\t    \t\tthis.addDrawingEvent([\"DL\", d])\n\t    \t\tthis.addDrawingEvent([\"NO\"])\n    \t\t}\n    \t}\n        return this.turtleCanvas.getDelay();\n    }\n\n    Turtle.prototype.speed = function(s,t) {\n        if (s > 0 && !this.animate) {\n            this.animate = true;\n            this.turtleCanvas.setSpeedDelay(s)\n        } else if (s == 0 && !this.animate) {\n        \tthis.turtleCanvas.setSpeedDelay(s)\n        } else {\n//          this.animate = false;\n//          this.turtleCanvas.cancelAnimation();\n\t\t\tthis.addDrawingEvent([\"SC\", s, t])\n\t\t\tthis.addDrawingEvent([\"NO\"])\n        }\n        if (t) {\n            this.turtleCanvas.setSegmentLength(t);\n            // set the number of units to divide a segment into\n        } else {\n            this.turtleCanvas.setSegmentLength(10);\n        }\n    }\n\n    Turtle.prototype.tracer = function(t, d) {\n        this.turtleCanvas.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tthis.animate=false;\n\t\t\tthis.turtleCanvas.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.turtleCanvas.setDelay(d);\n    }\n\n    Turtle.prototype.getRenderCounter = function() {\n        return this.turtleCanvas.getCounter();\n    }\n\n    Turtle.prototype.turn = function (phi) {\n        with (this) {\n            var alpha = phi * Degree2Rad;\n            var left = normal.cross(heading);\n            var newheading = heading.rotateNormal(left, normal, alpha);\n            heading = newheading;\n\n            if (animate) {\n                addDrawingEvent([\"TT\",heading]);\n            }\n        }\n    }\n\n    Turtle.prototype.right = Turtle.prototype.turn;\n\n    Turtle.prototype.left = function(phi) {\n        this.turn(-phi);\n    }\n\n    Turtle.prototype.get_heading = function () {\n        if (TurtleGraphics.defaults.degrees)\n            return this.heading.toAngle()\n        else\n            return this.heading\n    }\n\n    Turtle.prototype.get_position = function () {\n        return this.position;\n    }\n\n    Turtle.prototype.getx = function () {\n        return this.position[0];\n    }\n\n    Turtle.prototype.gety = function () {\n        return this.position[1];\n    }\n\n    Turtle.prototype.set_heading = function(newhead) {\n        if ((typeof(newhead)).toLowerCase() === 'number') {\n            this.heading = Vector.angle2vec(newhead);\n        } else {\n            this.heading = newhead;\n        }\n    }\n\n    Turtle.prototype.towards = function(to, y) {\n        // set heading vector to point towards another point.\n        if ((typeof(to)).toLowerCase() === 'number')\n            to = new Vector(to, y, 0);\n        else if (! (to instanceof Vector)) {\n            to = new Vector(to);\n        }\n        var res = to.sub(this.position);\n        res = res.normalize();\n        if (TurtleGraphics.defaults.degrees)\n            return res.toAngle();\n        else\n            return res;\n    }\n\n    Turtle.prototype.distance = function(to, y) {\n        if ((typeof(to)).toLowerCase() === 'number')\n            to = new Vector(to, y, 0);\n        return this.position.sub(new Vector(to)).len();\n    }\n\n    Turtle.prototype.dot = function() {\n        var size = 2;\n        if (arguments.length >= 1) size = arguments[0];\n        size = size * this.turtleCanvas.lineScale;\n        with (this) {\n            with (context) {\n                var color = penStyle;\n                var nc = arguments[1] || color;\n                if (! animate) {\n                    fillStyle = nc;\n                    fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n                    fillStyle = color;\n                } else {\n                    addDrawingEvent([\"DT\", size, nc, position[0], position[1]]);\n                }\n            }\n        }\n\n    }\n\n    Turtle.prototype.circle = function(radius, extent) {\n        if (extent === undefined) {\n            extent = 360\n        }\n\t\tif (this.animate) {\n\t\t\tvar arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n\t\t\tvar segLen = this.turtleCanvas.getSegmentLength();\n\t\t\tif (arcLen <= segLen)\n\t\t\t\tthis.arc(radius,extent);\n\t\t\telse {\n\t\t\t\t//\tBreak the arc into segments for animation\n\t\t\t\tvar extentPart = (segLen / arcLen) * extent;\n\t\t\t\tvar extentLeft = extent;\n\t\t\t\twhile (Math.abs(extentLeft) > Math.abs(extentPart)) {\n\t\t\t\t\tthis.arc(radius, extentPart);\n\t\t\t\t\textentLeft = extentLeft - extentPart;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(extentLeft) > 0.01)\n\t\t\t\t\tthis.arc(radius, extentLeft);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.arc(radius,extent);\n\t\t}\n\t}\n\t\n    Turtle.prototype.arc = function(radius, extent) {\n\t\t//\tFigure out where the turtle is and which way it's facing\n\t\tvar turtleHeading = this.get_heading()\n\t\tvar tx = this.position[0]\n\t\tvar ty = this.position[1]\n\n\t\t//\tFigure out the circle center\n\t\tvar cx = tx + (radius * Math.cos((turtleHeading + 90) * Degree2Rad));\n\t\tvar cy = ty + (radius * Math.sin((turtleHeading + 90) * Degree2Rad));\n\n\t\t//\tCanvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Turtle\n\n\t\t//\tFigure out our arc angles\n\t\tvar startAngleDeg;\n\t\tif (radius >= 0)\n\t\t\tstartAngleDeg = turtleHeading - 90;\n\t\telse\n\t\t\tstartAngleDeg = turtleHeading + 90;\n\n\t\tvar endAngleDeg;\n        if (extent) {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + extent;\n\t\t\telse\n\t            endAngleDeg = startAngleDeg - extent;\n        } else {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + 360;\n\t\t\telse\n\t\t\t\tendAngleDeg = startAngleDeg - 360;\n\t\t}\n\n\t\t//\tCanvas angles are opposite\n\t\tstartAngleDeg = 360 - startAngleDeg\n\t\tendAngleDeg   = 360 - endAngleDeg\n\n\t\t//\tBecuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n\t\tstartAngleDeg = -startAngleDeg\n\t\tendAngleDeg   = -endAngleDeg\n\n\t\t//\tConvert to radians\n\t\tvar startAngle = startAngleDeg * Degree2Rad;\n\t\tvar endAngle   = endAngleDeg   * Degree2Rad;\n\n\n\t\t//\tDo the drawing\n        if (! this.animate) {\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.beginPath();\n            this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n            this.context.stroke();\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.closePath();\n        } else {\n            this.addDrawingEvent([\"CI\", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n        }\n\n\t\t//\tMove the turtle only if we have to\n\t\tif (extent && (extent % 360) != 0) {\n\t\t\tvar turtleArc;\n\t\t\tif (radius >= 0)\n\t\t\t\tturtleArc = extent;\n\t\t\telse \n\t\t\t\tturtleArc = -extent;\n\t\t\tvar newTurtleHeading = (turtleHeading + turtleArc) % 360;\n\t\t\tif (newTurtleHeading < 0)\n\t\t\t\tnewTurtleHeading = newTurtleHeading + 360;\n\n\t\t\tvar nx = cx + (radius * Math.cos((newTurtleHeading - 90) * Degree2Rad));\n\t\t\tvar ny = cy + (radius * Math.sin((newTurtleHeading - 90) * Degree2Rad));\t//\ty coord is inverted in turtle\n\n\t\t\t//\tMove it internally\n\t\t\tthis.set_heading(newTurtleHeading);\n\t\t\tthis.teleport_to(nx,ny);\n\n\t\t\t//\tIf we're animating the turtle, move it on the screen\n\t\t\tif (this.animate) {\n\t\t\t\tthis.addDrawingEvent([\"TT\", this.heading]);\n\t\t\t}\n\t\t}\n\n    }\n\n    Turtle.prototype.write = function(theText, move, align, font) {\n        if (! this.animate) {\n            if (font)\n                this.context.font = font.v;\n            this.context.scale(1, -1);\n            this.context.fillText(theText, this.position[0], -this.position[1]);\n            this.context.scale(1, -1);\n        } else {\n            var fontspec;\n            if (font)\n                fontspec = font.v\n            this.addDrawingEvent([\"WT\", theText, fontspec, this.position[0], this.position[1]]);\n        }\n    }\n\n    Turtle.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.turtleCanvas.setworldcoordinates(llx, lly, urx, ury);\n    }\n\n//\n// Pen and Style functions\n//\n    Turtle.prototype.pen_down = function () {\n        this.pen = true;\n    }\n\n    Turtle.prototype.down = Turtle.prototype.pen_down;\n\n    Turtle.prototype.pen_up = function () {\n        this.pen = false;\n    }\n\n    Turtle.prototype.up = Turtle.prototype.pen_up;\n\n    Turtle.prototype.get_pen = function () {\n        return this.pen;\n    }\n\n    Turtle.prototype.set_pen_width = function (w) {\n        if (this.animate)\n            this.addDrawingEvent([\"PW\", w * this.turtleCanvas.lineScale]);\n        else\n            this.penWidth = w;\n    }\n\n    Turtle.prototype.get_pen_width = function() {\n        return this.penWidth * this.turtleCanvas.lineScale;\n    }\n\n    Turtle.prototype.set_pen_color = function (c, g, b) {\n        if (typeof(c) == \"string\") {\n            this.penStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == \"object\" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16);\n            gs = c1.toString(16);\n            bs = c2.toString(16);\n            while (rs.length < 2) rs = \"0\" + rs;\n            while (gs.length < 2) gs = \"0\" + gs;\n            while (bs.length < 2) bs = \"0\" + bs;\n            c = \"#\" + rs + gs + bs;\n            this.penStyle = c;\n        }\n\n        this.context.strokeStyle = c;\n        if (this.animate)\n            this.addDrawingEvent([\"TC\", c]);\n    }\n\n    Turtle.prototype.set_fill_color = function (c, g, b) {\n        if (typeof(c) == \"string\") {\n            this.fillStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == \"object\" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16)\n            gs = c1.toString(16)\n            bs = c2.toString(16)\n            while (rs.length < 2) rs = \"0\" + rs;\n            while (gs.length < 2) gs = \"0\" + gs;\n            while (bs.length < 2) bs = \"0\" + bs;\n            c = \"#\" + rs + gs + bs;\n            this.fillStyle = c;\n        }\n\n        this.context.fillStyle = c;\n        if (this.animate)\n            this.addDrawingEvent([\"FC\", c]);\n    }\n\n    Turtle.prototype.begin_fill = function () {\n        if (! this.animate) {\n            this.filling = true;\n            this.context.beginPath();\n            this.context.moveTo(this.position[0], this.position[1]);\n        } else\n            this.addDrawingEvent([\"BF\", this.position[0], this.position[1]]);\n\n    }\n\n    Turtle.prototype.end_fill = function () {\n        if (! this.animate) {\n            this.context.stroke();\n            this.context.fill();\n            this.context.closePath();\n            this.filling = false;\n        } else\n            this.addDrawingEvent([\"EF\", this.position[0], this.position[1], this.fillStyle]);\n    }\n\n\n    Turtle.prototype.showturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent([\"SH\"]);\n        }\n        this.visible = true;\n    }\n\n    Turtle.prototype.hideturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent([\"HT\"]);\n        }\n        this.visible = false;\n    }\n\n    Turtle.prototype.isvisible = function() {\n        return this.visible;\n    }\n\n    // \n    // Appearance\n    //\n\n    Turtle.prototype.shape = function(s) {\n        if (this.shapeStore[s])\n            this.currentShape = s;\n        else {\n        }\n    }\n\n    Turtle.prototype.drawturtle = function(heading, position) {\n        var rtPoints = [];\n        var plist = this.shapeStore[this.currentShape];\n        var head;\n        if (! (heading === undefined))\n            head = heading - 90.0;\n        else\n            head = this.heading.toAngle() - 90.0;\n        if (! position)\n            position = this.position\n        for (p in plist) {\n            rtPoints.push(plist[p].scale(this.turtleCanvas.xptscale,this.turtleCanvas.yptscale).rotate(head).add(position));\n        }\n        this.context.beginPath();\n        this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n        for (var i = 1; i < rtPoints.length; i++) {\n            this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n        }\n        this.context.closePath();\n        this.context.stroke();\n        if (this.fillStyle) {\n            this.context.fill();\n        }\n    }\n\n    Turtle.prototype.stamp = function() {\n        // either call drawTurtle or just add a DT with current position and heading to the drawingEvents list.\n        if (this.animate) {\n            this.addDrawingEvent([\"ST\",this.position[0],this.position[1],this.heading.toAngle()]);\n        } else\n            this.drawturtle();\n    }\n    \n    Turtle.prototype.clear = function () {\n    \tif (this.animate) {\n    \t\tthis.addDrawingEvent([\"CL\"])\n    \t} else {\n    \t\tclear_canvas(this.canvasID);\n    \t}\n    }\n\n    function clear_canvas(canId) {\n        with (document.getElementById(canId).getContext('2d')) {\n            if (arguments.length >= 2) {\n//\t\tfillStyle = arguments[1];\n//\t\tfillRect(0, 0, canvas.width, canvas.height);\n            }\n            clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n        }\n    }\n\n\n    // Create a 3d Vector class for manipulating turtle heading, and position.\n\n    function Vector(x, y, z) {\n        if ((typeof(x)).toLowerCase() === 'number') {\n            Array.prototype.push.call(this, x);\n            Array.prototype.push.call(this, y);\n            Array.prototype.push.call(this, z);\n        }\n        else {\n            for (var i in x) {\n                Array.prototype.push.call(this, x[i]);\n            }\n        }\n    }\n\n\n    // Create a vector object given a direction as an angle.\n    Vector.angle2vec = function(phi) {\n        var res = new Vector([0.0,0.0,0.0]);\n        phi = phi * Degree2Rad;\n        res[0] = Math.cos(phi);\n        res[1] = Math.sin(phi);\n        return res.normalize();\n    }\n\n    // This trick allows you to access a Vector object like an array\n    // myVec[0] == x\n    // myVec[1] == y\n    // myVec[2] == z\n    // we really only need the z for the convenience of rotating\n    Vector.prototype.addItem = function(item) {\n        Array.prototype.push.call(this, item);\n    }\n\n    Vector.prototype.linear = function(a, b, v) {\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = a * this[c] + b * v[c];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.cross = function(v) {\n        // Return cross product of this and v\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.rotate = function(angle) {\n        // Rotate this counter clockwise by angle.\n        var perp = new Vector(-this[1], this[0], 0);\n        angle = angle * Degree2Rad;\n        var c = Math.cos(angle);\n        var s = Math.sin(angle);\n        return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n    }\n\n    Vector.prototype.rotateNormal = function(v, w, alpha) {\n        // Return rotation of this in direction of v about w over alpha\n        // Requires: v, w are vectors; alpha is angle in radians\n        //   this, v, w are orthonormal\n        return this.linear(Math.cos(alpha), Math.sin(alpha), v);\n    }\n\n    Vector.prototype.normalize = function() {\n        var n = this.len();\n        var res = this.div(n);\n        return res;\n    }\n\n    Vector.prototype.toAngle = function() {\n        // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n        if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n        if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n        var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n        var deg = rads * Rad2Degree;\n        if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n        else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n        else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n        return deg;\n    }\n\n    // divide all vector components by the same value\n    Vector.prototype.div = function(n) {\n        res = []\n        res[0] = this[0] / n;\n        res[1] = this[1] / n;\n        res[2] = this[2] / n;\n        return new Vector(res);\n    }\n\n    // subtract one vector from another\n    Vector.prototype.sub = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] - v[0];\n        res[1] = this[1] - v[1];\n        res[2] = this[2] - v[2];\n        return res;\n    }\n\n    Vector.prototype.add = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] + v[0];\n        res[1] = this[1] + v[1];\n        res[2] = this[2] + v[2];\n        return res;\n    }\n\n    Vector.prototype.smul = function(k) {  // scalar multiplication\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] * k;\n        res[1] = this[1] * k;\n        res[2] = this[2] * k;\n        return res;\n    }\n\n    Vector.prototype.scale = function(xs,ys) {\n        res = new Vector(0,0,0);\n        res[0] =  this[0] * ys;\n        res[1] =  this[1] * xs;\n        res[2] = 1.0;\n        return res;\n    }\n\n    Vector.prototype.len = function() {\n        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n    }\n\n\n    TurtleGraphics.defaults = { canvasID: 'mycanvas', degrees: true, animate: true }\n    TurtleGraphics.turtleList = [];\n    TurtleGraphics.Turtle = Turtle;\n    TurtleGraphics.TurtleCanvas = TurtleCanvas;\n    TurtleGraphics.canvasLib = {}\n    TurtleGraphics.clear_canvas = clear_canvas;\n    TurtleGraphics.Vector = Vector;\n    TurtleGraphics.canvasInit = false;\n    TurtleGraphics.eventCount = 0;\n    TurtleGraphics.renderClock = 0;\n    TurtleGraphics.renderTime  = 0; // RNL\n\n})();\n\n\n//\n// Wrapper around the Turtle Module starts here.\n//\n//\nvar $builtinmodule = function(name) {\n    var mod = {};\n    // First we create an object, this will end up being the class\n    // class\n    Sk.tg = TurtleGraphics;\n\n    var checkArgs = function(expected, actual, func) {\n        if (actual != expected ) {\n            throw new Sk.builtin.TypeError(func + \" takes exactly \" + expected +\n                    \" positional argument (\" + actual + \" given)\")\n        }\n    }\n\n    var turtle = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            self.theTurtle = new TurtleGraphics.Turtle();\n        });\n\n//\n// Turtle Motion\n//\n        //\n        // Move and Draw\n        //\n        $loc.forward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,\"forward()\");\n            self.theTurtle.forward(dist);\n        });\n\n        $loc.fd = $loc.forward;\n\n        $loc.backward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,\"backward()\");\n            self.theTurtle.forward(-dist);\n        });\n\n        $loc.back = $loc.backward;\n        $loc.bk = $loc.backward;\n\n        $loc.right = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,\"right()\");\n            self.theTurtle.turn(angle);\n        });\n\n        $loc.rt = $loc.right;\n\n        $loc.left = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,\"left()\");\n            self.theTurtle.turn(-angle);\n        });\n\n        $loc.lt = $loc.left;\n\n        $loc.goto_$rw$ = new Sk.builtin.func(function(self, nx, ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,\"goto()\");\n            self.theTurtle.goto(nx, ny);\n        });\n\n        $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,\"setposition()\");\n            self.theTurtle.up();\n            self.theTurtle.goto(nx,ny);\n            self.theTurtle.down();\n        });\n        $loc.setpos = $loc.setposition;\n\n        $loc.setx = new Sk.builtin.func(function(self, nx) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n            checkArgs(2,arguments.length,\"setx()\");\n            self.theTurtle.goto(nx, self.theTurtle.GetY());\n        });\n\n        $loc.sety = new Sk.builtin.func(function(self, ny) {\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(2,arguments.length,\"sety()\");\n            self.theTurtle.goto(self.theTurtle.GetX(), ny);\n        });\n\n        $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n\t\t\tnewhead = Sk.builtin.asnum$(newhead);\n            checkArgs(2,arguments.length,\"setheading()\");\n            return self.theTurtle.set_heading(newhead);\n        });\n\n        $loc.seth = $loc.setheading;\n\n        $loc.home = new Sk.builtin.func(function(self) {\n            self.theTurtle.go_home();\n        });\n\n        $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n\t\t\tsize = Sk.builtin.asnum$(size);\n            size = size || 1;\n            if (color) {\n                color = color.v || self.theTurtle.penStyle;\n            }\n            self.theTurtle.dot(size, color);\n        });\n\n        $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n\t\t\tradius = Sk.builtin.asnum$(radius);\n\t\t\textent = Sk.builtin.asnum$(extent);\n            self.theTurtle.circle(radius, extent);\n        });\n\n        $loc.delay = new Sk.builtin.func(function(self, d) {\n\t\t\td = Sk.builtin.asnum$(d);\n            return self.theTurtle.delay(d);\n        });\n\n        $loc.speed = new Sk.builtin.func(function(self, s, t) {\n\t\t\ts = Sk.builtin.asnum$(s);\n\t\t\tt = Sk.builtin.asnum$(t);\n            self.theTurtle.speed(s,t);\n        });\n\n        $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n\t\t\tt = Sk.builtin.asnum$(t);\n\t\t\td = Sk.builtin.asnum$(d);\n            self.theTurtle.tracer(t, d);\n        });\n\n\t\t$loc.update = new Sk.builtin.func(function(self) {\n\t\t\t//\tDummy function to emulate update... when not animating, we don't save the drawing operations, so this is pointless for us\n\t\t});\n\n        // todo:  stamp, clearstamp, clearstamps, undo, speed\n\n        //\n        // Tell Turtle's state\n        //\n        $loc.heading = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"heading()\");\n            return self.theTurtle.get_heading();\n        });\n\n        $loc.position = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"position()\");\n            var res = self.theTurtle.get_position();\n            var x = new Sk.builtin.tuple([res[0],res[1]]);\n            return x;\n        });\n\n        $loc.pos = $loc.position;\n\n        $loc.xcor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"xcor()\");\n            var res = self.theTurtle.getx();\n            return res;\n        });\n\n        $loc.ycor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"ycor()\");\n            var res = self.theTurtle.gety();\n            return res;\n        });\n\n        $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === 'number')\n                tx = [tx, ty, 0];\n            return self.theTurtle.towards(tx);\n        });\n\n        // tx can be either a number or a vector position.\n        // tx can not be a turtle at this time as multiple turtles have not been implemented yet.\n        $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === 'number') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [tx.theTurtle.getx(), tx.theTurtle.gety(), 0];\n            }\n            return self.theTurtle.distance(tx);\n        });\n\n        //\n        // Setting and Measurement\n        //\n\n        // todo:  degrees and radians...\n\n//\n// Pen Control\n//\n\n        //\n        // Drawing State\n        //\n\n        $loc.up = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"up()\");\n            self.theTurtle.pen_up();\n        });\n\n        $loc.penup = $loc.up;\n        $loc.pu = $loc.up;\n\n        $loc.down = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"down()\");\n            self.theTurtle.pen_down();\n        });\n\n        $loc.pendown = $loc.down;\n        $loc.pd = $loc.down;\n\n        $loc.width = new Sk.builtin.func(function(self, w) {\n\t\t\tw = Sk.builtin.asnum$(w);\n            checkArgs(2,arguments.length,\"width()\");\n            self.theTurtle.set_pen_width(w);\n        });\n\n        $loc.pensize = $loc.width;\n\n        $loc.isdown = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"isdown()\");\n            return self.theTurtle.get_pen();\n        });\n\n        // todo:  pen  -- return a dictionary full of pen stuff\n\n        //\n        // Color Control\n        //\n\n        $loc.fillcolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else\n                return self.theTurtle.fillStyle;\n        });\n\n        $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n\t\t\t\t\tcolor = Sk.builtin.asnum$(color);\n\t\t\t\t\tgreen = Sk.builtin.asnum$(green);\n\t\t\t\t\tblue = Sk.builtin.asnum$(blue);\n                    self.theTurtle.set_pen_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                }\n            } else\n                return self.theTurtle.penStyle;\n        });\n\n        $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n            if(color) {\n                if (blue) {\n                    self.theTurtle.set_pen_color(color, green, blue);\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else \n                return [self.theTurtle.penStyle, self.theTurtle.fillStyle];            \n        });\n\n        //\n        //  Filling\n        //\n\n        $loc.begin_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"begin_fill()\");\n            self.theTurtle.begin_fill();\n        });\n\n        $loc.end_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"end_fill()\");\n            self.theTurtle.end_fill();\n        });\n\n        $loc.fill = new Sk.builtin.func(function(self, fillt) {\n\t\t\tif (fillt === undefined)\n\t\t\t\treturn self.theTurtle.filling;\n            if (fillt)\n                self.theTurtle.begin_fill();\n            else\n                self.theTurtle.end_fill();\n        });\n\n        //\n        // More drawing control\n        //\n\n        $loc.reset = new Sk.builtin.func(function(self) {\n            self.theTurtle.clean();\n        });\n\n        $loc.showturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"showturtle()\");\n            self.theTurtle.showturtle();\n        });\n        $loc.st = $loc.showturtle;\n\n        $loc.hideturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"hideturtle()\");\n            self.theTurtle.hideturtle();\n        });\n        $loc.ht = $loc.hideturtle;\n\n        $loc.isvisible = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"isvisible()\");\n            self.theTurtle.isvisible()\n        });\n\n        $loc.stamp = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,\"stamp()\");\n            self.theTurtle.stamp();\n        });\n\n        $loc.shape = new Sk.builtin.func(function(self, s) {\n            checkArgs(2,arguments.length,\"shape()\");\n            self.theTurtle.shape(s.v);\n        });\n\n\n        // todo the move, align, and font parameters should be kwargs...\n        $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n            self.theTurtle.write(mystr.v, move, align, font);\n        });\n\n        // todo clean  -- again multiple turtles\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theTurtle.setworldcoordinates(llx, lly, urx, ury);\n        });\n\n\t\t//\tAdded by RNL\n\n\t\t$loc.clear = new Sk.builtin.func(function(self) {\n\t\t\tself.theTurtle.clear()\n\t\t});\n\n    }\n\n    mod.Turtle = Sk.misceval.buildClass(mod, turtle, 'Turtle', []);\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            var currentCanvas = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID];\n            if (currentCanvas === undefined) {\n                self.theScreen = new TurtleGraphics.TurtleCanvas(TurtleGraphics.defaults);\n            } else {\n                self.theScreen = currentCanvas;\n            }\n        });\n\n        $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n            self.theScreen.bgcolor(c);\n        });\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n        });\n\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            self.theScreen.exitonclick();\n        });\n\n        $loc.title = new Sk.builtin.func(function(self,titlestring) {\n            // no op....\n        });\n\n        $loc.window_width = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_width();\n        });\n\n        $loc.window_height = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_height();\n        });\n\n        $loc.turtles = new Sk.builtin.func(function(self) {\n            return self.theScreen.turtles();\n        });\n\n\t\t$loc.colormode = new Sk.builtin.func(function(self) {\n\t\t\t//\tEmpty function to emulate compatibility\n\t\t});\n        \n//        $loc.clear = new Sk.builtin.func(function(self) {\n//        \t\n//        });\n\n        var myfunc = function(self, width, height, startx, starty) {\n\t\t\twidth = Sk.builtin.asnum$(width);\n\t\t\theight = Sk.builtin.asnum$(height);\n            self.theScreen.setup(width,height);\n        }\n        // this should allow for named parameters\n        myfunc.co_varnames = ['self','width','height','startx','starty'];\n        myfunc.$defaults = [null,500,500,0,0];\n        $loc.setup = new Sk.builtin.func(myfunc);\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod, screen, 'Screen', []);\n\n    mod.tracer = new Sk.builtin.func(function(t, d) {\n\t\tt = Sk.builtin.asnum$(t);\n\t\td = Sk.builtin.asnum$(d);\n\t\tfor (var i in Sk.tg.canvasLib)\n\t\t\tSk.tg.canvasLib[i].tracer(t, d);\n    });\n\n\tmod.update = new Sk.builtin.func(function(self) {\n\t\t//\tDummy function to emulate update... when not animating, we don't save the drawing operations, so this is pointless for us\n\t});\n\n\n    return mod\n}\n", "src/lib/webgl/math.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; should probably put this in a math package\n    mod.Mat44 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                        self.stack = [];\n                    });\n\n                $loc.push = new Sk.builtin.func(function(self)\n                    {\n                        self.stack.push(self.elements.slice(0));\n                    });\n\n                $loc.pop = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = self.stack.pop();\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0, 0.0,\n                                         0.0, 0.0, 1.0, 0.0,\n                                         0.0, 0.0, 0.0, 1.0];\n                    });\n\n                $loc.transform3 = new Sk.builtin.func(function(self, v)\n                    {\n                        var e = self.elements;\n                        return Sk.misceval.callsim(mod.Vec3,\n                            e[0] * v.x + e[4] * v.y + e[8] * v.z,\n                            e[1] * v.x + e[5] * v.y + e[9] * v.z,\n                            e[2] * v.x + e[6] * v.y + e[10] * v.z);\n                    });\n\n                $loc.scale = new Sk.builtin.func(function(self, sx, sy, sz)\n                        {\n                            self.elements[0*4+0] *= sx;\n                            self.elements[0*4+1] *= sx;\n                            self.elements[0*4+2] *= sx;\n                            self.elements[0*4+3] *= sx;\n\n                            self.elements[1*4+0] *= sy;\n                            self.elements[1*4+1] *= sy;\n                            self.elements[1*4+2] *= sy;\n                            self.elements[1*4+3] *= sy;\n\n                            self.elements[2*4+0] *= sz;\n                            self.elements[2*4+1] *= sz;\n                            self.elements[2*4+2] *= sz;\n                            self.elements[2*4+3] *= sz;\n\n                            return self;\n                        });\n\n                $loc.translate = new Sk.builtin.func(function(self, tx, ty, tz)\n                        {\n                            self.elements[3*4+0] += self.elements[0*4+0] * tx + self.elements[1*4+0] * ty + self.elements[2*4+0] * tz;\n                            self.elements[3*4+1] += self.elements[0*4+1] * tx + self.elements[1*4+1] * ty + self.elements[2*4+1] * tz;\n                            self.elements[3*4+2] += self.elements[0*4+2] * tx + self.elements[1*4+2] * ty + self.elements[2*4+2] * tz;\n                            self.elements[3*4+3] += self.elements[0*4+3] * tx + self.elements[1*4+3] * ty + self.elements[2*4+3] * tz;\n                            return self;\n                        });\n\n                $loc.rotate = new Sk.builtin.func(function(self, angle, x, y, z)\n                        {\n                            var mag = Math.sqrt(x*x + y*y + z*z);\n                            var sinAngle = Math.sin(angle * Math.PI / 180.0);\n                            var cosAngle = Math.cos(angle * Math.PI / 180.0);\n\n                            if (mag > 0)\n                            {\n                                var xx, yy, zz, xy, yz, zx, xs, ys, zs;\n                                var oneMinusCos;\n                                var rotMat;\n\n                                x /= mag;\n                                y /= mag;\n                                z /= mag;\n\n                                xx = x * x;\n                                yy = y * y;\n                                zz = z * z;\n                                xy = x * y;\n                                yz = y * z;\n                                zx = z * x;\n                                xs = x * sinAngle;\n                                ys = y * sinAngle;\n                                zs = z * sinAngle;\n                                oneMinusCos = 1.0 - cosAngle;\n\n                                rotMat = Sk.misceval.callsim(mod.Mat44);\n\n                                rotMat.elements[0*4+0] = (oneMinusCos * xx) + cosAngle;\n                                rotMat.elements[0*4+1] = (oneMinusCos * xy) - zs;\n                                rotMat.elements[0*4+2] = (oneMinusCos * zx) + ys;\n                                rotMat.elements[0*4+3] = 0.0;\n\n                                rotMat.elements[1*4+0] = (oneMinusCos * xy) + zs;\n                                rotMat.elements[1*4+1] = (oneMinusCos * yy) + cosAngle;\n                                rotMat.elements[1*4+2] = (oneMinusCos * yz) - xs;\n                                rotMat.elements[1*4+3] = 0.0;\n\n                                rotMat.elements[2*4+0] = (oneMinusCos * zx) - ys;\n                                rotMat.elements[2*4+1] = (oneMinusCos * yz) + xs;\n                                rotMat.elements[2*4+2] = (oneMinusCos * zz) + cosAngle;\n                                rotMat.elements[2*4+3] = 0.0;\n\n                                rotMat.elements[3*4+0] = 0.0;\n                                rotMat.elements[3*4+1] = 0.0;\n                                rotMat.elements[3*4+2] = 0.0;\n                                rotMat.elements[3*4+3] = 1.0;\n\n                                rotMat = rotMat.multiply(self);\n                                self.elements = rotMat.elements;\n                            }\n                            return self;\n                        });\n\n                $loc.multiply = new Sk.builtin.func(function(self, right)\n                        {\n                            var tmp = Sk.misceval.callsim(mod.Mat44);\n\n                            for (var i = 0; i < 4; i++)\n                            {\n                                tmp.elements[i*4+0] =\n                                (self.elements[i*4+0] * right.elements[0*4+0]) +\n                                (self.elements[i*4+1] * right.elements[1*4+0]) +\n                                (self.elements[i*4+2] * right.elements[2*4+0]) +\n                                (self.elements[i*4+3] * right.elements[3*4+0]) ;\n\n                                tmp.elements[i*4+1] =\n                                (self.elements[i*4+0] * right.elements[0*4+1]) +\n                                (self.elements[i*4+1] * right.elements[1*4+1]) +\n                                (self.elements[i*4+2] * right.elements[2*4+1]) +\n                                (self.elements[i*4+3] * right.elements[3*4+1]) ;\n\n                                tmp.elements[i*4+2] =\n                                (self.elements[i*4+0] * right.elements[0*4+2]) +\n                                (self.elements[i*4+1] * right.elements[1*4+2]) +\n                                (self.elements[i*4+2] * right.elements[2*4+2]) +\n                                (self.elements[i*4+3] * right.elements[3*4+2]) ;\n\n                                tmp.elements[i*4+3] =\n                                (self.elements[i*4+0] * right.elements[0*4+3]) +\n                                (self.elements[i*4+1] * right.elements[1*4+3]) +\n                                (self.elements[i*4+2] * right.elements[2*4+3]) +\n                                (self.elements[i*4+3] * right.elements[3*4+3]) ;\n                            }\n\n                            self.elements = tmp.elements;\n                            return self;\n                        });\n\n                /* Following gluLookAt implementation is adapted from\n                 * the Mesa 3D Graphics library. http://www.mesa3d.org\n                 */\n                // todo; rewrite this with proper vec/mat ops\n                $loc.lookAt = new Sk.builtin.func(function(self, eyeX, eyeY, eyeZ,\n                                                                 centerX, centerY, centerZ,\n                                                                 upX, upY, upZ)\n                        {\n                            /* Z vector */\n                            var z = [\n                                eyeX - centerX,\n                                eyeY - centerY,\n                                eyeZ - centerZ\n                            ];\n                            var mag = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);\n                            if (mag)\n                            {\n                                z[0] /= mag;\n                                z[1] /= mag;\n                                z[2] /= mag;\n                            }\n\n                            /* Y vector */\n                            var y = [ upX, upY, upZ ];\n\n                            /* X vector = Y cross Z */\n                            var x = [];\n                            x[0] = y[1] * z[2] - y[2] * z[1];\n                            x[1] = -y[0] * z[2] + y[2] * z[0];\n                            x[2] = y[0] * z[1] - y[1] * z[0];\n\n                            /* Recompute Y = Z cross X */\n                            y[0] = z[1] * x[2] - z[2] * x[1];\n                            y[1] = -z[0] * x[2] + z[2] * x[0];\n                            y[2] = z[0] * x[1] - z[1] * x[0];\n\n                            /* mpichler, 19950515 */\n                            /* cross product gives area of parallelogram, which is < 1.0 for\n                            * non-perpendicular unit-length vectors; so normalize x, y here\n                            */\n\n                            mag = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n                            if (mag) {\n                                x[0] /= mag;\n                                x[1] /= mag;\n                                x[2] /= mag;\n                            }\n\n                            mag = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);\n                            if (mag) {\n                                y[0] /= mag;\n                                y[1] /= mag;\n                                y[2] /= mag;\n                            }\n\n                            var lookAt = Sk.misceval.callsim(mod.Mat44);\n                            lookAt.elements[0 * 4 + 0] = x[0];\n                            lookAt.elements[1 * 4 + 0] = x[1];\n                            lookAt.elements[2 * 4 + 0] = x[2];\n                            lookAt.elements[3 * 4 + 0] = 0.;\n                            lookAt.elements[0 * 4 + 1] = y[0];\n                            lookAt.elements[1 * 4 + 1] = y[1];\n                            lookAt.elements[2 * 4 + 1] = y[2];\n                            lookAt.elements[3 * 4 + 1] = 0.;\n                            lookAt.elements[0 * 4 + 2] = z[0];\n                            lookAt.elements[1 * 4 + 2] = z[1];\n                            lookAt.elements[2 * 4 + 2] = z[2];\n                            lookAt.elements[3 * 4 + 2] = 0.;\n                            lookAt.elements[0 * 4 + 3] = 0.;\n                            lookAt.elements[1 * 4 + 3] = 0.;\n                            lookAt.elements[2 * 4 + 3] = 0.;\n                            lookAt.elements[3 * 4 + 3] = 1.;\n\n                            // log(lookAt.elements);\n\n                            lookAt = lookAt.multiply(self);\n                            self.elements = lookAt.elements;\n                            self.translate(-eyeX, -eyeY, -eyeZ);\n\n                            // log(this.elements);\n\n                            return self;\n                        });\n            },\n            'Mat44', []);\n\n    // todo; should probably put this in a math package\n    mod.Mat33 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0,\n                                         0.0, 0.0, 1.0];\n                    });\n            },\n            'Mat33', []);\n\n    mod.Vec3 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, x, y, z)\n                    {\n                        self.x = x;\n                        self.y = y;\n                        self.z = z;\n                    });\n                $loc.__sub__ = new Sk.builtin.func(function(self, other)\n                    {\n                        return Sk.misceval.callsim(mod.Vec3, self.x - other.x, self.y - other.y, self.z - other.z);\n                    });\n            },\n            'Vec3', []);\n    \n    mod.cross = new Sk.builtin.func(function(v1, v2)\n            {\n                goog.asserts.assert(v1 instanceof mod.Vec3 && v2 instanceof mod.Vec3);\n                return Sk.misceval.callsim(mod.Vec3,\n                    v1.y * v2.z - v1.z * v2.y,\n                    v1.z * v2.x - v1.x * v2.z,\n                    v1.x * v2.y - v1.y * v2.x);\n            });\n\n    return mod;\n};\n", "src/builtin/unittest.py": "#!/usr/bin/env python\n'''\nPython unit testing framework, based on Erich Gamma's JUnit and Kent Beck's\nSmalltalk testing framework.\n\nThis module contains the core framework classes that form the basis of\nspecific test cases and suites (TestCase, TestSuite etc.), and also a\ntext-based utility class for running the tests and reporting the results\n (TextTestRunner).\n\nSimple usage:\n\n    import unittest\n\n    class IntegerArithmenticTestCase(unittest.TestCase):\n        def testAdd(self):  ## test method names begin 'test*'\n            self.assertEquals((1 + 2), 3)\n            self.assertEquals(0 + 1, 1)\n        def testMultiply(self):\n            self.assertEquals((0 * 10), 0)\n            self.assertEquals((5 * 8), 40)\n\n    if __name__ == '__main__':\n        unittest.main()\n\nFurther information is available in the bundled documentation, and from\n\n  http://docs.python.org/lib/module-unittest.html\n\nCopyright (c) 1999-2003 Steve Purcell\nThis module is free software, and you may redistribute it and/or modify\nit under the same terms as Python itself, so long as this copyright message\nand disclaimer are retained in their original form.\n\nIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\nSPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\nTHIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN \"AS IS\" BASIS,\nAND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,\nSUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n'''\n\n__author__ = \"Steve Purcell\"\n__email__ = \"stephen_purcell at yahoo dot com\"\n__version__ = \"#Revision: 1.63 $\"[11:-2]\n\nimport time\nimport sys\nimport traceback\nimport os\nimport types\n\n##############################################################################\n# Exported classes and functions\n##############################################################################\n__all__ = ['TestResult', 'TestCase', 'TestSuite', 'TextTestRunner',\n           'TestLoader', 'FunctionTestCase', 'main', 'defaultTestLoader']\n\n# Expose obsolete functions for backwards compatibility\n__all__.extend(['getTestCaseNames', 'makeSuite', 'findTestCases'])\n\n\n##############################################################################\n# Backward compatibility\n##############################################################################\nif sys.version_info[:2] < (2, 2):\n    def isinstance(obj, clsinfo):\n        import __builtin__\n        if type(clsinfo) in (tuple, list):\n            for cls in clsinfo:\n                if cls is type: cls = types.ClassType\n                if __builtin__.isinstance(obj, cls):\n                    return 1\n            return 0\n        else: return __builtin__.isinstance(obj, clsinfo)\n\ndef _CmpToKey(mycmp):\n    'Convert a cmp= function into a key= function'\n    class K(object):\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) == -1\n    return K\n\n##############################################################################\n# Test framework core\n##############################################################################\n\n# All classes defined herein are 'new-style' classes, allowing use of 'super()'\n__metaclass__ = type\n\ndef _strclass(cls):\n    return \"%s.%s\" % (cls.__module__, cls.__name__)\n\n__unittest = 1\n\nclass TestResult:\n    \"\"\"Holder for test result information.\n\n    Test results are automatically managed by the TestCase and TestSuite\n    classes, and do not need to be explicitly manipulated by writers of tests.\n\n    Each instance holds the total number of tests run, and collections of\n    failures and errors that occurred among those test runs. The collections\n    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the\n    formatted traceback of the error that occurred.\n    \"\"\"\n    def __init__(self):\n        self.failures = []\n        self.errors = []\n        self.testsRun = 0\n        self.shouldStop = False\n\n    def startTest(self, test):\n        \"Called when the given test is about to be run\"\n        self.testsRun = self.testsRun + 1\n\n    def stopTest(self, test):\n        \"Called when the given test has been run\"\n        pass\n\n    def addError(self, test, err):\n        \"\"\"Called when an error has occurred. 'err' is a tuple of values as\n        returned by sys.exc_info().\n        \"\"\"\n        self.errors.append((test, self._exc_info_to_string(err, test)))\n\n    def addFailure(self, test, err):\n        \"\"\"Called when an error has occurred. 'err' is a tuple of values as\n        returned by sys.exc_info().\"\"\"\n        self.failures.append((test, self._exc_info_to_string(err, test)))\n\n    def addSuccess(self, test):\n        \"Called when a test has completed successfully\"\n        pass\n\n    def wasSuccessful(self):\n        \"Tells whether or not this result was a success\"\n        return len(self.failures) == len(self.errors) == 0\n\n    def stop(self):\n        \"Indicates that the tests should be aborted\"\n        self.shouldStop = True\n\n    def _exc_info_to_string(self, err, test):\n        \"\"\"Converts a sys.exc_info()-style tuple of values into a string.\"\"\"\n        exctype, value, tb = err\n        # Skip test runner traceback levels\n        while tb and self._is_relevant_tb_level(tb):\n            tb = tb.tb_next\n        if exctype is test.failureException:\n            # Skip assert*() traceback levels\n            length = self._count_relevant_tb_levels(tb)\n            return ''.join(traceback.format_exception(exctype, value, tb, length))\n        return ''.join(traceback.format_exception(exctype, value, tb))\n\n    def _is_relevant_tb_level(self, tb):\n        return '__unittest' in tb.tb_frame.f_globals\n\n    def _count_relevant_tb_levels(self, tb):\n        length = 0\n        while tb and not self._is_relevant_tb_level(tb):\n            length += 1\n            tb = tb.tb_next\n        return length\n\n    def __repr__(self):\n        return \"<%s run=%i errors=%i failures=%i>\" % \\\n               (_strclass(self.__class__), self.testsRun, len(self.errors),\n                len(self.failures))\n\nclass TestCase:\n    \"\"\"A class whose instances are single test cases.\n\n    By default, the test code itself should be placed in a method named\n    'runTest'.\n\n    If the fixture may be used for many test cases, create as\n    many test methods as are needed. When instantiating such a TestCase\n    subclass, specify in the constructor arguments the name of the test method\n    that the instance is to execute.\n\n    Test authors should subclass TestCase for their own tests. Construction\n    and deconstruction of the test's environment ('fixture') can be\n    implemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\n    If it is necessary to override the __init__ method, the base class\n    __init__ method must always be called. It is important that subclasses\n    should not change the signature of their __init__ method, since instances\n    of the classes are instantiated automatically by parts of the framework\n    in order to be run.\n    \"\"\"\n\n    # This attribute determines which exception will be raised when\n    # the instance's assertion methods fail; test methods raising this\n    # exception will be deemed to have 'failed' rather than 'errored'\n\n    failureException = AssertionError\n\n    def __init__(self, methodName='runTest'):\n        \"\"\"Create an instance of the class that will use the named test\n           method when executed. Raises a ValueError if the instance does\n           not have a method with the specified name.\n        \"\"\"\n        try:\n            self._testMethodName = methodName\n            testMethod = getattr(self, methodName)\n            self._testMethodDoc = testMethod.__doc__\n        except AttributeError:\n            raise ValueError, \"no such test method in %s: %s\" % \\\n                  (self.__class__, methodName)\n\n    def setUp(self):\n        \"Hook method for setting up the test fixture before exercising it.\"\n        pass\n\n    def tearDown(self):\n        \"Hook method for deconstructing the test fixture after testing it.\"\n        pass\n\n    def countTestCases(self):\n        return 1\n\n    def defaultTestResult(self):\n        return TestResult()\n\n    def shortDescription(self):\n        \"\"\"Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method's docstring.\n        \"\"\"\n        doc = self._testMethodDoc\n        return doc and doc.split(\"\\n\")[0].strip() or None\n\n    def id(self):\n        return \"%s.%s\" % (_strclass(self.__class__), self._testMethodName)\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self._testMethodName == other._testMethodName\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self._testMethodName))\n\n    def __str__(self):\n        return \"%s (%s)\" % (self._testMethodName, _strclass(self.__class__))\n\n    def __repr__(self):\n        return \"<%s testMethod=%s>\" % \\\n               (_strclass(self.__class__), self._testMethodName)\n\n    def run(self, result=None):\n        if result is None: result = self.defaultTestResult()\n        result.startTest(self)\n        testMethod = getattr(self, self._testMethodName)\n        try:\n            try:\n                self.setUp()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                return\n\n            ok = False\n            try:\n                testMethod()\n                ok = True\n            except self.failureException:\n                result.addFailure(self, self._exc_info())\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n\n            try:\n                self.tearDown()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                ok = False\n            if ok: result.addSuccess(self)\n        finally:\n            result.stopTest(self)\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        \"\"\"Run the test without collecting errors in a TestResult\"\"\"\n        self.setUp()\n        getattr(self, self._testMethodName)()\n        self.tearDown()\n\n    def _exc_info(self):\n        \"\"\"Return a version of sys.exc_info() with the traceback frame\n           minimised; usually the top level of the traceback frame is not\n           needed.\n        \"\"\"\n        return sys.exc_info()\n\n    def fail(self, msg=None):\n        \"\"\"Fail immediately, with the given message.\"\"\"\n        raise self.failureException, msg\n\n    def failIf(self, expr, msg=None):\n        \"Fail the test if the expression is true.\"\n        if expr: raise self.failureException, msg\n\n    def failUnless(self, expr, msg=None):\n        \"\"\"Fail the test unless the expression is true.\"\"\"\n        if not expr: raise self.failureException, msg\n\n    def failUnlessRaises(self, excClass, callableObj, *args, **kwargs):\n        \"\"\"Fail unless an exception of class excClass is thrown\n           by callableObj when invoked with arguments args and keyword\n           arguments kwargs. If a different type of exception is\n           thrown, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n        \"\"\"\n        try:\n            callableObj(*args, **kwargs)\n        except excClass:\n            return\n        else:\n            if hasattr(excClass,'__name__'): excName = excClass.__name__\n            else: excName = str(excClass)\n            raise self.failureException, \"%s not raised\" % excName\n\n    def failUnlessEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by the '=='\n           operator.\n        \"\"\"\n        if not first == second:\n            raise self.failureException, \\\n                  (msg or '%r != %r' % (first, second))\n\n    def failIfEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by the '=='\n           operator.\n        \"\"\"\n        if first == second:\n            raise self.failureException, \\\n                  (msg or '%r == %r' % (first, second))\n\n    def failUnlessAlmostEqual(self, first, second, places=7, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        \"\"\"\n        if round(abs(second-first), places) != 0:\n            raise self.failureException, \\\n                  (msg or '%r != %r within %r places' % (first, second, places))\n\n    def failIfAlmostEqual(self, first, second, places=7, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        \"\"\"\n        if round(abs(second-first), places) == 0:\n            raise self.failureException, \\\n                  (msg or '%r == %r within %r places' % (first, second, places))\n\n    # Synonyms for assertion methods\n\n    assertEqual = assertEquals = failUnlessEqual\n\n    assertNotEqual = assertNotEquals = failIfEqual\n\n    assertAlmostEqual = assertAlmostEquals = failUnlessAlmostEqual\n\n    assertNotAlmostEqual = assertNotAlmostEquals = failIfAlmostEqual\n\n    assertRaises = failUnlessRaises\n\n    assert_ = assertTrue = failUnless\n\n    assertFalse = failIf\n\n\n\nclass TestSuite:\n    \"\"\"A test suite is a composite test consisting of a number of TestCases.\n\n    For use, create an instance of TestSuite, then add test case instances.\n    When all tests have been added, the suite can be passed to a test\n    runner, such as TextTestRunner. It will run the individual test cases\n    in the order in which they were added, aggregating the results. When\n    subclassing, do not forget to call the base class constructor.\n    \"\"\"\n    def __init__(self, tests=()):\n        self._tests = []\n        self.addTests(tests)\n\n    def __repr__(self):\n        return \"<%s tests=%s>\" % (_strclass(self.__class__), self._tests)\n\n    __str__ = __repr__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n        return self._tests == other._tests\n\n    def __ne__(self, other):\n        return not self == other\n\n    # Can't guarantee hash invariant, so flag as unhashable\n    __hash__ = None\n\n    def __iter__(self):\n        return iter(self._tests)\n\n    def countTestCases(self):\n        cases = 0\n        for test in self._tests:\n            cases += test.countTestCases()\n        return cases\n\n    def addTest(self, test):\n        # sanity checks\n        if not hasattr(test, '__call__'):\n            raise TypeError(\"the test to add must be callable\")\n        if (isinstance(test, (type, types.ClassType)) and\n            issubclass(test, (TestCase, TestSuite))):\n            raise TypeError(\"TestCases and TestSuites must be instantiated \"\n                            \"before passing them to addTest()\")\n        self._tests.append(test)\n\n    def addTests(self, tests):\n        if isinstance(tests, basestring):\n            raise TypeError(\"tests must be an iterable of tests, not a string\")\n        for test in tests:\n            self.addTest(test)\n\n    def run(self, result):\n        for test in self._tests:\n            if result.shouldStop:\n                break\n            test(result)\n        return result\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        \"\"\"Run the tests without collecting errors in a TestResult\"\"\"\n        for test in self._tests: test.debug()\n\n\nclass FunctionTestCase(TestCase):\n    \"\"\"A test case that wraps a test function.\n\n    This is useful for slipping pre-existing test functions into the\n    unittest framework. Optionally, set-up and tidy-up functions can be\n    supplied. As with TestCase, the tidy-up ('tearDown') function will\n    always be called if the set-up ('setUp') function ran successfully.\n    \"\"\"\n\n    def __init__(self, testFunc, setUp=None, tearDown=None,\n                 description=None):\n        TestCase.__init__(self)\n        self.__setUpFunc = setUp\n        self.__tearDownFunc = tearDown\n        self.__testFunc = testFunc\n        self.__description = description\n\n    def setUp(self):\n        if self.__setUpFunc is not None:\n            self.__setUpFunc()\n\n    def tearDown(self):\n        if self.__tearDownFunc is not None:\n            self.__tearDownFunc()\n\n    def runTest(self):\n        self.__testFunc()\n\n    def id(self):\n        return self.__testFunc.__name__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self.__setUpFunc == other.__setUpFunc and \\\n               self.__tearDownFunc == other.__tearDownFunc and \\\n               self.__testFunc == other.__testFunc and \\\n               self.__description == other.__description\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self.__setUpFunc, self.__tearDownFunc,\n                                           self.__testFunc, self.__description))\n\n    def __str__(self):\n        return \"%s (%s)\" % (_strclass(self.__class__), self.__testFunc.__name__)\n\n    def __repr__(self):\n        return \"<%s testFunc=%s>\" % (_strclass(self.__class__), self.__testFunc)\n\n    def shortDescription(self):\n        if self.__description is not None: return self.__description\n        doc = self.__testFunc.__doc__\n        return doc and doc.split(\"\\n\")[0].strip() or None\n\n\n\n##############################################################################\n# Locating and loading tests\n##############################################################################\n\nclass TestLoader:\n    \"\"\"This class is responsible for loading tests according to various\n    criteria and returning them wrapped in a TestSuite\n    \"\"\"\n    testMethodPrefix = 'test'\n    sortTestMethodsUsing = cmp\n    suiteClass = TestSuite\n\n    def loadTestsFromTestCase(self, testCaseClass):\n        \"\"\"Return a suite of all tests cases contained in testCaseClass\"\"\"\n        if issubclass(testCaseClass, TestSuite):\n            raise TypeError(\"Test cases should not be derived from TestSuite. Maybe you meant to derive from TestCase?\")\n        testCaseNames = self.getTestCaseNames(testCaseClass)\n        if not testCaseNames and hasattr(testCaseClass, 'runTest'):\n            testCaseNames = ['runTest']\n        return self.suiteClass(map(testCaseClass, testCaseNames))\n\n    def loadTestsFromModule(self, module):\n        \"\"\"Return a suite of all tests cases contained in the given module\"\"\"\n        tests = []\n        for name in dir(module):\n            obj = getattr(module, name)\n            if (isinstance(obj, (type, types.ClassType)) and\n                issubclass(obj, TestCase)):\n                tests.append(self.loadTestsFromTestCase(obj))\n        return self.suiteClass(tests)\n\n    def loadTestsFromName(self, name, module=None):\n        \"\"\"Return a suite of all tests cases given a string specifier.\n\n        The name may resolve either to a module, a test case class, a\n        test method within a test case class, or a callable object which\n        returns a TestCase or TestSuite instance.\n\n        The method optionally resolves the names relative to a given module.\n        \"\"\"\n        parts = name.split('.')\n        if module is None:\n            parts_copy = parts[:]\n            while parts_copy:\n                try:\n                    module = __import__('.'.join(parts_copy))\n                    break\n                except ImportError:\n                    del parts_copy[-1]\n                    if not parts_copy: raise\n            parts = parts[1:]\n        obj = module\n        for part in parts:\n            parent, obj = obj, getattr(obj, part)\n\n        if type(obj) == types.ModuleType:\n            return self.loadTestsFromModule(obj)\n        elif (isinstance(obj, (type, types.ClassType)) and\n              issubclass(obj, TestCase)):\n            return self.loadTestsFromTestCase(obj)\n        elif (type(obj) == types.UnboundMethodType and\n              isinstance(parent, (type, types.ClassType)) and\n              issubclass(parent, TestCase)):\n            return TestSuite([parent(obj.__name__)])\n        elif isinstance(obj, TestSuite):\n            return obj\n        elif hasattr(obj, '__call__'):\n            test = obj()\n            if isinstance(test, TestSuite):\n                return test\n            elif isinstance(test, TestCase):\n                return TestSuite([test])\n            else:\n                raise TypeError(\"calling %s returned %s, not a test\" %\n                                (obj, test))\n        else:\n            raise TypeError(\"don't know how to make test from: %s\" % obj)\n\n    def loadTestsFromNames(self, names, module=None):\n        \"\"\"Return a suite of all tests cases found using the given sequence\n        of string specifiers. See 'loadTestsFromName()'.\n        \"\"\"\n        suites = [self.loadTestsFromName(name, module) for name in names]\n        return self.suiteClass(suites)\n\n    def getTestCaseNames(self, testCaseClass):\n        \"\"\"Return a sorted sequence of method names found within testCaseClass\n        \"\"\"\n        def isTestMethod(attrname, testCaseClass=testCaseClass, prefix=self.testMethodPrefix):\n            return attrname.startswith(prefix) and hasattr(getattr(testCaseClass, attrname), '__call__')\n        testFnNames = filter(isTestMethod, dir(testCaseClass))\n        if self.sortTestMethodsUsing:\n            testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))\n        return testFnNames\n\n\n\ndefaultTestLoader = TestLoader()\n\n\n##############################################################################\n# Patches for old functions: these functions should be considered obsolete\n##############################################################################\n\ndef _makeLoader(prefix, sortUsing, suiteClass=None):\n    loader = TestLoader()\n    loader.sortTestMethodsUsing = sortUsing\n    loader.testMethodPrefix = prefix\n    if suiteClass: loader.suiteClass = suiteClass\n    return loader\n\ndef getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):\n    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)\n\ndef makeSuite(testCaseClass, prefix='test', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)\n\ndef findTestCases(module, prefix='test', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)\n\n\n##############################################################################\n# Text UI\n##############################################################################\n\nclass _WritelnDecorator:\n    \"\"\"Used to decorate file-like objects with a handy 'writeln' method\"\"\"\n    def __init__(self,stream):\n        self.stream = stream\n\n    def __getattr__(self, attr):\n        return getattr(self.stream,attr)\n\n    def writeln(self, arg=None):\n        if arg: self.write(arg)\n        self.write('\\n') # text-mode streams translate to \\r\\n if needed\n\n\nclass _TextTestResult(TestResult):\n    \"\"\"A test result class that can print formatted text results to a stream.\n\n    Used by TextTestRunner.\n    \"\"\"\n    separator1 = '=' * 70\n    separator2 = '-' * 70\n\n    def __init__(self, stream, descriptions, verbosity):\n        TestResult.__init__(self)\n        self.stream = stream\n        self.showAll = verbosity > 1\n        self.dots = verbosity == 1\n        self.descriptions = descriptions\n\n    def getDescription(self, test):\n        if self.descriptions:\n            return test.shortDescription() or str(test)\n        else:\n            return str(test)\n\n    def startTest(self, test):\n        TestResult.startTest(self, test)\n        if self.showAll:\n            self.stream.write(self.getDescription(test))\n            self.stream.write(\" ... \")\n            self.stream.flush()\n\n    def addSuccess(self, test):\n        TestResult.addSuccess(self, test)\n        if self.showAll:\n            self.stream.writeln(\"ok\")\n        elif self.dots:\n            self.stream.write('.')\n            self.stream.flush()\n\n    def addError(self, test, err):\n        TestResult.addError(self, test, err)\n        if self.showAll:\n            self.stream.writeln(\"ERROR\")\n        elif self.dots:\n            self.stream.write('E')\n            self.stream.flush()\n\n    def addFailure(self, test, err):\n        TestResult.addFailure(self, test, err)\n        if self.showAll:\n            self.stream.writeln(\"FAIL\")\n        elif self.dots:\n            self.stream.write('F')\n            self.stream.flush()\n\n    def printErrors(self):\n        if self.dots or self.showAll:\n            self.stream.writeln()\n        self.printErrorList('ERROR', self.errors)\n        self.printErrorList('FAIL', self.failures)\n\n    def printErrorList(self, flavour, errors):\n        for test, err in errors:\n            self.stream.writeln(self.separator1)\n            self.stream.writeln(\"%s: %s\" % (flavour,self.getDescription(test)))\n            self.stream.writeln(self.separator2)\n            self.stream.writeln(\"%s\" % err)\n\n\nclass TextTestRunner:\n    \"\"\"A test runner class that displays results in textual form.\n\n    It prints out the names of tests as they are run, errors as they\n    occur, and a summary of the results at the end of the test run.\n    \"\"\"\n    def __init__(self, stream=sys.stderr, descriptions=1, verbosity=1):\n        self.stream = _WritelnDecorator(stream)\n        self.descriptions = descriptions\n        self.verbosity = verbosity\n\n    def _makeResult(self):\n        return _TextTestResult(self.stream, self.descriptions, self.verbosity)\n\n    def run(self, test):\n        \"Run the given test case or test suite.\"\n        result = self._makeResult()\n        startTime = time.time()\n        test(result)\n        stopTime = time.time()\n        timeTaken = stopTime - startTime\n        result.printErrors()\n        self.stream.writeln(result.separator2)\n        run = result.testsRun\n        self.stream.writeln(\"Ran %d test%s in %.3fs\" %\n                            (run, run != 1 and \"s\" or \"\", timeTaken))\n        self.stream.writeln()\n        if not result.wasSuccessful():\n            self.stream.write(\"FAILED (\")\n            failed, errored = map(len, (result.failures, result.errors))\n            if failed:\n                self.stream.write(\"failures=%d\" % failed)\n            if errored:\n                if failed: self.stream.write(\", \")\n                self.stream.write(\"errors=%d\" % errored)\n            self.stream.writeln(\")\")\n        else:\n            self.stream.writeln(\"OK\")\n        return result\n\n\n\n##############################################################################\n# Facilities for running tests from the command line\n##############################################################################\n\nclass TestProgram:\n    \"\"\"A command-line program that runs a set of tests; this is primarily\n       for making test modules conveniently executable.\n    \"\"\"\n    USAGE = \"\"\"\\\nUsage: %(progName)s [options] [test] [...]\n\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n\nExamples:\n  %(progName)s                               - run default set of tests\n  %(progName)s MyTestSuite                   - run suite 'MyTestSuite'\n  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething\n  %(progName)s MyTestCase                    - run all 'test*' test methods\n                                               in MyTestCase\n\"\"\"\n    def __init__(self, module='__main__', defaultTest=None,\n                 argv=None, testRunner=None,\n                 testLoader=defaultTestLoader):\n        if type(module) == type(''):\n            self.module = __import__(module)\n            for part in module.split('.')[1:]:\n                self.module = getattr(self.module, part)\n        else:\n            self.module = module\n        if argv is None:\n            argv = sys.argv\n        self.verbosity = 1\n        self.defaultTest = defaultTest\n        self.testRunner = testRunner\n        self.testLoader = testLoader\n        self.progName = os.path.basename(argv[0])\n        self.parseArgs(argv)\n        self.runTests()\n\n    def usageExit(self, msg=None):\n        if msg: print msg\n        print self.USAGE % self.__dict__\n        sys.exit(2)\n\n    def parseArgs(self, argv):\n        import getopt\n        try:\n            options, args = getopt.getopt(argv[1:], 'hHvq',\n                                          ['help','verbose','quiet'])\n            for opt, value in options:\n                if opt in ('-h','-H','--help'):\n                    self.usageExit()\n                if opt in ('-q','--quiet'):\n                    self.verbosity = 0\n                if opt in ('-v','--verbose'):\n                    self.verbosity = 2\n            if len(args) == 0 and self.defaultTest is None:\n                self.test = self.testLoader.loadTestsFromModule(self.module)\n                return\n            if len(args) > 0:\n                self.testNames = args\n            else:\n                self.testNames = (self.defaultTest,)\n            self.createTests()\n        except getopt.error, msg:\n            self.usageExit(msg)\n\n    def createTests(self):\n        self.test = self.testLoader.loadTestsFromNames(self.testNames,\n                                                       self.module)\n\n    def runTests(self):\n        if self.testRunner is None:\n            self.testRunner = TextTestRunner\n\n        if isinstance(self.testRunner, (type, types.ClassType)):\n            try:\n                testRunner = self.testRunner(verbosity=self.verbosity)\n            except TypeError:\n                # didn't accept the verbosity argument\n                testRunner = self.testRunner()\n        else:\n            # it is assumed to be a TestRunner instance\n            testRunner = self.testRunner\n        result = testRunner.run(self.test)\n        sys.exit(not result.wasSuccessful())\n\nmain = TestProgram\n\n\n##############################################################################\n# Executing this module from the command line\n##############################################################################\n\nif __name__ == \"__main__\":\n    main(module=None)\n", "src/lib/pythonds/graphs/__init__.py": "\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n", "src/lib/pythonds/graphs/priorityQueue.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,'x'))\n        self.theHeap.add((3,'y'))\n        self.theHeap.add((5,'z'))\n        self.theHeap.add((6,'a'))\n        self.theHeap.add((4,'d'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == 'x'\n        assert self.theHeap.delMin() == 'y'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey('d',1)\n        assert self.theHeap.delMin() == 'd'\n        \nif __name__ == '__main__':\n    unittest.main()\n", "src/lib/pythonds/__init__.py": "", "src/lib/cmath/__init__.js": "var $builtinmodule = function(name) {\n\n  function isNumber(x) {return typeof x === 'number';}\n  function isUndefined(x) {return typeof x === 'undefined';}\n\n  function phase(x, y) {\n    return Math.atan2(y, x);\n  }\n\n  function norm(x, y) {\n    return Math.sqrt(x * x + y * y);\n  }\n\n  function stringFromCoordinates(coordinates, labels, multiplier) {\n    var append, i, sb, str, _i, _ref;\n    sb = [];\n    append = function(number, label) {\n      var n;\n      if (number !== 0) {\n        if (number >= 0) {\n          if (sb.length > 0) {\n            sb.push(\"+\");\n          }\n        } else {\n          sb.push(\"-\");\n        }\n        n = Math.abs(number);\n        if (n === 1) {\n          return sb.push(label);\n        } else {\n          sb.push(n.toString());\n          if (label !== \"1\") {\n            sb.push(multiplier);\n            return sb.push(label);\n          }\n        }\n      }\n    };\n    for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n      append(coordinates[i], labels[i]);\n    }\n    if (sb.length > 0) {\n      str = sb.join(\"\");\n    } else {\n      str = \"0\";\n    }\n    return str;\n  }\n\n  // This is what you would use in code. e.g. i = complex(0.0, 1.0)\n  var COMPLEX_CONSTRUCTOR_NAME = \"complex\";\n  var PROP_REAL = \"real\";\n  var PROP_IMAG = \"imag\";\n\n  var mod = {};\n\n  mod[COMPLEX_CONSTRUCTOR_NAME] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, re, im) {\n      self.tp$name = COMPLEX_CONSTRUCTOR_NAME;\n      self.v = {\"x\": Sk.ffi.remapToJs(re), \"y\": Sk.ffi.remapToJs(im)};\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(z, name) {\n      z = Sk.ffi.remapToJs(z);\n      switch(name) {\n        case PROP_REAL: {\n          return Sk.builtin.assk$(z.x, Sk.builtin.nmber.float$);\n        }\n        case PROP_IMAG: {\n          return Sk.builtin.assk$(z.y, Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__add__ = new Sk.builtin.func(function(a, b) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        x = a.x + b;\n        y = a.y;\n      }\n      else {\n        x = a.x + b.x;\n        y = a.y + b.y;\n      }\n      return Sk.misceval.callsim(\n        mod[COMPLEX_CONSTRUCTOR_NAME],\n        Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n        Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(b, a) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        x = a + b.x;\n        y = b.y;\n        return Sk.misceval.callsim(\n          mod[COMPLEX_CONSTRUCTOR_NAME],\n          Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n          Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(aPy, b) {\n      var a = Sk.ffi.remapToJs(aPy);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        a.x += b;\n      }\n      else {\n        a.x += b.x;\n        a.y += b.y;\n      }\n      return aPy;\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(a, b) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        x = a.x - b;\n        y = a.y;\n      }\n      else {\n        x = a.x - b.x;\n        y = a.y - b.y;\n      }\n      return Sk.misceval.callsim(\n        mod[COMPLEX_CONSTRUCTOR_NAME],\n        Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n        Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(b, a) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        x = a - b.x;\n        y = -b.y;\n        return Sk.misceval.callsim(\n          mod[COMPLEX_CONSTRUCTOR_NAME],\n          Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n          Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(aPy, b) {\n      var a = Sk.ffi.remapToJs(aPy);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        a.x -= b;\n      }\n      else {\n        a.x -= b.x;\n        a.y -= b.y;\n      }\n      return aPy;\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        x = a.x * b;\n        y = a.y * b;\n      }\n      else {\n        x = a.x * b.x - a.y * b.y;\n        y = a.y * b.x + a.x * b.y;\n      }\n      return Sk.misceval.callsim(\n        mod[COMPLEX_CONSTRUCTOR_NAME],\n        Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n        Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(b, a) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        x = a * b.x;\n        y = a * b.y;\n        return Sk.misceval.callsim(\n          mod[COMPLEX_CONSTRUCTOR_NAME],\n          Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n          Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(aPy, b) {\n      var a = Sk.ffi.remapToJs(aPy);\n      var aX = a.x;\n      var aY = a.y;\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        a.x *= b;\n        a.y *= b;\n      }\n      else {\n        a.x = aX * b.x - aY * b.y;\n        a.y = aY * b.x + aX * b.y;\n      }\n      return aPy;\n    });\n    $loc.__div__ = new Sk.builtin.func(function(a, b) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        x = a.x / b;\n        y = a.y / b;\n      }\n      else {\n        var factor = b.x * b.x + b.y * b.y;\n        x = (a.x * b.x + a.y * b.y) / factor;\n        y = (a.y * b.x - a.x * b.y) / factor;\n      }\n      return Sk.misceval.callsim(\n        mod[COMPLEX_CONSTRUCTOR_NAME],\n        Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n        Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n    });\n    $loc.__rdiv__ = new Sk.builtin.func(function(b, a) {\n      var x, y;\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        var factor = b.x * b.x + b.y * b.y;\n        x = (a * b.x) / factor;\n        y = (-a * b.y) / factor;\n        return Sk.misceval.callsim(\n          mod[COMPLEX_CONSTRUCTOR_NAME],\n          Sk.builtin.assk$(x, Sk.builtin.nmber.float$),\n          Sk.builtin.assk$(y, Sk.builtin.nmber.float$));\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__idiv__ = new Sk.builtin.func(function(aPy, b) {\n      var a = Sk.ffi.remapToJs(aPy);\n      var aX = a.x;\n      var aY = a.y;\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        a.x /= b;\n        a.y /= b;\n      }\n      else {\n        var factor = b.x * b.x + b.y * b.y;\n        a.x = (aX * b.x + aY * b.y) / factor;\n        a.y = (aY * b.x - aX * b.y) / factor;\n      }\n      return aPy;\n    });\n    $loc.__str__ = new Sk.builtin.func(function(z) {\n      z = Sk.ffi.remapToJs(z);\n      if (!isUndefined(z)) {\n        return new Sk.builtin.str(\"(\" + stringFromCoordinates([z.x, z.y], [\"1\", \"j\"], \"\") + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + COMPLEX_CONSTRUCTOR_NAME + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(z) {\n      z = Sk.ffi.remapToJs(z);\n      if (!isUndefined(z)) {\n        return new Sk.builtin.str(COMPLEX_CONSTRUCTOR_NAME + '(' + z.x + ', ' + z.y + ')');\n      }\n      else {\n        return new Sk.builtin.str(\"__repr__(z)\");\n      }\n    });\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return (a.x === b.x) && (a.y === b.y);\n    });\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return (a.x !== b.x) || (a.y !== b.y);\n    });\n  }, COMPLEX_CONSTRUCTOR_NAME, []);\n\n  // Conversions to and from polar coordinates\n  mod.phase = new Sk.builtin.func(function(z) {\n    z = Sk.ffi.remapToJs(z);\n    if (isNumber(z.x) && isNumber(z.y)) {\n      // The argument is a complex number.\n      return Sk.builtin.assk$(phase(z.x, z.y), Sk.builtin.nmber.float$)\n    }\n    else if (isNumber(z)) {\n      // The argument should be considered as a real number with no imaginary part.\n      return Math.atan2(0, z);\n    }\n    else {\n      return z;\n    }\n  });\n\n  mod.polar = new Sk.builtin.func(function(z) {\n    z = Sk.ffi.remapToJs(z);\n    if (isNumber(z.x) && isNumber(z.y)) {\n      return new Sk.builtin.tuple([norm(z.x, z.y), phase(z.x, z.y)]);\n    }\n    else if (isNumber(z)) {\n      // The argument should be considered as a real number with no imaginary part.\n      return Math.atan2(0, z);\n    }\n    else {\n      // What do we do with illegal arguments?\n    }\n  });\n\n  // Constants\n  mod.pi = Sk.builtin.assk$(Math.PI, Sk.builtin.nmber.float$);\n  mod.e =  Sk.builtin.assk$(Math.E, Sk.builtin.nmber.float$);\n\n  return mod;\n};\n", "src/lib/pythonds/basic/deque.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#deque.py\r\n\r\n\r\nclass Deque:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def addFront(self, item):\r\n        self.items.append(item)\r\n\r\n    def addRear(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def removeFront(self):\r\n        return self.items.pop()\r\n\r\n    def removeRear(self):\r\n        return self.items.pop(0)\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n", "src/lib/processing/__init__.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n    var imList = [];\n    var looping = true;\n\n    // We need this to store a reference to the actual processing object which is not created\n    // until the run function is called.  Even then the processing object is passed by the\n    // processing-js sytem as a parameter to the sketchProc function.  Why not set it to None here\n    //\n\n    // See:  http://processingjs.org/reference/\n\n    mod.processing = null\n    mod.p = null\n\n    mod.CENTER = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.RADIUS = Sk.builtin.assk$(2, Sk.builtin.nmber.int$);\n    mod.CORNERS = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.CORNER = Sk.builtin.assk$(0, Sk.builtin.nmber.int$);\n    mod.RGB = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.HSB = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.CMYK = Sk.builtin.assk$(5, Sk.builtin.nmber.int$);\n    mod.MITER = new Sk.builtin.str('miter');\n    mod.BEVEL = new Sk.builtin.str('bevel');\n    mod.ROUND = new Sk.builtin.str('round');\n    mod.SQUARE = new Sk.builtin.str('butt');\n    mod.PROJECT = new Sk.builtin.str('square');\n\n// 2D - Primitives\n    mod.line = new Sk.builtin.func(function(x1, y1, x2, y2) {\n        mod.processing.line(x1.v, y1.v, x2.v, y2.v);\n    });\n    \n    mod.ellipse = new Sk.builtin.func(function(x,y,r1,r2) {\n        mod.processing.ellipse(x.v,y.v,r1.v,r2.v)\n        \n    });\n\n    mod.point = new Sk.builtin.func(function(x1,y1) {\n        mod.processing.point(x1.v,y1.v)\n    });\n        \n    mod.arc = new Sk.builtin.func(function(x, y, width, height, start, stop) {\n        mod.processing.arc(x.v, y.v, width.v, height.v, start.v, stop.v)\n    });\n\n    mod.quad = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3, x4, y4) {\n        mod.processing.quad(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v, x4.v, y4.v)\n    });\n            \n    mod.rect = new Sk.builtin.func(function(x, y, width, height, radius) {\n        if (typeof(radius) == 'undefined') {\n            var rad = 0\n        } else {\n            var rad = radius.v\n        }\n        mod.processing.rect(x.v, y.v, width.v, height.v, rad)\n    });\n    \n    mod.triangle = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3) {\n            mod.processing.triangle(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v)\n        });\n            \n\n    // 3D Primitives\n\n    // todo:  box, sphere, sphereDetail\n\n    // Color\n    mod.background = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== 'undefined')\n            g = g.v\n        if (typeof(b) !== 'undefined')\n            b = b.v\n\n        mod.processing.background(r.v,g,b)\n        \n    });\n\n    mod.fill = new Sk.builtin.func(function(r,g,b) {\n        // r will be either:\n        //      a number in which case the fill will be grayscale\n        //      a color object\n        // g, and b may be undefined.  If they hold values it will\n        // be assumed that we have an r,g,b color tuple\n        if (typeof(g) !== 'undefined')\n            g = g.v\n        if (typeof(b) !== 'undefined')\n            b = b.v\n    \n        mod.processing.fill(r.v,g,b)\n        \n    });\n\n\n    mod.stroke = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== 'undefined')\n            g = g.v\n        if (typeof(b) !== 'undefined')\n            b = b.v\n\n        mod.processing.stroke(r.v,g,b)\n        \n    });\n\n    mod.noStroke = new Sk.builtin.func(function() {\n        mod.processing.noStroke()\n    });\n    \n\n    mod.colorMode = new Sk.builtin.func(function(model, maxV) {\n        if (typeof(maxV) === 'undefined')\n            maxV = 255\n        else\n            maxV = maxV.v\n        mod.processing.colorMode(model.v, maxV)\n    });\n\n    mod.noFill = new Sk.builtin.func(function() {\n            mod.processing.noFill()\n        });\n            \n\n    // Environment\n\n    mod.loop = new Sk.builtin.func(function() {\n            if (mod.processing === null) {\n                throw new Sk.builtin.Exception(\"Loop should be called in setup\")\n            }\n            looping = true;\n            mod.processing.loop()\n        });\n            \n    mod.noLoop = new Sk.builtin.func(function() {\n        if (mod.processing === null) {\n            throw new Sk.builtin.Exception(\"noLoop should be called in setup\")\n        }\n        looping = false;\n        mod.processing.noLoop()\n    });\n    \n    mod.frameRate = new Sk.builtin.func(function(fr) {\n        mod.processing.frameRate(fr.v)\n        \n    });\n\n    mod.size = new Sk.builtin.func(function(h,w) {\n        mod.processing.size(h.v,w.v)\n        \n    });\n\n    mod.exitp = new Sk.builtin.func(function(h,w) {\n        mod.processing.exit()\n    });\n\n\n    mod.mouseX = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseX, Sk.builtin.nmber.int$);\n        \n    });\n\n    mod.mouseY = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseY, Sk.builtin.nmber.int$);\n        \n    });\n\n    // Attributes\n    mod.rectMode = new Sk.builtin.func(function(mode) {\n        mod.processing.rectMode(mode.v)\n    });\n\n    mod.strokeWeight = new Sk.builtin.func(function(wt) {\n        mod.processing.strokeWeight(wt.v)\n        \n    });\n\n    mod.smooth = new Sk.builtin.func(function() {\n        mod.processing.smooth()\n    });\n\n    mod.noSmooth = new Sk.builtin.func(function() {\n        mod.processing.noSmooth()\n        });\n            \n    mod.ellipseMode = new Sk.builtin.func(function(mode) {\n        mod.processing.ellipseMode(mode.v)\n        });\n\n    mod.strokeCap = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeCap(mode.v)\n        });\n\n    mod.strokeJoin = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeJoin(mode.v)\n    });\n    \n\n\n    // Transforms\n\n    mod.rotate = new Sk.builtin.func(function(rads) {\n        // rotation in radians\n        mod.processing.rotate(rads.v)\n        \n    });\n\n    mod.scale = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == 'undefined') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == 'undefined') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.scale(sx.v, sy, sz)\n    });\n\n    mod.translate = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == 'undefined') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == 'undefined') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.translate(sx.v, sy, sz)\n    });\n\n    // todo:  applyMatrix, popMatrix, printMatrix??, pushMatrix, resetMatrix, rotate{X,Y,Z}\n    \n\n    //  //////////////////////////////////////////////////////////////////////\n    //  Run\n    // \n    //  Create the processing context and setup of calls to setup, draw etc.\n    //\n    //\n    //  //////////////////////////////////////////////////////////////////////    \n    mod.run = new Sk.builtin.func(function() {\n        function sketchProc(processing) {\n            mod.processing = processing\n\n            // processing.setup = function() {\n            //     if Sk.globals['setup']\n            //         Sk.misceval.callsim(Sk.globals['setup'])\n            // }\n\n            \n            processing.draw = function() {\n                // if there are pending image loads then just use the natural looping calls to \n                // retry until all the images are loaded.  If noLoop was called in setup then make\n                // sure to revert to that after all the images in hand.\n                var wait = false\n                for (var i in imList) {\n                    if (imList[i].width == 0) {\n                        wait = true\n                    }\n                }\n                if (wait == true) {\n                    if (looping == true) \n                        return\n                    else {\n                        processing.loop()\n                        return\n                    }\n\n                } else {\n                    if (looping == false)\n                        processing.noLoop()\n                }\n\n                mod.frameCount = processing.frameCount  \n                if (Sk.globals['draw'])\n                    Sk.misceval.callsim(Sk.globals['draw'])\n            }\n            \n            var callBacks = ['setup', 'mouseMoved','mouseClicked', 'mouseDragged', 'mouseMoved', 'mouseOut',\n             'mouseOver', 'mousePressed', 'mouseReleased', 'keyPressed', 'keyReleased', 'keyTyped'\n             ];\n\n             for(var cb in callBacks) {\n                if (Sk.globals[callBacks[cb]]) {\n                    console.log('defining ' + callBacks[cb])                    \n                    processing[callBacks[cb]] = new Function(\"Sk.misceval.callsim(Sk.globals['\"+callBacks[cb]+\"']);\")\n                }\n            }\n        }\n        \n        var canvas = document.getElementById(Sk.canvas)\n        $(canvas).show()\n        mod.p = new Processing(canvas, sketchProc)\n\n        \n    });\n\n    var mouseClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == 'x') \n                return mod.processing.mouseX;\n            else if (key == 'y') \n                return mod.processing.mouseY;\n            else if (key == 'px')\n                return mod.processing.pmouseX;\n            else if (key == 'py')\n                return mod.processing.pmouseY;\n            else if (key == 'pressed')\n                return mod.processing.mousePressed;\n            else if (key == 'button')\n                return mod.processing.mouseButton\n        });\n\n\n    }\n\n\n    mod.Mouse = Sk.misceval.buildClass(mod, mouseClass, 'Mouse', []);\n\n    mod.mouse = Sk.misceval.callsim(mod.Mouse)\n\n    var keyboardClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == 'key') {\n                console.log(mod.processing.key)\n                return new Sk.builtin.str(mod.processing.key.toString())\n            }\n            else if (key == 'keyCode') \n                return mod.processing.keyCode\n            else if (key == 'keyPressed')\n                return new Sk.builtin.str(mod.processing.keyPressed) // todo bool\n        });\n\n\n    }\n\n    mod.Keyboard = Sk.misceval.buildClass(mod,keyboardClass,'Keyboard', [])\n\n    mod.keyboard = Sk.misceval.callsim(mod.Keyboard)\n\n\n\n    var environmentClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == 'frameCount') \n                return mod.processing.frameCount\n            else if (key == 'frameRate') \n                return mod.processing.frameRate\n            else if (key == 'height')\n                return mod.processing.height\n            else if (key == 'width')\n                return mod.processing.width\n            else if (key == 'online')\n                return mod.processing.online\n            else if (key == 'focused')\n                return mod.processing.focused\n        });\n\n\n    }\n\n    mod.Environment = Sk.misceval.buildClass(mod,environmentClass,'Environment', [])\n\n    mod.environment = Sk.misceval.callsim(mod.Environment)\n\n    var screenClass = function($gbl, $loc) {\n\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            self.pixels = null;\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == 'height')\n                return mod.processing.height\n            else if (key == 'width')\n                return mod.processing.width\n            else if (key == 'pixels')\n                if (self.pixels == null) {\n                    self.pixels = new Sk.builtin.list(mod.processing.pixels.toArray())\n                }\n                return self.pixels\n        });\n\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod,screenClass,'Screen', [])\n\n    mod.screen = Sk.misceval.callsim(mod.Screen)\n\n    mod.loadPixels = new Sk.builtin.func(function() {\n        mod.processing.loadPixels()\n        console.log(mod.processing.pixels)\n    });\n    \n\n    var colorClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self, val1, val2, val3, alpha) {\n            if (typeof(val2) !== 'undefined')\n                val2 = val2.v\n            if (typeof(val3) !== 'undefined')\n                val3 = val3.v\n            if (typeof(alpha) !== 'undefined')\n                alpha = alpha.v\n            self.v = mod.processing.color(val1.v, val2, val3, alpha)\n        })\n    \n    }\n\n    mod.color = Sk.misceval.buildClass(mod,colorClass,'color', [])\n\n    mod.red = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.red(clr.v), Sk.builtin.nmber.int$);\n    });\n    \n    mod.green = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.green(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    mod.blue = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.blue(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    // Image class and functions\n    //\n    var imageClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self,im) {\n            self.v = im\n            self.width = Sk.builtin.assk$(im.width, Sk.builtin.nmber.int$);\n            self.height = Sk.builtin.assk$(im.height, Sk.builtin.nmber.int$);\n        })\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == 'width') return self.v.width;\n            if (key == 'height') return self.v.height;\n        });\n    \n    }\n\n    mod.PImage = Sk.misceval.buildClass(mod,imageClass,'PImage', [])\n\n    mod.loadImage = new Sk.builtin.func(function(imfile) {\n        var i = mod.processing.loadImage(imfile.v);\n        imList.push(i);\n        return Sk.misceval.callsim(mod.PImage,i);\n    });\n    \n\n    mod.image = new Sk.builtin.func(function(im,x,y) {\n        if (im.v.width > 0)\n            mod.processing.image(im.v,x.v,y.v,im.v.width,im.v.height)\n    });\n\n    mod.get = new Sk.builtin.func(function(x,y) {\n        var clr = mod.processing.get(x.v,y.v)\n        return Sk.misceval.callsim(mod.color,\n            Sk.builtin.assk$(mod.processing.red(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.green(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.blue(clr), Sk.builtin.nmber.int$));\n    });\n\n    mod.set = new Sk.builtin.func(function(x, y, color) {\n        mod.processing.set(x.v, y.v, color.v)\n    });\n    \n// todo  -- add a color class for creating color objects.\n\n\n    return mod;\n}\n", "src/lib/webgl/models.js": "// most of this file is from/based on 'tdl'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var Buffer = function(array, opt_target) {\n        var target = opt_target || gl.ARRAY_BUFFER;\n        var buf = gl.createBuffer();\n        this.target = target;\n        this.buf = buf;\n        this.set(array);\n        this.numComponents_ = array.numComponents;\n        this.numElements_ = array.numElements;\n        this.totalComponents_ = this.numComponents_ * this.numElements_;\n        if (array.buffer instanceof Float32Array) {\n            this.type_ = gl.FLOAT;\n        } else if (array.buffer instanceof Uint8Array) {\n            this.type_ = gl.UNSIGNED_BYTE;\n        } else if (array.buffer instanceof Int8Array) {\n            this.type_ = gl._BYTE;\n        } else if (array.buffer instanceof Uint16Array) {\n            this.type_ = gl.UNSIGNED_SHORT;\n        } else if (array.buffer instanceof Int16Array) {\n            this.type_ = gl.SHORT;\n        } else {\n            throw(\"unhandled type:\" + (typeof array.buffer));\n        }\n    };\n\n    Buffer.prototype.set = function(array) {\n        gl.bindBuffer(this.target, this.buf);\n        gl.bufferData(this.target, array.buffer, gl.STATIC_DRAW);\n    }\n\n    Buffer.prototype.type = function() {\n        return this.type_;\n    };\n\n    Buffer.prototype.numComponents = function() {\n        return this.numComponents_;\n    };\n\n    Buffer.prototype.numElements = function() {\n        return this.numElements_;\n    };\n\n    Buffer.prototype.totalComponents = function() {\n        return this.totalComponents_;\n    };\n\n    Buffer.prototype.buffer = function() {\n        return this.buf;\n    };\n\n    Buffer.prototype.stride = function() {\n        return 0;\n    };\n\n    Buffer.prototype.offset = function() {\n        return 0;\n    };\n\n\n\n    mod.Model = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, shader, arrays, textures)\n                    {\n                        self.buffers = {};\n                        var setBuffer = function(name, array)\n                        {\n                            var target = (name == 'indices') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n                            b = self.buffers[name];\n                            if (!b)\n                                b = new Buffer(array, target);\n                            else\n                                b.set(array);\n                            self.buffers[name] = b;\n                        };\n                        for (name in arrays)\n                            setBuffer(name, arrays[name]);\n\n                        var textureUnits = {};\n                        var unit = 0;\n                        for (var texture in textures)\n                        {\n                            textureUnits[texture] = unit++;\n                        }\n\n                        self.mode = gl.TRIANGLES;\n                        self.textures = textures.v;\n                        self.textureUnits = textureUnits;\n                        self.shader = shader;\n                    });\n\n                /**\n                * Sets up the shared parts of drawing this model. Uses the\n                * program, binds the buffers, sets the textures.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.drawPrep = new Sk.builtin.func(function(self, uniforms)\n                    {\n                        var shader = self.shader;\n                        var buffers = self.buffers;\n                        var textures = self.textures;\n\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n\n                        Sk.misceval.callsim(shader.use, shader);\n\n                        for (var buffer in buffers) {\n                            var b = buffers[buffer];\n                            if (buffer == 'indices') {\n                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.buffer());\n                            } else {\n                                var attrib = shader.attrib[buffer];\n                                if (attrib) {\n                                    attrib(b);\n                                }\n                            }\n                        }\n\n                        for (var texture in textures) {\n                            var unit = self.textureUnits[texture];\n                            shader.setUniform$impl(shader, textuer, unit);\n                            textures[texture].bindToUnit(unit);\n                        }\n\n                        for (var uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n                    });\n\n                /**\n                * Draws this model.\n                *\n                * After calling tdl.models.Model.drawPrep you can call this\n                * function multiple times to draw this model.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.draw = new Sk.builtin.func(function(self, uniforms, opt_textures)\n                    {\n                        var shader = self.shader;\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n                        for (uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n\n                        if (opt_textures) {\n                            for (var texture in opt_textures) {\n                                var unit = self.textureUnits[texture];\n                                shader.setUniform$impl(shader, texture, unit);\n                                opt_textures[texture].bindToUnit(unit);\n                            }\n                        }\n\n                        var buffers = self.buffers;\n                        gl.drawElements(self.mode, buffers.indices.totalComponents(), gl.UNSIGNED_SHORT, 0);\n                    });\n            },\n            'Model', []);\n\n    return mod;\n};\n", "src/lib/pythonds/trees/__init__.py": "\n# from .binaryTree import BinaryTree\n# from .balance import AVLTree\n# from .bst import BinarySearchTree\n# from .binheap import BinHeap\n\n\n", "src/lib/pythonds/trees/binaryTree.py": "# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    \"\"\"\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    \"\"\"    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print('(')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(')')\n\n    def postordereval(self):\n        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print('(')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(')') \n\ndef printexp(tree):\n    sVal = \"\"\n    if tree:\n        sVal = '(' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + ')'\n    return sVal\n\ndef postordereval(tree):\n    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree('*')\n# x.insertLeft('+')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n", "src/lib/math/__init__.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n    mod.pi = Sk.builtin.assk$(Math.PI, Sk.builtin.nmber.float$);\n    mod.e =  Sk.builtin.assk$(Math.E, Sk.builtin.nmber.float$);\n\n//\tRNL\tadded\n    mod.fabs = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"fabs\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.abs(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.asin = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"asin\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.asin(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.acos = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"acos\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.acos(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.atan = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"atan\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.atan(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.atan2 = new Sk.builtin.func(function(y, x) {\n        Sk.builtin.pyCheckArgs(\"atan2\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.atan2(Sk.builtin.asnum$(y), Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.sin = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"sin\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.sin(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.cos = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"cos\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.cos(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.tan = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"tan\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\treturn new Sk.builtin.nmber(Math.tan(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);\n    });\n\n    mod.asinh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"asinh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar L = x + Math.sqrt(x*x+1);\n\n\treturn new Sk.builtin.nmber(Math.log(L), Sk.builtin.nmber.float$);\n    });\n\n    mod.acosh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"acosh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar L = x + Math.sqrt(x*x-1);\n\n\treturn new Sk.builtin.nmber(Math.log(L), Sk.builtin.nmber.float$);\n    });\n\n    mod.atanh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"atanh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar L = (1+x)/(1-x);\n\n\treturn new Sk.builtin.nmber(Math.log(L)/2, Sk.builtin.nmber.float$);\n    });\n\n    mod.sinh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"sinh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar e = Math.E;\n\tvar p = Math.pow(e, x);\n\tvar n = 1/p;\n\tvar result = (p-n)/2;\n\n\treturn new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);\n    });\n\n    mod.cosh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"cosh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar e = Math.E;\n\tvar p = Math.pow(e, x);\n\tvar n = 1/p;\n\tvar result = (p+n)/2;\n\n\treturn new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);\n    });\n\n    mod.tanh = new Sk.builtin.func(function(x) {\n\tSk.builtin.pyCheckArgs(\"tanh\", arguments, 1, 1);\n\tSk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\tx = Sk.builtin.asnum$(x);\n\n\tvar e = Math.E;\n\tvar p = Math.pow(e, x);\n\tvar n = 1/p;\n\tvar result = ((p-n)/2)/((p+n)/2);\n\n\treturn new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);\n    });\n\n    mod.ceil = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"ceil\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.ceil(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.floor = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"floor\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.floor(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.sqrt = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"sqrt\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.sqrt(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.trunc = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"trunc\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        return new Sk.builtin.nmber(Sk.builtin.asnum$(x)|0, Sk.builtin.nmber.float$);\n    });\n\n    mod.log = new Sk.builtin.func(function(x, base) {\n        Sk.builtin.pyCheckArgs(\"log\", arguments, 1, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        if (base === undefined) {\n\t    return new Sk.builtin.nmber(Math.log(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n        } else {\n            Sk.builtin.pyCheckType(\"base\", \"number\", Sk.builtin.checkNumber(base));\n            var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(Sk.builtin.asnum$(base));\n\t    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n        }\n    });\n\n    mod.log10 = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"log10\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n        var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(10);\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n    });\n\n    mod.exp = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"exp\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\treturn new Sk.builtin.nmber(Math.exp(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);\n    });\n\n    mod.pow = new Sk.builtin.func(function(x,y) {\n        Sk.builtin.pyCheckArgs(\"pow\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n        Sk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n\n\treturn new Sk.builtin.nmber(Math.pow(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y)), Sk.builtin.nmber.float$);\n    });\n\n    mod.radians = new Sk.builtin.func(function(deg) {\n        Sk.builtin.pyCheckArgs(\"radians\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"deg\", \"number\", Sk.builtin.checkNumber(deg));\n\n\tvar ret = Math.PI / 180.0 * Sk.builtin.asnum$(deg);\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n    });\n\n    mod.degrees = new Sk.builtin.func(function(rad) {\n        Sk.builtin.pyCheckArgs(\"degrees\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"rad\", \"number\", Sk.builtin.checkNumber(rad));\n\n\tvar ret = 180.0 / Math.PI * Sk.builtin.asnum$(rad);\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);\n    });\n\n    mod.hypot = new Sk.builtin.func(function(x, y) {\n\tSk.builtin.pyCheckArgs(\"hypot\", arguments, 2, 2);\n        Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\tSk.builtin.pyCheckType(\"y\", \"number\", Sk.builtin.checkNumber(y));\n\n\t\tx = Sk.builtin.asnum$(x);\n\t\ty = Sk.builtin.asnum$(y);\n\treturn new Sk.builtin.nmber(Math.sqrt((x*x)+(y*y)), Sk.builtin.nmber.float$);\n    });\n\n\tmod.factorial = new Sk.builtin.func(function(x) {\n\t    Sk.builtin.pyCheckArgs(\"factorial\", arguments, 1, 1);\n            Sk.builtin.pyCheckType(\"x\", \"number\", Sk.builtin.checkNumber(x));\n\n\t\tx = Math.floor(Sk.builtin.asnum$(x));\n\t\tvar r = 1;\n\t\tfor (var i = 2; i <= x; i++)\n\t\t\tr *= i;\n\t\treturn new Sk.builtin.nmber(r, Sk.builtin.nmber.int$);\n\t});\n\n    return mod;\n}", "src/lib/e3ga/__init__.js": "/**\n * e3ga is a foreign function interface over Three.js for the DaVinci Python to JavaScript cross-compiler.\n *\n * The e3ga module is in most respects API-compatible with the Three.js library except that THREE.Vector3 has\n * been extended in the ffi to Euclidean3.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n  \n  var EUCLIDEAN_3           = \"Euclidean3\";\n  var SCALAR_3              = \"Scalar3\";\n  var VECTOR_3              = \"Vector3\";\n  var BIVECTOR_3            = \"Bivector3\";\n  var PSEUDOSCALAR_3        = \"Pseudoscalar3\";\n\n  var QUATERNION            = \"Quaternion\";\n\n  var SCENE                 = \"Scene\";\n  var CANVAS_RENDERER       = \"CanvasRenderer\";\n  var WEBGL_RENDERER        = \"WebGLRenderer\";\n  var COLOR                 = \"Color\";\n  var ORTHOGRAPHIC_CAMERA   = \"OrthographicCamera\";\n  var PERSPECTIVE_CAMERA    = \"PerspectiveCamera\";\n\n  var GEOMETRY              = \"Geometry\";\n  var OBJECT_3D             = \"Object3D\";\n\n  var AMBIENT_LIGHT         = \"AmbientLight\";\n  var DIRECTIONAL_LIGHT     = \"DirectionalLight\";\n  var POINT_LIGHT           = \"PointLight\";\n\n  var LINE                  = \"Line\";\n  var LINE_BASIC_MATERIAL   = \"LineBasicMaterial\";\n\n  var MESH                  = \"Mesh\";\n  var MESH_BASIC_MATERIAL   = \"MeshBasicMaterial\";\n  var MESH_LAMBERT_MATERIAL = \"MeshLambertMaterial\";\n  var MESH_NORMAL_MATERIAL  = \"MeshNormalMaterial\";\n  var MESH_PHONG_MATERIAL   = \"MeshPhongMaterial\";\n\n  var ARROW_GEOMETRY        = \"ArrowGeometry\";\n  var CIRCLE_GEOMETRY       = \"CircleGeometry\";\n  var CUBE_GEOMETRY         = \"CubeGeometry\";\n  var CYLINDER_GEOMETRY     = \"CylinderGeometry\";\n  var ICOSAHEDRON_GEOMETRY  = \"IcosahedronGeometry\";\n  var LATHE_GEOMETRY        = \"LatheGeometry\";\n  var OCTAHEDRON_GEOMETRY   = \"OctahedronGeometry\";\n  var PLANE_GEOMETRY        = \"PlaneGeometry\";\n  var SPHERE_GEOMETRY       = \"SphereGeometry\";\n  var TEXT_GEOMETRY         = \"TextGeometry\";\n  var TETRAHEDRON_GEOMETRY  = \"TetrahedronGeometry\";\n  var TORUS_GEOMETRY        = \"TorusGeometry\";\n\n  var PROP_BOTTOM              = \"bottom\";\n  var PROP_COLOR               = \"color\";\n  var PROP_DETAIL              = \"detail\";\n  var PROP_EULER_ORDER         = \"eulerOrder\";\n  var PROP_FAR                 = \"far\";\n  var PROP_GEOMETRY            = \"geometry\";\n  var PROP_ID                  = \"id\";\n  var PROP_LEFT                = \"left\";\n  var PROP_MASS                = \"mass\";\n  var PROP_MATERIAL            = \"material\";\n  var PROP_MATRIX_AUTO_UPDATE  = \"matrixAutoUpdate\";\n  var PROP_NAME                = \"name\";\n  var PROP_NEAR                = \"near\";\n  var PROP_NEEDS_UPDATE        = \"needsUpdate\";\n  var PROP_OPACITY             = \"opacity\";\n  var PROP_OVERDRAW            = \"overdraw\";\n  var PROP_POSITION            = \"position\";\n  var PROP_QUATERNION          = \"quaternion\";\n  var PROP_RADIUS              = \"radius\";\n  var PROP_RIGHT               = \"right\";\n  var PROP_ROTATION            = \"rotation\";\n  var PROP_SCALE               = \"scale\";\n  var PROP_SEGMENTS            = \"segments\";\n  var PROP_THETA_START         = \"thetaStart\";\n  var PROP_THETA_LENGTH        = \"thetaLength\";\n  var PROP_TOP                 = \"top\";\n  var PROP_TRANSPARENT         = \"transparent\";\n  var PROP_TYPE                = \"type\";\n  var PROP_UP                  = \"up\";\n  var PROP_USE_QUATERNION      = \"useQuaternion\";\n  var PROP_VELOCITY            = \"velocity\";\n  var PROP_VERTICES            = \"vertices\";\n  var PROP_VISIBLE             = \"visible\";\n  var PROP_WIREFRAME           = \"wireframe\";\n  var PROP_WIREFRAME_LINEWIDTH = \"wireframeLinewidth\";\n\n  var PROP_W                     = \"w\";\n  var PROP_X                     = \"x\";\n  var PROP_Y                     = \"y\";\n  var PROP_Z                     = \"z\";\n  var PROP_XY                    = \"xy\";\n  var PROP_YZ                    = \"yz\";\n  var PROP_ZX                    = \"zx\";\n  var PROP_XYZ                   = \"xyz\";\n  var METHOD_SET_X               = \"setX\";\n  var METHOD_SET_Y               = \"setY\";\n  var METHOD_SET_Z               = \"setZ\";\n  var METHOD_GET_COMPONENT       = \"getComponent\";\n  var METHOD_SET_COMPONENT       = \"setComponent\";\n  var METHOD_SET                 = \"set\";\n  var METHOD_SET_FROM_AXIS_ANGLE = \"setFromAxisAngle\";\n  var METHOD_SET_FROM_EULER      = \"setFromEuler\";\n  var METHOD_SET_GEOMETRY        = \"setGeometry\";\n  var METHOD_UPDATE_MATRIX       = \"updateMatrix\";\n\n  var METHOD_ADD               = \"add\";\n  var METHOD_CLONE             = \"clone\";\n  var METHOD_CONJUGATE         = \"conjugate\";\n  var METHOD_COPY              = \"copy\";\n  var METHOD_CROSS             = \"cross\";\n  var METHOD_DOT               = \"dot\";\n  var METHOD_INVERSE           = \"inverse\";\n  var METHOD_LENGTH            = \"length\";\n  var METHOD_LENGTH_SQ         = \"lengthSq\";\n  var METHOD_LOOK_AT           = \"lookAt\";\n  var METHOD_NORMALIZE         = \"normalize\";\n  var METHOD_REMOVE            = \"remove\";\n  var METHOD_SET_RGB           = \"setRGB\";\n\n  var mod = {};\n\n  function isBoolean(x)   { return typeof x === 'boolean'; }\n  function isFunction(x)  { return typeof x === 'function'; }\n  function isNumber(x)    { return typeof x === 'number'; }\n  function isObject(x)    { return typeof x === 'object'; }\n  function isString(x)    { return typeof x === 'string'; }\n  function isUndefined(x) { return typeof x === 'undefined'; }\n\n  function isDefined(x)   { return typeof x !== 'undefined'; }\n  function isNull(x)      { return typeof x === 'object' && x === null; }\n\n  function methodAdd(target) {\n    if (!isObject(target)) {\n      throw new Sk.builtin.AssertionError(\"target must be an object.\");\n    }\n    if (!isFunction(target[METHOD_ADD])) {\n      throw new Sk.builtin.AssertionError(\"target must have an 'add' function.\");\n    }\n    return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n      $loc.__init__ = new Sk.builtin.func(function(self) {\n        self.tp$name = METHOD_ADD;\n      });\n      $loc.__call__ = new Sk.builtin.func(function(self, childPy) {\n        var child = Sk.ffi.remapToJs(childPy);\n        target[METHOD_ADD](child);\n      });\n      $loc.__str__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_ADD)\n      })\n      $loc.__repr__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_ADD)\n      })\n    }, METHOD_ADD, []));\n  }\n\n  function methodRemove(target) {\n    if (!isObject(target)) {\n      throw new Sk.builtin.AssertionError(\"target must be an object.\");\n    }\n    if (!isFunction(target[METHOD_REMOVE])) {\n      throw new Sk.builtin.AssertionError(\"target must have a 'remove' function.\");\n    }\n    return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n      $loc.__init__ = new Sk.builtin.func(function(self) {\n        self.tp$name = METHOD_REMOVE;\n      });\n      $loc.__call__ = new Sk.builtin.func(function(self, childPy) {\n        var child = Sk.ffi.remapToJs(childPy);\n        target[METHOD_REMOVE](child);\n      });\n      $loc.__str__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_REMOVE)\n      })\n      $loc.__repr__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_REMOVE)\n      })\n    }, METHOD_REMOVE, []));\n  }\n\n  function verticesPy(vertices) {\n    return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n      $loc.__init__ = new Sk.builtin.func(function(self) {\n        self.tp$name = PROP_VERTICES;\n        self.v = vertices;\n      });\n      $loc.__getattr__ = new Sk.builtin.func(function(verticesPy, name) {\n        var METHOD_APPEND = \"append\";\n        switch(name) {\n          case METHOD_APPEND: {\n            return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n              $loc.__init__ = new Sk.builtin.func(function(self) {\n                self.tp$name = METHOD_APPEND;\n              });\n              $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n                vertices.push(Sk.ffi.remapToJs(vectorPy));\n              });\n              $loc.__str__ = new Sk.builtin.func(function(self) {\n                return new Sk.builtin.str(METHOD_APPEND)\n              });\n              $loc.__repr__ = new Sk.builtin.func(function(self) {\n                return new Sk.builtin.str(METHOD_APPEND)\n              });\n            }, METHOD_APPEND, []));\n          }\n        }\n      });\n      $loc.__getitem__ = new Sk.builtin.func(function(verticesPy, indexPy) {\n        var index = Sk.ffi.remapToJs(indexPy);\n        return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(vertices[index], EUCLIDEAN_3));\n      });\n      $loc.mp$length = function() {return vertices.length;};\n      $loc.__str__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(PROP_VERTICES)\n      });\n      $loc.__repr__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(PROP_VERTICES)\n      });\n    }, PROP_VERTICES, []));\n  }\n\n  /*\n   * Deterines whether the argument is a genuine Color reference.\n   */\n  function isColor(x) {\n    if (isDefined(x)) {\n      if (x.hasOwnProperty(\"r\") && x.hasOwnProperty(\"g\") && x.hasOwnProperty(\"b\")) {\n        return isNumber(x[\"r\"]) && isNumber(x[\"g\"]) && isNumber(x[\"b\"]);\n      }\n      else {\n        return false;\n      }\n    }\n    else {\n      return false;\n    }\n  }\n\n  function webGLSupported() {\n    try {\n      if (window.WebGLRenderingContext) {\n        if (document.createElement('canvas').getContext('experimental-webgl')) {\n          return true;\n        }\n        else {\n          return false;\n        }\n      }\n      else {\n        return false;\n      }\n    }\n    catch(e) {\n      return false;\n    }\n  }\n\n  function numberFromArg(arg, argName, functionName, lax) {\n    if (isUndefined(argName)) {\n      throw new Error(\"argName must be specified\")\n    }\n    if (isUndefined(functionName)) {\n      throw new Error(\"functionName must be specified\")\n    }\n    lax = isUndefined(lax) ? true : (isBoolean(lax) ? lax : true);\n    if (isUndefined(arg)) {\n      if (lax) {\n        return arg;\n      }\n      else {\n        throw new Sk.builtin.TypeError(functionName + \".\" + argName + \" must be convertible to a number, but was Missing.\");\n      }\n    }\n    else if (isNull(arg)) {\n      if (lax) {\n        return arg;\n      }\n      else {\n        throw new Sk.builtin.TypeError(functionName + \".\" + argName + \" must be convertible to a number, but was None.\");\n      }\n    }\n    if (isBoolean(arg)) {\n      throw new Sk.builtin.TypeError(functionName + \".\" + argName + \" must be convertible to a number, but was a Boolean.\");\n    }\n\n    if (arg.skType) {\n      switch(arg.skType) {\n        case 'float': {\n          return arg.v;\n        }\n        case 'int': {\n          return arg.v;\n        }\n        default: {\n          throw new Sk.builtin.TypeError(functionName + \"(\" + argName + \": \" + arg.skType + \") must be convertible to a number.\");\n        }\n      }\n    }\n    else if (arg.v) {\n      if (isString(arg.v)) {\n        throw new Sk.builtin.TypeError(functionName + \".\" + argName + \" must be convertible to a number, but was a String.\");\n      }\n      else {\n        throw new Sk.builtin.AssertionError(functionName + \".\" + argName + \" is unknown.\");\n      }\n    }\n    else {\n      throw new Sk.builtin.AssertionError(functionName + \".\" + argName + \" is unknown.\");\n    }\n  }\n\n  function numberFromIntegerArg(arg, argName, functionName) {\n    // TODO: Maybe need an argument to say whether undefined is acceptable?\n    // TODO: Likewise for whether null is acceptable.\n    if (isUndefined(arg)) {\n      return arg;\n    }\n    else if (isNull(arg)) {\n      return null;\n    }\n    else {\n      if (arg.skType) {\n        switch(arg.skType) {\n          case 'float': {\n            // TODO: Handle coercion to nearest integer.\n            return arg.v;\n          }\n          case 'int': {\n            return arg.v;\n          }\n        }\n      }\n      throw new Sk.builtin.AssertionError(functionName + \".\" + argName + \" must be an integer.\");\n    }\n  }\n\n  function remapE3ToPy(w, x, y, z, xy, yz, zx, xyz) {\n    w = Sk.builtin.assk$(w, Sk.builtin.nmber.float$);\n    x = Sk.builtin.assk$(x, Sk.builtin.nmber.float$);\n    y = Sk.builtin.assk$(y, Sk.builtin.nmber.float$);\n    z = Sk.builtin.assk$(z, Sk.builtin.nmber.float$);\n    xy = Sk.builtin.assk$(xy, Sk.builtin.nmber.float$);\n    yz = Sk.builtin.assk$(yz, Sk.builtin.nmber.float$);\n    zx = Sk.builtin.assk$(zx, Sk.builtin.nmber.float$);\n    xyz = Sk.builtin.assk$(xyz, Sk.builtin.nmber.float$);\n    return Sk.misceval.callsim(mod[EUCLIDEAN_3], w, x, y, z, xy, yz, zx, xyz);\n  }\n\n  function wxyzToPy(w, x, y, z) {\n    var wPy = Sk.builtin.assk$(w, Sk.builtin.nmber.float$);\n    var xPy = Sk.builtin.assk$(x, Sk.builtin.nmber.float$);\n    var yPy = Sk.builtin.assk$(y, Sk.builtin.nmber.float$);\n    var zPy = Sk.builtin.assk$(z, Sk.builtin.nmber.float$);\n    return Sk.misceval.callsim(mod[QUATERNION], xPy, yPy, zPy, wPy);\n  }\n\n  function divide(a000, a001, a010, a011, a100, a101, a110, a111, b000, b001, b010, b011, b100, b101, b110, b111, dst) {\n    // WARNING! bladeASM.mulE2 uses w,x,y,z,xy,yz,zx,xyz representation. Notice the ordering and sign change.\n    // TODO: Move everything to the more systematic bitmap representation.\n    // r = ~b = reverse(b)\n    var r000 = +b000; // w,   grade 0(+)\n    var r001 = +b001; // x,   grade 1(+)\n    var r010 = +b010; // y,   grade 1(+)\n    var r011 = -b011; // xy,  grade 2(-)\n    var r100 = +b100; // z,   grade 1(+)\n    var r101 = -b101; // yz,  grade 2(-)\n    var r110 = -b110; // yz,  grade 2(-)\n    var r111 = -b111; // xyz, grade 3(-)\n    // m = b * r = b * (~b)\n    // The grade 2 and grade 3 components evaluate to zero.\n    var m000 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 0);\n    var m001 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 1);\n    var m010 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 2);\n    var m011 =  0;//bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 4);\n    var m100 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 3);\n    var m101 =  0;//-bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 6);\n    var m110 =  0;//bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 5);\n    var m111 =  0;//bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 7);\n    // c = cliffordConjugate(m)\n    var c000 = +m000; // w,   grade 0(+)\n    var c001 = -m001; // x,   grade 1(-)\n    var c010 = -m010; // y,   grade 1(-)\n    var c011 = -m011; // xy,  grade 2(-)\n    var c100 = -m100; // z,   grade 1(-)\n    var c101 = -m101; // -zx, grade 2(-)\n    var c110 = -m110; // yz,  grade 2(-)\n    var c111 = +m111; // xyz, grade 3(+)\n    // s = r * c\n    // TODO: Presumably there is some simplified computation on account of the c's being sparse.\n    var s000 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 0);\n    var s001 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 1);\n    var s010 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 2);\n    var s011 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 4);\n    var s100 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 3);\n    var s101 = -bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 6);\n    var s110 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 5);\n    var s111 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 7);\n    // k = b * s\n    var k000 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, s000, s001, s010, s100, s011, s110, -s101, s111, 0);\n    // i = inverse(b)\n    var i000 = s000/k000;\n    var i001 = s001/k000;\n    var i010 = s010/k000;\n    var i011 = s011/k000;\n    var i100 = s100/k000;\n    var i101 = s101/k000;\n    var i110 = s110/k000;\n    var i111 = s111/k000;\n    // x = a * inverse(b)\n    var x000 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 0);\n    var x001 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 1);\n    var x010 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 2);\n    var x011 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 4);\n    var x100 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 3);\n    var x101 = -bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 6);\n    var x110 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 5);\n    var x111 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 7);\n    // translate bitmap representation to Cartesian.\n    var w   =  x000;\n    var x   =  x001;\n    var y   =  x010;\n    var z   =  x100;\n    var xy  =  x011;\n    var yz  =  x110;\n    var zx  = -x101;\n    var xyz =  x111;\n    // return or populate the optional dst parameter.\n    if (typeof dst !== 'undefined') {\n      dst.w   = w;\n      dst.x   = x;\n      dst.y   = y;\n      dst.z   = z;\n      dst.xy  = xy;\n      dst.yz  = yz;\n      dst.zx  = zx;\n      dst.xyz = xyz;\n    }\n    else {\n      return remapE3ToPy(w, x, y, z, xy, yz, zx, xyz);\n    }\n  }\n\n  function multiVector3(w, vector, xy, yz, zx, xyz) {\n    vector.w = w;\n    vector.xy = xy;\n    vector.yz = yz;\n    vector.zx = zx;\n    vector.xyz = xyz;\n    return vector;\n  }\n\n  function coord(mv, index) {\n    switch(index) {\n      case 0: {\n        return mv.w;\n      }\n      case 1: {\n        return mv.x;\n      }\n      case 2: {\n        return mv.y;\n      }\n      case 3: {\n        return mv.z;\n      }\n      case 4: {\n        return mv.xy;\n      }\n      case 5: {\n        return mv.yz;\n      }\n      case 6: {\n        return mv.zx;\n      }\n      case 7: {\n        return mv.xyz;\n      }\n      default: {\n        throw new Sk.builtin.AssertionError(\"\" + index + \" is not a valid multivector coordinate index\");\n      }\n    }\n  }\n  \n  function compute(f, a, b, coord, pack) {\n    var a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, x0, x1, x2, x3, x4, x5, x6, x7;\n    a0 = a.w;\n    a1 = a.x;\n    a2 = a.y;\n    a3 = a.z;\n    a4 = a.xy;\n    a5 = a.yz;\n    a6 = a.zx;\n    a7 = a.xyz;\n    b0 = b.w;\n    b1 = b.x;\n    b2 = b.y;\n    b3 = b.z;\n    b4 = b.xy;\n    b5 = b.yz;\n    b6 = b.zx;\n    b7 = b.xyz;\n    x0 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n    x1 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n    x2 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n    x3 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n    x4 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n    x5 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n    x6 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n    x7 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n    return pack(x0, x1, x2, x3, x4, x5, x6, x7);\n  }\n\n  mod[EUCLIDEAN_3] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, w, x, y, z, xy, yz, zx, xyz) {\n      w = Sk.ffi.remapToJs(w);\n      x = Sk.ffi.remapToJs(x);\n      y = Sk.ffi.remapToJs(y);\n      z = Sk.ffi.remapToJs(z);\n      xy = Sk.ffi.remapToJs(xy);\n      yz = Sk.ffi.remapToJs(yz);\n      zx = Sk.ffi.remapToJs(zx);\n      xyz = Sk.ffi.remapToJs(xyz);\n      if (isNumber(w) && isNumber(x) && isNumber(y) && isNumber(z) && isNumber(xy) && isNumber(yz) && isNumber(zx) && isNumber(xyz)) {\n        self.v = multiVector3(w, new THREE.Vector3(x, y, z), xy, yz, zx, xyz);\n      }\n      else if (isDefined(w) && isUndefined(x) && isUndefined(y) && isUndefined(z) && isUndefined(xy) && isUndefined(yz) && isUndefined(zx) && isUndefined(xyz)) {\n        self.v = multiVector3(w.w || 0, w, w.xy || 0, w.yz || 0, w.zx|| 0, w.xyz || 0);\n      }\n      else if (isDefined(w) && isUndefined(x) && isUndefined(y) && isUndefined(z) && isDefined(xy) && isDefined(yz) && isDefined(zx) && isDefined(xyz)) {\n        self.v = multiVector3(w, new THREE.Vector3(0, 0, 0), xy, yz, zx, xyz);\n      }\n      else if (isUndefined(w) && isUndefined(x) && isUndefined(y) && isUndefined(z) && isUndefined(xy) && isUndefined(yz) && isUndefined(zx) && isUndefined(xyz)) {\n        self.v = multiVector3(0, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(EUCLIDEAN_3);\n      }\n      self.tp$name = EUCLIDEAN_3;\n    });\n    $loc.__add__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w + b, a.x, a.y, a.z, a.xy, a.yz, a.zx, a.xyz);\n      }\n      else {\n        var w = a.w + b.w;\n        var x = a.x + b.x;\n        var y = a.y + b.y;\n        var z = a.z + b.z;\n        var xy = a.xy + b.xy;\n        var yz = a.yz + b.yz;\n        var zx = a.zx + b.zx;\n        var xyz = a.xyz + b.xyz;\n        return remapE3ToPy(w, x, y, z, xy, yz, zx, xyz);\n      }\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a + b.w, b.x, b.y, b.z, b.xy, b.yz, b.zx, b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w += other;\n      }\n      else {\n        self.w += other.w;\n        self.x += other.x;\n        self.y += other.y;\n        self.z += other.z;\n        self.xy += other.xy;\n        self.yz += other.yz;\n        self.zx += other.zx;\n        self.xyz += other.xyz;\n      }\n      return selfPy;\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w - b, a.x, a.y, a.z, a.xy, a.yz, a.zx, a.xyz);\n      }\n      else {\n        var w = a.w - b.w;\n        var x = a.x - b.x;\n        var y = a.y - b.y;\n        var z = a.z - b.z;\n        var xy = a.xy - b.xy;\n        var yz = a.yz - b.yz;\n        var zx = a.zx - b.zx;\n        var xyz = a.xyz - b.xyz;\n        return remapE3ToPy(w, x, y, z, xy, yz, zx, xyz);\n      }\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a - b.w, -b.x, -b.y, -b.z, -b.xy, -b.yz, -b.zx, -b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w -= other;\n      }\n      else {\n        self.w -= other.w;\n        self.x -= other.x;\n        self.y -= other.y;\n        self.z -= other.z;\n        self.xy -= other.xy;\n        self.yz -= other.yz;\n        self.zx -= other.zx;\n        self.xyz -= other.xyz;\n      }\n      return selfPy;\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);\n      }\n      else {\n        return compute(bladeASM.mulE3, a, b, coord, remapE3ToPy);\n      }\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var a4 = a.xy;\n      var a5 = a.yz;\n      var a6 = a.zx;\n      var a7 = a.xyz;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        b0 = b;\n        b1 = 0;\n        b2 = 0;\n        b3 = 0;\n        b4 = 0;\n        b5 = 0;\n        b6 = 0;\n        b7 = 0;\n      }\n      else {\n        b0 = b.w;\n        b1 = b.x;\n        b2 = b.y;\n        b3 = b.z;\n        b4 = b.xy;\n        b5 = b.yz;\n        b6 = b.zx;\n        b7 = b.xyz;\n      }\n      a.w   = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n      a.x   = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n      a.y   = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n      a.z   = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n      a.xy  = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n      a.yz  = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n      a.zx  = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n      a.xyz = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n      return selfPy;\n    });\n    $loc.__div__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b, 0, 0, 0, 0, 0, 0, 0);\n      }\n      else {\n        return divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz);\n      }\n    });\n    $loc.__rdiv__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return divide(lhs, 0, 0, 0, 0, 0, 0, 0, rhs.w, rhs.x, rhs.y, rhs.xy, rhs.z, -rhs.zx, rhs.yz, rhs.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" / \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__idiv__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(b)) {\n        divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b, 0, 0, 0, 0, 0, 0, 0, a);\n        return selfPy;\n      }\n      else {\n        divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz, a);\n        return selfPy;\n      }\n    });\n    $loc.__xor__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);\n      }\n      else {\n        return compute(bladeASM.extE3, a, b, coord, remapE3ToPy);\n      }\n    });\n    $loc.__rxor__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__ixor__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var a4 = a.xy;\n      var a5 = a.yz;\n      var a6 = a.zx;\n      var a7 = a.xyz;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        b0 = b;\n        b1 = 0;\n        b2 = 0;\n        b3 = 0;\n        b4 = 0;\n        b5 = 0;\n        b6 = 0;\n        b7 = 0;\n      }\n      else {\n        b0 = b.w;\n        b1 = b.x;\n        b2 = b.y;\n        b3 = b.z;\n        b4 = b.xy;\n        b5 = b.yz;\n        b6 = b.zx;\n        b7 = b.xyz;\n      }\n      a.w   = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n      a.x   = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n      a.y   = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n      a.z   = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n      a.xy  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n      a.yz  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n      a.zx  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n      a.xyz = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n      return selfPy;\n    });\n    $loc.__lshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w * b, 0, 0, 0, 0, 0, 0, 0);\n      }\n      else {\n        return compute(bladeASM.lcoE3, a, b, coord, remapE3ToPy);\n      }\n    });\n    $loc.__rlshift__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__ilshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var a4 = a.xy;\n      var a5 = a.yz;\n      var a6 = a.zx;\n      var a7 = a.xyz;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        b0 = b;\n        b1 = 0;\n        b2 = 0;\n        b3 = 0;\n        b4 = 0;\n        b5 = 0;\n        b6 = 0;\n        b7 = 0;\n      }\n      else {\n        b0 = b.w;\n        b1 = b.x;\n        b2 = b.y;\n        b3 = b.z;\n        b4 = b.xy;\n        b5 = b.yz;\n        b6 = b.zx;\n        b7 = b.xyz;\n      }\n      a.w   = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n      a.x   = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n      a.y   = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n      a.z   = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n      a.xy  = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n      a.yz  = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n      a.zx  = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n      a.xyz = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n      return selfPy;\n    });\n    $loc.__rshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);\n      }\n      else {\n        return compute(bladeASM.rcoE3, a, b, coord, remapE3ToPy);\n      }\n    });\n    $loc.__rrshift__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a * b.w, 0, 0, 0, 0, 0, 0, 0);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__irshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var a4 = a.xy;\n      var a5 = a.yz;\n      var a6 = a.zx;\n      var a7 = a.xyz;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        b0 = b;\n        b1 = 0;\n        b2 = 0;\n        b3 = 0;\n        b4 = 0;\n        b5 = 0;\n        b6 = 0;\n        b7 = 0;\n      }\n      else {\n        b0 = b.w;\n        b1 = b.x;\n        b2 = b.y;\n        b3 = b.z;\n        b4 = b.xy;\n        b5 = b.yz;\n        b6 = b.zx;\n        b7 = b.xyz;\n      }\n      a.w   = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n      a.x   = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n      a.y   = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n      a.z   = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n      a.xy  = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n      a.yz  = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n      a.zx  = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n      a.xyz = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n      return selfPy;\n    });\n    $loc.nb$positive = function() {\n      return this;\n    };\n    $loc.nb$negative = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return remapE3ToPy(-mv.w, -mv.x, -mv.y, -mv.z, -mv.xy, -mv.yz, -mv.zx, -mv.xyz);\n    };\n    $loc.nb$invert = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return remapE3ToPy(mv.w, mv.x, mv.y, mv.z, -mv.xy, -mv.yz, -mv.zx, -mv.xyz);\n    };\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w === b.w && a.x === b.x && a.y === b.y && a.z === b.z && a.xy === b.xy && a.yz === b.yz && a.zx === b.zx && a.xyz === b.xyz;\n    });\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.z !== b.z || a.xy !== b.xy || a.yz !== b.yz || a.zx !== b.zx || a.xyz !== b.xyz;\n    });\n    $loc.__getitem__ = new Sk.builtin.func(function(mv, index) {\n      mv = Sk.ffi.remapToJs(mv);\n      index = Sk.builtin.asnum$(index);\n      switch(index) {\n        case 0: {\n          return remapE3ToPy(mv.w, 0, 0, 0, 0, 0, 0, 0);\n        }\n        case 1: {\n          return remapE3ToPy(0, mv.x, mv.y, mv.z, 0, 0, 0, 0);\n        }\n        case 2: {\n          return remapE3ToPy(0, 0, 0, 0, mv.xy, mv.yz, mv.zx, 0);\n        }\n        case 3: {\n          return remapE3ToPy(0, 0, 0, 0, 0, 0, 0, mv.xyz);\n        }\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(mvPy, name) {\n      var mv = Sk.ffi.remapToJs(mvPy);\n      switch(name) {\n        case PROP_W: {\n          return Sk.builtin.assk$(mv.w, Sk.builtin.nmber.float$);\n        }\n        case PROP_X: {\n          return Sk.builtin.assk$(mv.x, Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(mv.y, Sk.builtin.nmber.float$);\n        }\n        case PROP_Z: {\n          return Sk.builtin.assk$(mv.z, Sk.builtin.nmber.float$);\n        }\n        case PROP_XY: {\n          return Sk.builtin.assk$(mv.xy, Sk.builtin.nmber.float$);\n        }\n        case PROP_YZ: {\n          return Sk.builtin.assk$(mv.yz, Sk.builtin.nmber.float$);\n        }\n        case PROP_ZX: {\n          return Sk.builtin.assk$(mv.zx, Sk.builtin.nmber.float$);\n        }\n        case PROP_XYZ: {\n          return Sk.builtin.assk$(mv.xyz, Sk.builtin.nmber.float$);\n        }\n        case METHOD_ADD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ADD;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, arg) {\n              arg  = Sk.ffi.remapToJs(arg);\n              mv.w += arg.w;\n              mv.x += arg.x;\n              mv.y += arg.y;\n              mv.z += arg.z;\n              mv.xy += arg.xy;\n              mv.yz += arg.yz;\n              mv.zx += arg.zx;\n              mv.xyz += arg.xyz;\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_ADD);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_ADD);\n            });\n          }, METHOD_ADD, []));\n        }\n        case METHOD_CROSS: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CROSS;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vPy) {\n              var v  = Sk.ffi.remapToJs(vPy);\n              mv.w = 0;\n              mv[METHOD_CROSS](v);\n//            mv.x  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n//            mv.y  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n//            mv.z  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n              mv.xy = 0;\n              mv.yz = 0;\n              mv.zx = 0;\n              mv.xyz = 0;\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CROSS);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CROSS);\n            });\n          }, METHOD_CROSS, []));\n        }\n        case METHOD_DOT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_DOT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vPy) {\n              var v  = Sk.ffi.remapToJs(vPy);\n              return Sk.builtin.assk$(mv[METHOD_DOT](v), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_DOT);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_DOT);\n            });\n          }, METHOD_DOT, []));\n        }\n        case METHOD_SET_X: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_X;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x) {\n              x  = Sk.ffi.remapToJs(x);\n              mv[METHOD_SET_X](x);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_X);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_X);\n            });\n          }, METHOD_SET_X, []));\n        }\n        case METHOD_SET_Y: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_Y;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, y) {\n              y  = Sk.ffi.remapToJs(y);\n              mv[METHOD_SET_Y](y);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_Y);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_Y);\n            });\n          }, METHOD_SET_Y, []));\n        }\n        case METHOD_SET_Z: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_Z;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, z) {\n              z  = Sk.ffi.remapToJs(z);\n              mv[METHOD_SET_Z](z);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_Z);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_Z);\n            });\n          }, METHOD_SET_Z, []));\n        }\n        case METHOD_GET_COMPONENT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_COMPONENT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, index) {\n              index  = Sk.ffi.remapToJs(index);\n              return Sk.builtin.assk$(mv[METHOD_GET_COMPONENT](index), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_COMPONENT);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_COMPONENT);\n            });\n          }, METHOD_GET_COMPONENT, []));\n        }\n        case METHOD_SET_COMPONENT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_COMPONENT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, index, value) {\n              index  = Sk.ffi.remapToJs(index);\n              value  = Sk.ffi.remapToJs(value);\n              mv[METHOD_SET_COMPONENT](index, value);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_COMPONENT);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_COMPONENT);\n            });\n          }, METHOD_SET_COMPONENT, []));\n        }\n        case METHOD_SET: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y, z) {\n              x  = Sk.ffi.remapToJs(x);\n              y  = Sk.ffi.remapToJs(y);\n              z  = Sk.ffi.remapToJs(z);\n              mv[METHOD_SET](x, y, z);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n          }, METHOD_SET, []));\n        }\n        case METHOD_CLONE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CLONE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return remapE3ToPy(mv.w, mv.x, mv.y, mv.z, mv.xy, mv.yz, mv.zx, mv.xyz);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n          }, METHOD_CLONE, []));\n        }\n        case METHOD_LENGTH: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(mv[METHOD_LENGTH](), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n          }, METHOD_LENGTH, []));\n        }\n        case METHOD_NORMALIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_NORMALIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              mv[METHOD_NORMALIZE]();\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n          }, METHOD_NORMALIZE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(mv, name, value) {\n      mv = Sk.ffi.remapToJs(mv);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_W: {\n          mv.w = value;\n        }\n        break;\n        case PROP_X: {\n          mv.x = value;\n        }\n        break;\n        case PROP_Y: {\n          mv.y = value;\n        }\n        break;\n        case PROP_Z: {\n          mv.z = value;\n        }\n        break;\n        case PROP_XY: {\n          mv.xy = value;\n        }\n        break;\n        case PROP_YZ: {\n          mv.yz = value;\n        }\n        break;\n        case PROP_ZX: {\n          mv.zx = value;\n        }\n        break;\n        case PROP_XYZ: {\n          mv.xyz = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not an attribute of \" + EUCLIDEAN_3);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(m) {\n      m = Sk.ffi.remapToJs(m);\n      var grade0 = m.w !== 0;\n      var grade1 = m.x !== 0 || m.y != 0 || m.z !== 0;\n      var grade2 = m.xy !== 0 || m.yz !== 0 || m.zx !== 0;\n      var grade3 = m.xyz !== 0;\n      if (grade0 && !grade1 && !grade2 && !grade3) {\n        var args = [m.w];\n        return new Sk.builtin.str(SCALAR_3 + \"(\" + args.join(\", \") + \")\");\n      }\n      else if (!grade0 && grade1 && !grade2 && !grade3) {\n        var args = [m.x, m.y, m.z];\n        return new Sk.builtin.str(VECTOR_3 + \"(\" + args.join(\", \") + \")\");\n      }\n      else if (!grade0 && !grade1 && grade2 && !grade3) {\n        var args = [m.xy, m.yz, m.zx];\n        return new Sk.builtin.str(BIVECTOR_3 + \"(\" + args.join(\", \") + \")\");\n      }\n      else if (!grade0 && !grade1 && !grade2 && grade3) {\n        var args = [m.xyz];\n        return new Sk.builtin.str(PSEUDOSCALAR_3 + \"(\" + args.join(\", \") + \")\");\n      }\n      else {\n        var args = [m.w, m.x, m.y, m.z, m.xy, m.yz, m.zx, m.xyz];\n        return new Sk.builtin.str(EUCLIDEAN_3 + \"(\" + args.join(\", \") + \")\");\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      if (isDefined(mv)) {\n        return new Sk.builtin.str(bladeSTR.stringFromCoordinates([mv.w, mv.x, mv.y, mv.z, mv.xy, mv.yz, mv.zx, mv.xyz], [\"1\", \"i\", \"j\", \"k\", \"ij\", \"jk\", \"ki\", \"I\"]));\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + EUCLIDEAN_3 + \"'>\");\n      }\n    });\n  }, EUCLIDEAN_3, []);\n\n  mod[QUATERNION] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, x, y, z, w) {\n      x = Sk.ffi.remapToJs(x);\n      y = Sk.ffi.remapToJs(y);\n      z = Sk.ffi.remapToJs(z);\n      w = Sk.ffi.remapToJs(w);\n      if (isObject(x) && isUndefined(y) && isUndefined(z) && isUndefined(w)) {\n        self.v = x;\n      }\n      else {\n        self.v = new THREE[QUATERNION](x, y, z, w);\n      }\n      self.tp$name = QUATERNION;\n    });\n    $loc.__add__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return wxyzToPy(a.w + b, a.x, a.y, a.z);\n      }\n      else {\n        var w = a.w + b.w;\n        var x = a.x + b.x;\n        var y = a.y + b.y;\n        var z = a.z + b.z;\n        return wxyzToPy(w, x, y, z);\n      }\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return wxyzToPy(a + b.w, b.x, b.y, b.z);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w += other;\n      }\n      else {\n        self.w += other.w;\n        self.x += other.x;\n        self.y += other.y;\n        self.z += other.z;\n      }\n      return selfPy;\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return wxyzToPy(a.w - b, a.x, a.y, a.z);\n      }\n      else {\n        var w = a.w - b.w;\n        var x = a.x - b.x;\n        var y = a.y - b.y;\n        var z = a.z - b.z;\n        return wxyzToPy(w, x, y, z);\n      }\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return wxyzToPy(a - b.w, -b.x, -b.y, -b.z);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w -= other;\n      }\n      else {\n        self.w -= other.w;\n        self.x -= other.x;\n        self.y -= other.y;\n        self.z -= other.z;\n      }\n      return selfPy;\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return wxyzToPy(a.w * b, a.x * b, a.y * b, a.z * b);\n      }\n      else {\n        var ab = new THREE[QUATERNION]().multiplyQuaternions(a, b);\n        return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(ab, QUATERNION));\n      }\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return quaternionToPy(a * b.w, a * b.x, a * b.y, a * b.z);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        a.w *= b;\n        a.x *= b;\n        a.y *= b;\n        a.z *= b;\n      }\n      else {\n        a.multiply(b);\n      }\n      return selfPy;\n    });\n    $loc.nb$positive = function() {\n      return this;\n    };\n    $loc.nb$negative = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return quaternionToPy(-mv.x, -mv.y, -mv.z, -mv.w);\n    };\n    $loc.nb$invert = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return remapE3ToPy(mv.w, mv.x, mv.y, mv.z, -mv.xy, -mv.yz, -mv.zx, -mv.xyz);\n    };\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w === b.w && a.x === b.x && a.y === b.y && a.z === b.z;\n    });\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.z !== b.z;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(quaternionPy, name) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      switch(name) {\n        case PROP_X: {\n          return Sk.builtin.assk$(quaternion.x, Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(quaternion.y, Sk.builtin.nmber.float$);\n        }\n        case PROP_Z: {\n          return Sk.builtin.assk$(quaternion.z, Sk.builtin.nmber.float$);\n        }\n        case PROP_W: {\n          return Sk.builtin.assk$(quaternion.w, Sk.builtin.nmber.float$);\n        }\n        case METHOD_COPY: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_COPY;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, qPy) {\n              var q  = Sk.ffi.remapToJs(qPy);\n              quaternion.x = q.x;\n              quaternion.y = q.y;\n              quaternion.z = q.z;\n              quaternion.w = q.w;\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_COPY);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_COPY);\n            });\n          }, METHOD_COPY, []));\n        }\n        case METHOD_SET_FROM_AXIS_ANGLE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_FROM_AXIS_ANGLE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, axisPy, anglePy) {\n              var axis = Sk.ffi.remapToJs(axisPy);\n              var angle = Sk.ffi.remapToJs(anglePy);\n              quaternion[METHOD_SET_FROM_AXIS_ANGLE](axis, angle);\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_AXIS_ANGLE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_AXIS_ANGLE);\n            });\n          }, METHOD_SET_FROM_AXIS_ANGLE, []));\n        }\n        case METHOD_SET_FROM_EULER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_FROM_EULER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy, orderPy) {\n              var vector = Sk.ffi.remapToJs(vectorPy);\n              var order = Sk.ffi.remapToJs(orderPy);\n              quaternion[METHOD_SET_FROM_EULER](vector, order);\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_EULER);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_EULER);\n            });\n          }, METHOD_SET_FROM_EULER, []));\n        }\n        case METHOD_SET: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y, z, w) {\n              quaternion.x = Sk.ffi.remapToJs(x);\n              quaternion.y = Sk.ffi.remapToJs(y);\n              quaternion.z = Sk.ffi.remapToJs(z);\n              quaternion.w = Sk.ffi.remapToJs(w);\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n          }, METHOD_SET, []));\n        }\n        case METHOD_CLONE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CLONE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return wxyzToPy(quaternion.w, quaternion.x, quaternion.y, quaternion.z);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n          }, METHOD_CLONE, []));\n        }\n        case METHOD_CONJUGATE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CONJUGATE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              quaternion[METHOD_CONJUGATE]();\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CONJUGATE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CONJUGATE);\n            });\n          }, METHOD_CONJUGATE, []));\n        }\n        case METHOD_INVERSE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_INVERSE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              var k = 1.0 / quaternion.lengthSq();\n              quaternion[METHOD_CONJUGATE]();\n              quaternion.w *= k;\n              quaternion.x *= k;\n              quaternion.y *= k;\n              quaternion.z *= k;\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_INVERSE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_INVERSE);\n            });\n          }, METHOD_INVERSE, []));\n        }\n        case METHOD_LENGTH: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(quaternion[METHOD_LENGTH](), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n          }, METHOD_LENGTH, []));\n        }\n        case METHOD_LENGTH_SQ: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH_SQ;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(quaternion[METHOD_LENGTH_SQ](), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH_SQ);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH_SQ);\n            });\n          }, METHOD_LENGTH_SQ, []));\n        }\n        case METHOD_NORMALIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_NORMALIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              quaternion[METHOD_NORMALIZE]();\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n          }, METHOD_NORMALIZE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(quaternionPy, name, valuePy) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_X: {\n          quaternion.x = value;\n        }\n        break;\n        case PROP_Y: {\n          quaternion.y = value;\n        }\n        break;\n        case PROP_Z: {\n          quaternion.z = value;\n        }\n        break;\n        case PROP_W: {\n          quaternion.w = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not an attribute of \" + QUATERNION);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(quaternionPy) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      var args = [quaternion.x, quaternion.y, quaternion.z, quaternion.w];\n      return new Sk.builtin.str(QUATERNION + \"(\" + args.join(\", \") + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(quaternionPy) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      if (isDefined(quaternion)) {\n        return new Sk.builtin.str(bladeSTR.stringFromCoordinates([quaternion.w, quaternion.x, quaternion.y, quaternion.z], [\"1\", \"i\", \"j\", \"k\"]));\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + QUATERNION + \"'>\");\n      }\n    });\n  }, QUATERNION, []);\n\n  // Erik Moller's requestAnimationFrame for smart(er) animating\n  // Minor formatting changes and use of braces for if conditions.\n  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n  // The purpose of this enhanced shim is to \n  (function(scope) {\n    if (isDefined(scope)) {\n      var lastTime = 0;\n      var vendors = ['ms', 'moz', 'webkit', 'o'];\n      for(var x = 0; x < vendors.length && !scope.requestAnimationFrame; ++x) {\n        scope.requestAnimationFrame = scope[vendors[x]+'RequestAnimationFrame'];\n        scope.cancelRequestAnimationFrame = scope[vendors[x]+'CancelRequestAnimationFrame'];\n      }\n\n      if (!scope.requestAnimationFrame) {\n        scope.requestAnimationFrame = function(callback, element) {\n          var currTime = new Date().getTime();\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n          var id = scope.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);\n          lastTime = currTime + timeToCall;\n          return id;\n        };\n      }\n\n      if (!scope.cancelAnimationFrame) {\n        scope.cancelAnimationFrame = function(id) {\n          clearTimeout(id);\n        };\n      }\n    }\n  }((typeof window === 'object') ? window : void 0));\n\n   mod[SCENE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.v = new THREE[SCENE]();\n      self.tp$name = SCENE;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(scenePy, name) {\n      var scene = Sk.ffi.remapToJs(scenePy);\n      switch(name) {\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(scene[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(scene[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return scene[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              scene.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return scenePy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case METHOD_ADD: {\n          return methodAdd(scene);\n        }\n        case METHOD_REMOVE: {\n          return methodRemove(scene);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(scenePy, name, valuePy) {\n      var scene = Sk.ffi.remapToJs(scenePy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_POSITION: {\n          scene[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          scene[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          scene[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            scene[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          scene[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          scene[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          scene[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not a write attribute of \" + SCENE);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(SCENE);\n    });\n  }, SCENE, []);\n\n  mod[CANVAS_RENDERER] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_AUTO_CLEAR   = \"autoClear\";\n    var PROP_CLEAR_COLOR  = \"clearColor\";\n    var PROP_DOM_ELEMENT  = \"domElement\";\n    var PROP_GAMMA_INPUT  = \"gammaInput\";\n    var PROP_GAMMA_OUTPUT = \"gammaOutput\";\n    var PROP_SORT_OBJECTS = \"sortObjects\";\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = CANVAS_RENDERER;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[CANVAS_RENDERER](parameters);\n    });\n    $loc.setSize = new Sk.builtin.func(function(self, width, height) {\n      self.v.setSize(Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      var METHOD_RENDER = \"render\";\n      var METHOD_GET_CLEAR_COLOR = \"getClearColor\";\n      var METHOD_SET_CLEAR_COLOR = \"setClearColor\";\n      var METHOD_SET_SIZE        = \"setSize\";\n      var renderer  = Sk.ffi.remapToJs(self);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          return renderer[PROP_AUTO_CLEAR];\n        }\n        case PROP_GAMMA_INPUT: {\n          return renderer[PROP_GAMMA_INPUT];\n        }\n        case PROP_GAMMA_OUTPUT: {\n          return renderer[PROP_GAMMA_OUTPUT];\n        }\n        case PROP_SORT_OBJECTS: {\n          return renderer[PROP_SORT_OBJECTS];\n        }\n        case PROP_DOM_ELEMENT: {\n          // TODO: I think duck-typing means that this will work as long as we don't\n          // try to do anything more ambitious.\n          return {v: renderer.domElement};\n        }\n        case METHOD_RENDER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_RENDER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, scene, camera) {\n              scene  = Sk.ffi.remapToJs(scene);\n              camera = Sk.ffi.remapToJs(camera);\n              renderer.render(scene, camera);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n          }, METHOD_RENDER, []));\n        }\n        case METHOD_GET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(renderer.getClearColor(), COLOR));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n          }, METHOD_GET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color, alpha) {\n              color  = Sk.ffi.remapToJs(color);\n              alpha = Sk.ffi.remapToJs(alpha);\n              renderer.setClearColor(color, alpha);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n          }, METHOD_SET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_SIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_SIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, width, height, updateStyle) {\n              width  = Sk.ffi.remapToJs(width);\n              height = Sk.ffi.remapToJs(height);\n              updateStyle = Sk.ffi.remapToJs(updateStyle);\n              renderer.setSize(width, height, updateStyle);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n          }, METHOD_SET_SIZE, []));\n        }\n        default: {\n          // The framework will raise an AttributeError exception.\n          return /* undefined */;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(self, name, value) {\n      var renderer  = Sk.ffi.remapToJs(self);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          if (isBoolean(value)) {\n            renderer[PROP_AUTO_CLEAR] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_AUTO_CLEAR + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_GAMMA_INPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_INPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_GAMMA_INPUT + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_GAMMA_OUTPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_OUTPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_GAMMA_OUTPUT + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_SORT_OBJECTS: {\n          if (isBoolean(value)) {\n            renderer[PROP_SORT_OBJECTS] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_SORT_OBJECTS + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case \"size\": {\n          var width  = Sk.builtin.asnum$(value[0]);\n          var height = Sk.builtin.asnum$(value[1]);\n          renderer.setSize(width, height);\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + CANVAS_RENDERER);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var args = {};\n      args[PROP_AUTO_CLEAR] = renderer[PROP_AUTO_CLEAR];\n      args[PROP_GAMMA_INPUT] = renderer[PROP_GAMMA_INPUT];\n      args[PROP_GAMMA_OUTPUT] = renderer[PROP_GAMMA_OUTPUT];\n      return new Sk.builtin.str(CANVAS_RENDERER + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var autoClear = renderer[PROP_AUTO_CLEAR];\n      // Note: The WebGLRenderer takes only one argument, but it is a dictionary.\n      var args = [{\"autoClear\": autoClear}];\n      return new Sk.builtin.str(CANVAS_RENDERER + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, CANVAS_RENDERER, []);\n\n  mod[WEBGL_RENDERER] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_AUTO_CLEAR   = \"autoClear\";\n    var PROP_CLEAR_COLOR  = \"clearColor\";\n    var PROP_DOM_ELEMENT  = \"domElement\";\n    var PROP_GAMMA_INPUT  = \"gammaInput\";\n    var PROP_GAMMA_OUTPUT = \"gammaOutput\";\n    var PROP_SORT_OBJECTS = \"sortObjects\";\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = WEBGL_RENDERER;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[WEBGL_RENDERER](parameters);\n    });\n    $loc.setSize = new Sk.builtin.func(function(self, width, height) {\n      self.v.setSize(Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      var METHOD_RENDER = \"render\";\n      var METHOD_GET_CLEAR_COLOR = \"getClearColor\";\n      var METHOD_SET_CLEAR_COLOR = \"setClearColor\";\n      var METHOD_SET_SIZE        = \"setSize\";\n      var renderer  = Sk.ffi.remapToJs(self);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          return renderer[PROP_AUTO_CLEAR];\n        }\n        case PROP_GAMMA_INPUT: {\n          return renderer[PROP_GAMMA_INPUT];\n        }\n        case PROP_GAMMA_OUTPUT: {\n          return renderer[PROP_GAMMA_OUTPUT];\n        }\n        case PROP_SORT_OBJECTS: {\n          return renderer[PROP_SORT_OBJECTS];\n        }\n        case PROP_DOM_ELEMENT: {\n          // TODO: I think duck-typing means that this will work as long as we don't\n          // try to do anything more ambitious.\n          return {v: renderer.domElement};\n        }\n        case METHOD_RENDER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_RENDER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, scene, camera) {\n              scene  = Sk.ffi.remapToJs(scene);\n              camera = Sk.ffi.remapToJs(camera);\n              renderer.render(scene, camera);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n          }, METHOD_RENDER, []));\n        }\n        case METHOD_GET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(renderer.getClearColor()));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n          }, METHOD_GET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color, alpha) {\n              color  = Sk.ffi.remapToJs(color);\n              alpha = Sk.ffi.remapToJs(alpha);\n              renderer.setClearColor(color, alpha);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n          }, METHOD_SET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_SIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_SIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, width, height, updateStyle) {\n              width  = Sk.ffi.remapToJs(width);\n              height = Sk.ffi.remapToJs(height);\n              updateStyle = Sk.ffi.remapToJs(updateStyle);\n              renderer.setSize(width, height, updateStyle);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n          }, METHOD_SET_SIZE, []));\n        }\n        default: {\n          // The framework will raise an AttributeError exception.\n          return /* undefined */;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(self, name, value) {\n      var renderer  = Sk.ffi.remapToJs(self);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          if (isBoolean(value)) {\n            renderer[PROP_AUTO_CLEAR] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_AUTO_CLEAR + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_GAMMA_INPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_INPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_GAMMA_INPUT + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_GAMMA_OUTPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_OUTPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_GAMMA_OUTPUT + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_SORT_OBJECTS: {\n          if (isBoolean(value)) {\n            renderer[PROP_SORT_OBJECTS] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_SORT_OBJECTS + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case \"size\": {\n          var width  = Sk.builtin.asnum$(value[0]);\n          var height = Sk.builtin.asnum$(value[1]);\n          renderer.setSize(width, height);\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + WEBGL_RENDERER);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var args = {};\n      args[PROP_AUTO_CLEAR] = renderer[PROP_AUTO_CLEAR];\n      args[PROP_GAMMA_INPUT] = renderer[PROP_GAMMA_INPUT];\n      args[PROP_GAMMA_OUTPUT] = renderer[PROP_GAMMA_OUTPUT];\n      return new Sk.builtin.str(WEBGL_RENDERER + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var autoClear = renderer[PROP_AUTO_CLEAR];\n      // Note: The WebGLRenderer takes only one argument, but it is a dictionary.\n      var args = [{\"autoClear\": autoClear}];\n      return new Sk.builtin.str(WEBGL_RENDERER + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, WEBGL_RENDERER, []);\n\n  mod[COLOR] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_R = \"r\";\n    var PROP_G = \"g\";\n    var PROP_B = \"b\";\n    $loc.__init__ = new Sk.builtin.func(function(self, value) {\n      value = Sk.ffi.remapToJs(value);\n      self.tp$name = COLOR;\n      if (isUndefined(value)) {\n        self.v = new THREE.Color();\n      }\n      else {\n        if (isNumber(value) || isString(value)) {\n          self.v = new THREE.Color(value);\n        }\n        else if (isColor(value)) {\n          self.v = new THREE.Color(value);\n        }\n        else {\n          throw new Sk.builtin.AssertionError(\"value must be either a number, string or Color.\");\n        }\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(colorPy, name) {\n      var color = Sk.ffi.remapToJs(colorPy);\n      switch(name) {\n        case PROP_R: {\n          return Sk.builtin.assk$(color[PROP_R], Sk.builtin.nmber.float$);\n        }\n        case PROP_G: {\n          return Sk.builtin.assk$(color[PROP_G], Sk.builtin.nmber.float$);\n        }\n        case PROP_B: {\n          return Sk.builtin.assk$(color[PROP_B], Sk.builtin.nmber.float$);\n        }\n        case METHOD_SET_RGB: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_RGB;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, rPy, gPy, bPy) {\n              var r  = Sk.ffi.remapToJs(rPy);\n              var g  = Sk.ffi.remapToJs(gPy);\n              var b  = Sk.ffi.remapToJs(bPy);\n              color.setRGB(r, g, b);\n              return colorPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_RGB);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_RGB);\n            });\n          }, METHOD_SET_RGB, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(colorPy, name, valuePy) {\n      var color = Sk.ffi.remapToJs(colorPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_R: {\n          color[PROP_R] = value;\n        }\n        break;\n        case PROP_G: {\n          color[PROP_G] = value;\n        }\n        break;\n        case PROP_B: {\n          color[PROP_B] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not an attribute of \" + COLOR);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var color = self.v;\n      var args = {};\n      args[PROP_R] = color[PROP_R];\n      args[PROP_G] = color[PROP_G];\n      args[PROP_B] = color[PROP_B];\n      return new Sk.builtin.str(COLOR + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var color = self.v;\n      var r = color[PROP_R];\n      var g = color[PROP_G];\n      var b = color[PROP_B];\n      var args = [r, g, b];\n      return new Sk.builtin.str(COLOR + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, COLOR, []);\n\n  mod[PERSPECTIVE_CAMERA] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, fov, aspect, near, far) {\n      var fieldOfView = Sk.builtin.asnum$(fov)\n      var aspectRatio = Sk.builtin.asnum$(aspect)\n      var nearPlane = Sk.builtin.asnum$(near)\n      var farPlane = Sk.builtin.asnum$(far)\n      self.v = new THREE[PERSPECTIVE_CAMERA](fieldOfView, aspectRatio, nearPlane, farPlane);\n      self.tp$name = PERSPECTIVE_CAMERA;\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(cameraPy, name) {\n      camera = Sk.ffi.remapToJs(cameraPy);\n      var UPDATE_PROJECTION_MATRIX = \"updateProjectionMatrix\"\n      switch(name) {\n        case \"aspect\": {\n          return Sk.builtin.assk$(camera.aspect, Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(camera[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(camera[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_UP], EUCLIDEAN_3));\n        }\n        case PROP_USE_QUATERNION: {\n          return camera[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              camera.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return cameraPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case UPDATE_PROJECTION_MATRIX: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = UPDATE_PROJECTION_MATRIX;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              camera[name]();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n          }, UPDATE_PROJECTION_MATRIX, []));\n        }\n        default: {\n          return;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(cameraPy, name, valuePy) {\n      var camera = Sk.ffi.remapToJs(cameraPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case \"aspect\": {\n          camera.aspect = value;\n        }\n        break;\n        case PROP_POSITION: {\n          camera[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          camera[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          camera[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            camera[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          camera[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          camera[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          camera[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AssertionError(name + \" is not an attribute of \" + PERSPECTIVE_CAMERA);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(PERSPECTIVE_CAMERA);\n    });\n  }, PERSPECTIVE_CAMERA, []);\n\n  mod[ORTHOGRAPHIC_CAMERA] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, leftPy, rightPy, topPy, bottomPy, nearPy, farPy) {\n      var left = Sk.builtin.asnum$(leftPy)\n      var right = Sk.builtin.asnum$(rightPy)\n      var top = Sk.builtin.asnum$(topPy)\n      var bottom = Sk.builtin.asnum$(bottomPy)\n      var near = Sk.builtin.asnum$(nearPy)\n      var far = Sk.builtin.asnum$(farPy)\n      self.v = new THREE[ORTHOGRAPHIC_CAMERA](left, right, top, bottom, near, far);\n      self.tp$name = ORTHOGRAPHIC_CAMERA;\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(cameraPy, name) {\n      camera = Sk.ffi.remapToJs(cameraPy);\n      var UPDATE_PROJECTION_MATRIX = \"updateProjectionMatrix\"\n      switch(name) {\n        case \"aspect\": {\n          return Sk.builtin.assk$(camera.aspect, Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(camera[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(camera[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return camera[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              camera.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return cameraPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case UPDATE_PROJECTION_MATRIX: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = UPDATE_PROJECTION_MATRIX;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              camera[name]();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n          }, UPDATE_PROJECTION_MATRIX, []));\n        }\n        default: {\n          return;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(cameraPy, name, valuePy) {\n      var camera = Sk.ffi.remapToJs(cameraPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_LEFT: {\n          camera[PROP_LEFT] = value;\n        }\n        break;\n        case PROP_RIGHT: {\n          camera[PROP_RIGHT] = value;\n        }\n        break;\n        case PROP_TOP: {\n          camera[PROP_TOP] = value;\n        }\n        break;\n        case PROP_BOTTOM: {\n          camera[PROP_BOTTOM] = value;\n        }\n        break;\n        case PROP_POSITION: {\n          camera[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          camera[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          camera[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            camera[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          camera[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          camera[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          camera[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AssertionError(name + \" is not an attribute of \" + ORTHOGRAPHIC_CAMERA);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(cameraPy) {\n      var camera = Sk.ffi.remapToJs(cameraPy);\n      var args = [camera[PROP_LEFT], camera[PROP_RIGHT], camera[PROP_TOP], camera[PROP_BOTTOM], camera[PROP_NEAR], camera[PROP_FAR]];\n      return new Sk.builtin.str(ORTHOGRAPHIC_CAMERA + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(ORTHOGRAPHIC_CAMERA);\n    });\n  }, ORTHOGRAPHIC_CAMERA, []);\n\n  mod[ARROW_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, length, segments, radiusShaft, radiusCone, lengthCone) {\n      length = Sk.ffi.remapToJs(length) || 1;\n      segments = Sk.ffi.remapToJs(segments);\n      radiusShaft = Sk.ffi.remapToJs(radiusShaft) || 0.01;\n      radiusCone = Sk.ffi.remapToJs(radiusCone) || 0.08;\n      lengthCone = Sk.ffi.remapToJs(lengthCone) || 0.2;\n      var lengthShaft = 1 - lengthCone;\n      var a = new THREE.Vector3(0, 0, length);\n      var b = new THREE.Vector3(radiusCone, 0, lengthShaft);\n      var c = new THREE.Vector3(radiusShaft, 0, lengthShaft);\n      var d = new THREE.Vector3(radiusShaft, 0, 0);\n      var e = new THREE.Vector3(0, 0, 0);\n      var points = [a, b, c, d, e];\n      self.v = new THREE.LatheGeometry(points, segments);\n      self.tp$name = ARROW_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(geometryPy, name) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(geometry[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(geometry[PROP_NAME]);\n        }\n        case PROP_VERTICES: {\n          return verticesPy(geometry.vertices);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_NAME: {\n          if (isString(value)) {\n            geometry[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + ARROW_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var geometry = Sk.ffi.remapToJs(self);\n      var args = {};\n      return new Sk.builtin.str(ARROW_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var geometry = Sk.ffi.remapToJs(self);\n      var args = [];\n      return new Sk.builtin.str(ARROW_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, ARROW_GEOMETRY, []);\n\n   mod[CIRCLE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, segments, thetaStart, thetaLength) {\n      radius      = numberFromArg(radius,          PROP_RADIUS,       CIRCLE_GEOMETRY);\n      segments    = numberFromIntegerArg(segments, PROP_SEGMENTS,     CIRCLE_GEOMETRY);\n      thetaStart  = numberFromArg(thetaStart,      PROP_THETA_START,  CIRCLE_GEOMETRY);\n      thetaLength = numberFromArg(thetaLength,     PROP_THETA_LENGTH, CIRCLE_GEOMETRY);\n      self.v = new THREE[CIRCLE_GEOMETRY](radius, segments, thetaStart, thetaLength);\n      self.tp$name = CIRCLE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + CIRCLE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var args = {};\n      return new Sk.builtin.str(CIRCLE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var args = [];\n      return new Sk.builtin.str(CIRCLE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, CIRCLE_GEOMETRY, []);\n\n   mod[CUBE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_WIDTH           = \"width\";\n    var PROP_HEIGHT          = \"height\";\n    var PROP_DEPTH           = \"depth\";\n    var PROP_WIDTH_SEGMENTS  = \"widthSegments\";\n    var PROP_HEIGHT_SEGMENTS = \"heightSegments\";\n    var PROP_DEPTH_SEGMENTS  = \"depthSegments\";\n    $loc.__init__ = new Sk.builtin.func(function(self, width, height, depth, widthSegments, heightSegments, depthSegments) {\n      width          = numberFromArg(width,                 PROP_WIDTH,           CUBE_GEOMETRY);\n      height         = numberFromArg(height,                PROP_HEIGHT,          CUBE_GEOMETRY);\n      depth          = numberFromArg(depth,                 PROP_DEPTH,           CUBE_GEOMETRY);\n      widthSegments  = numberFromIntegerArg(widthSegments,  PROP_WIDTH_SEGMENTS,  CUBE_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, CUBE_GEOMETRY);\n      depthSegments  = numberFromIntegerArg(depthSegments,  PROP_DEPTH_SEGMENTS,  CUBE_GEOMETRY);\n      self.v = new THREE[CUBE_GEOMETRY](width, height, depth, widthSegments, heightSegments, depthSegments);\n      self.tp$name = CUBE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_WIDTH: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT], Sk.builtin.nmber.float$);\n        }\n        case PROP_DEPTH: {\n          return Sk.builtin.assk$(self.v[PROP_DEPTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_WIDTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_DEPTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_DEPTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + CUBE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var cube = self.v;\n      var args = {};\n      args[PROP_WIDTH]  = cube[PROP_WIDTH];\n      args[PROP_HEIGHT] = cube[PROP_HEIGHT];\n      args[PROP_DEPTH]  = cube[PROP_DEPTH];\n      return new Sk.builtin.str(CUBE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var cube = self.v;\n      var width          = cube[PROP_WIDTH];\n      var height         = cube[PROP_HEIGHT];\n      var depth          = cube[PROP_DEPTH];\n      var widthSegments  = cube[PROP_WIDTH_SEGMENTS];\n      var heightSegments = cube[PROP_HEIGHT_SEGMENTS];\n      var depthSegments  = cube[PROP_DEPTH_SEGMENTS];\n      var args = [width, height, depth, widthSegments, heightSegments, depthSegments];\n      return new Sk.builtin.str(CUBE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, CUBE_GEOMETRY, []);\n\n  mod[CYLINDER_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_RADIUS_TOP      = \"radiusTop\";\n    var PROP_RADIUS_BOTTOM   = \"radiusBottom\";\n    var PROP_HEIGHT          = \"height\";\n    var PROP_RADIUS_SEGMENTS = \"radiusSegments\";\n    var PROP_HEIGHT_SEGMENTS = \"heightSegments\";\n    var PROP_OPEN_ENDED      = \"openEnded\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded) {\n      radiusTop      = numberFromArg(radiusTop,             PROP_RADIUS_TOP,      CYLINDER_GEOMETRY);\n      radiusBottom   = numberFromArg(radiusBottom,          PROP_RADIUS_BOTTOM,   CYLINDER_GEOMETRY);\n      height         = numberFromArg(height,                PROP_HEIGHT,          CYLINDER_GEOMETRY);\n      radiusSegments = numberFromIntegerArg(radiusSegments, PROP_RADIUS_SEGMENTS, CYLINDER_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, CYLINDER_GEOMETRY);\n      openEnded      = Sk.ffi.remapToJs(openEnded);\n      self.v = new THREE[CYLINDER_GEOMETRY](radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded);\n      self.tp$name = CYLINDER_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS_TOP: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS_TOP], Sk.builtin.nmber.float$);\n        }\n        case PROP_RADIUS_BOTTOM: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS_BOTTOM], Sk.builtin.nmber.float$);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT], Sk.builtin.nmber.float$);\n        }\n        case PROP_RADIUS_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_OPEN_ENDED: {\n          return self.v[PROP_OPEN_ENDED];\n        }\n        default: {\n          // Framework will take care of the error message.\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + CYLINDER_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var cylinder = self.v;\n      var args = {};\n      args[PROP_RADIUS_TOP] = cylinder[PROP_RADIUS_TOP];\n      args[PROP_RADIUS_BOTTOM] = cylinder[PROP_RADIUS_BOTTOM];\n      args[PROP_HEIGHT] = cylinder[PROP_HEIGHT];\n      args[PROP_OPEN_ENDED] = cylinder[PROP_OPEN_ENDED];\n      // TODO: Need a Python.stringify because Boolean is {True, False} etc.\n      return new Sk.builtin.str(CYLINDER_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var cylinder = self.v;\n      var radiusTop      = cylinder[PROP_RADIUS_TOP];\n      var radiusBottom   = cylinder[PROP_RADIUS_BOTTOM];\n      var height         = cylinder[PROP_HEIGHT];\n      var radiusSegments = cylinder[PROP_RADIUS_SEGMENTS];\n      var heightSegments = cylinder[PROP_HEIGHT_SEGMENTS];\n      var openEnded      = cylinder[PROP_OPEN_ENDED];\n      var args = [radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded];\n      return new Sk.builtin.str(CYLINDER_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, CYLINDER_GEOMETRY, []);\n\n  mod[LATHE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, pointsPy, segmentsPy, phiStart, phiLength) {\n      var points = Sk.ffi.remapToJs(pointsPy);\n      var segments = Sk.ffi.remapToJs(segmentsPy);\n      phiStart = Sk.ffi.remapToJs(phiStart);\n      phiLength = Sk.ffi.remapToJs(phiLength);\n      self.v = new THREE[LATHE_GEOMETRY](points, segments, phiStart, phiLength);\n      self.tp$name = LATHE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(geometryPy, name) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(geometry[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(geometry[PROP_NAME]);\n        }\n        case PROP_VERTICES: {\n          return verticesPy(geometry.vertices);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_NAME: {\n          if (isString(value)) {\n            geometry[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + LATHE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var latheGeometry = self.v;\n      var args = {};\n      return new Sk.builtin.str(LATHE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var latheGeometry = self.v;\n      var args = [];\n      return new Sk.builtin.str(LATHE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, LATHE_GEOMETRY, []);\n\n  mod[ICOSAHEDRON_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, detail) {\n      radius = numberFromArg(radius,        PROP_RADIUS, ICOSAHEDRON_GEOMETRY);\n      detail = numberFromIntegerArg(detail, PROP_DETAIL, ICOSAHEDRON_GEOMETRY);\n      self.v = new THREE[ICOSAHEDRON_GEOMETRY](radius, detail);\n      self.tp$name = ICOSAHEDRON_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_DETAIL: {\n          return Sk.builtin.assk$(self.v[PROP_DETAIL], Sk.builtin.nmber.int$);\n        }\n        default: {\n          // Framework will take care of the error message.\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + ICOSAHEDRON_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var icosahedron = self.v;\n      var args = {};\n      args[PROP_RADIUS] = icosahedron[PROP_RADIUS];\n      args[PROP_DETAIL] = icosahedron[PROP_DETAIL];\n      return new Sk.builtin.str(ICOSAHEDRON_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var icosahedron = self.v;\n      var radius = icosahedron[PROP_RADIUS];\n      var detail = icosahedron[PROP_DETAIL];\n      var args = [radius, detail];\n      return new Sk.builtin.str(ICOSAHEDRON_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, ICOSAHEDRON_GEOMETRY, []);\n\n  mod[OCTAHEDRON_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_DETAIL = \"detail\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, detail) {\n      radius = numberFromArg(radius,        PROP_RADIUS, OCTAHEDRON_GEOMETRY);\n      detail = numberFromIntegerArg(detail, PROP_DETAIL, OCTAHEDRON_GEOMETRY);\n      self.v = new THREE[OCTAHEDRON_GEOMETRY](radius, detail);\n      self.v.radius = radius; // workaround for THREE not caching radius.\n      self.v.detail = detail; // workaround for THREE not caching detail.\n      self.tp$name = OCTAHEDRON_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_DETAIL: {\n          return Sk.builtin.assk$(self.v[PROP_DETAIL], Sk.builtin.nmber.int$);\n        }\n        default: {\n          // Framework will take care of the error message.\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + OCTAHEDRON_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var octahedron = self.v;\n      var args = {};\n      args[PROP_RADIUS] = octahedron[PROP_RADIUS];\n      args[PROP_DETAIL] = octahedron[PROP_DETAIL];\n      return new Sk.builtin.str(OCTAHEDRON_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var octahedron = self.v;\n      var radius = octahedron[PROP_RADIUS];\n      var detail = octahedron[PROP_DETAIL];\n      var args = [radius, detail];\n      return new Sk.builtin.str(OCTAHEDRON_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, OCTAHEDRON_GEOMETRY, []);\n\n   mod[PLANE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_WIDTH           = \"width\";\n    var PROP_HEIGHT          = \"height\";\n    var PROP_WIDTH_SEGMENTS  = \"widthSegments\";\n    var PROP_HEIGHT_SEGMENTS = \"heightSegments\";\n    $loc.__init__ = new Sk.builtin.func(function(self, width, height, widthSegments, heightSegments) {\n      width          = numberFromArg(width,                 PROP_WIDTH,           PLANE_GEOMETRY);\n      height         = numberFromArg(height,                PROP_HEIGHT,          PLANE_GEOMETRY);\n      widthSegments  = numberFromIntegerArg(widthSegments,  PROP_WIDTH_SEGMENTS,  PLANE_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, PLANE_GEOMETRY);\n      self.v = new THREE[PLANE_GEOMETRY](width, height, widthSegments, heightSegments);\n      self.tp$name = PLANE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_WIDTH: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT], Sk.builtin.nmber.float$);\n        }\n        case PROP_WIDTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + PLANE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var plane = self.v;\n      var args = {};\n      args[PROP_WIDTH]  = plane[PROP_WIDTH];\n      args[PROP_HEIGHT] = plane[PROP_HEIGHT];\n      return new Sk.builtin.str(PLANE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var plane = self.v;\n      var width          = plane[PROP_WIDTH];\n      var height         = plane[PROP_HEIGHT];\n      var widthSegments  = plane[PROP_WIDTH_SEGMENTS];\n      var heightSegments = plane[PROP_HEIGHT_SEGMENTS];\n      var args = [width, height, widthSegments, heightSegments];\n      return new Sk.builtin.str(PLANE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, PLANE_GEOMETRY, []);\n\n   mod[SPHERE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_WIDTH_SEGMENTS  = \"widthSegments\";\n    var PROP_HEIGHT_SEGMENTS = \"heightSegments\";\n    var PROP_PHI_START       = \"phiStart\";\n    var PROP_PHI_LENGTH      = \"phiLength\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {\n      radius         = numberFromArg(radius,                PROP_RADIUS,          SPHERE_GEOMETRY);\n      widthSegments  = numberFromIntegerArg(widthSegments,  PROP_WIDTH_SEGMENTS,  SPHERE_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, SPHERE_GEOMETRY);\n      phiStart       = numberFromArg(phiStart,              PROP_PHI_START,       SPHERE_GEOMETRY);\n      phiLength      = numberFromArg(phiLength,             PROP_PHI_LENGTH,      SPHERE_GEOMETRY);\n      thetaStart     = numberFromArg(thetaStart,            PROP_THETA_START,     SPHERE_GEOMETRY);\n      thetaLength    = numberFromArg(thetaLength,           PROP_THETA_LENGTH,    SPHERE_GEOMETRY);\n      self.v = new THREE[SPHERE_GEOMETRY](radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);\n      self.tp$name = SPHERE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_WIDTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_PHI_START: {\n          return Sk.builtin.assk$(self.v[PROP_PHI_START], Sk.builtin.nmber.float$);\n        }\n        case PROP_PHI_LENGTH: {\n          return Sk.builtin.assk$(self.v[PROP_PHI_LENGTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_THETA_START: {\n          return Sk.builtin.assk$(self.v[PROP_THETA_START], Sk.builtin.nmber.float$);\n        }\n        case PROP_THETA_LENGTH: {\n          return Sk.builtin.assk$(self.v[PROP_THETA_LENGTH], Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + SPHERE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var radius = sphere[PROP_RADIUS];\n      var args = {};\n      args[PROP_RADIUS] = radius;\n      return new Sk.builtin.str(SPHERE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var radius         = sphere[PROP_RADIUS];\n      var widthSegments  = sphere[PROP_WIDTH_SEGMENTS];\n      var heightSegments = sphere[PROP_HEIGHT_SEGMENTS];\n      var phiStart       = sphere[PROP_PHI_START];\n      var phiLength      = sphere[PROP_PHI_LENGTH];\n      var thetaStart     = sphere[PROP_THETA_START];\n      var thetaLength    = sphere[PROP_THETA_LENGTH];\n      var args = [radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength];\n      return new Sk.builtin.str(SPHERE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, SPHERE_GEOMETRY, []);\n\n  mod[TETRAHEDRON_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_DETAIL = \"detail\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, detail) {\n      radius = numberFromArg(radius,        PROP_RADIUS, TETRAHEDRON_GEOMETRY);\n      detail = numberFromIntegerArg(detail, PROP_DETAIL, TETRAHEDRON_GEOMETRY);\n      self.v = new THREE[TETRAHEDRON_GEOMETRY](radius, detail);\n      self.v.radius = radius; // workaround for THREE not caching radius.\n      self.v.detail = detail; // workaround for THREE not caching detail.\n      self.tp$name = TETRAHEDRON_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_DETAIL: {\n          return Sk.builtin.assk$(self.v[PROP_DETAIL], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + TETRAHEDRON_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var tetrahedron = self.v;\n      var args = {};\n      args[PROP_RADIUS] = tetrahedron[PROP_RADIUS];\n      args[PROP_DETAIL] = tetrahedron[PROP_DETAIL];\n      return new Sk.builtin.str(TETRAHEDRON_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var tetrahedron = self.v;\n      var radius = tetrahedron[PROP_RADIUS];\n      var detail = tetrahedron[PROP_DETAIL];\n      var args = [radius, detail];\n      return new Sk.builtin.str(TETRAHEDRON_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, TETRAHEDRON_GEOMETRY, []);\n\n   mod[TEXT_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, text, parameters) {\n      text = Sk.ffi.remapToJs(text);\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[TEXT_GEOMETRY](text, parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + TEXT_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var text = Sk.ffi.remapToJs(self);\n      var args = {};\n      return new Sk.builtin.str(TEXT_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var text = Sk.ffi.remapToJs(self);\n      var args = [];\n      return new Sk.builtin.str(TEXT_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, TEXT_GEOMETRY, []);\n\n   mod[TORUS_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_TUBE             = \"tube\";\n    var PROP_RADIAL_SEGMENTS  = \"radialSegments\";\n    var PROP_TUBULAR_SEGMENTS = \"tubularSegments\";\n    var PROP_ARC              = \"arc\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, tube, radialSegments, tubularSegments, arc) {\n      radius = numberFromArg(radius,                          PROP_RADIUS,           TORUS_GEOMETRY);\n      tube = numberFromArg(tube,                              PROP_TUBE,             TORUS_GEOMETRY);\n      radialSegments = numberFromIntegerArg(radialSegments,   PROP_RADIAL_SEGMENTS,  TORUS_GEOMETRY);\n      tubularSegments = numberFromIntegerArg(tubularSegments, PROP_TUBULAR_SEGMENTS, TORUS_GEOMETRY);\n      arc = numberFromArg(arc,                                PROP_ARC,              TORUS_GEOMETRY);\n      self.v = new THREE[TORUS_GEOMETRY](radius, tube, radialSegments, tubularSegments, arc);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_TUBE: {\n          return Sk.builtin.assk$(self.v[PROP_TUBE], Sk.builtin.nmber.float$);\n        }\n        case PROP_RADIAL_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIAL_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_TUBULAR_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_TUBULAR_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_ARC: {\n          return Sk.builtin.assk$(self.v[PROP_ARC], Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + TORUS_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var torus = self.v;\n      var args = {};\n      args[PROP_RADIUS] = torus[PROP_RADIUS];\n      args[PROP_TUBE]   = torus[PROP_TUBE];\n      args[PROP_ARC]    = torus[PROP_ARC];\n      return new Sk.builtin.str(TORUS_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var torus = self.v;\n      var radius          = torus[PROP_RADIUS];\n      var tube            = torus[PROP_TUBE];\n      var radialSegments  = torus[PROP_RADIAL_SEGMENTS];\n      var tubularSegments = torus[PROP_TUBULAR_SEGMENTS];\n      var arc             = torus[PROP_ARC];\n      var args = [radius, tube, radialSegments, tubularSegments, arc];\n      return new Sk.builtin.str(TORUS_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, TORUS_GEOMETRY, []);\n\n   mod[GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, geometryPy) {\n      if (isDefined(geometryPy)) {\n        self.v = Sk.ffi.remapToJs(geometryPy);\n        self.tp$name = geometryPy.tp$name;\n      }\n      else {\n        self.v = new THREE[GEOMETRY]();\n        self.tp$name = GEOMETRY;\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(geometryPy, name) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(geometry[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(geometry[PROP_NAME]);\n        }\n        case PROP_VERTICES: {\n          return verticesPy(geometry.vertices);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(geometryPy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      if (isDefined(geometry)) {\n        var args = {};\n        return new Sk.builtin.str(GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + GEOMETRY + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(geometry) {\n      geometry = Sk.ffi.remapToJs(geometry);\n      var args = [];\n      return new Sk.builtin.str(GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, GEOMETRY, []);\n\n  mod[OBJECT_3D] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = OBJECT_3D;\n      self.v = new THREE[OBJECT_3D]();\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(objPy, name) {\n      var obj = Sk.ffi.remapToJs(objPy);\n      switch(name) {\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(obj[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(obj[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return obj[PROP_USE_QUATERNION];\n        }\n        case METHOD_ADD: {\n          return methodAdd(obj);\n        }\n        case METHOD_REMOVE: {\n          return methodRemove(obj);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(obj, name, value) {\n      obj = Sk.ffi.remapToJs(obj);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_POSITION: {\n          obj[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          obj[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          obj[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            obj[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          obj[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          obj[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          obj[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an settable attribute of \" + OBJECT_3D);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(obj) {\n      obj = Sk.ffi.remapToJs(obj);\n      if (isDefined(obj)) {\n        var args = {};\n        return new Sk.builtin.str(OBJECT_3D + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + OBJECT_3D + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(obj) {\n      obj = Sk.ffi.remapToJs(obj);\n      var args = [];\n      return new Sk.builtin.str(OBJECT_3D + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, OBJECT_3D, []);\n\n  mod[AMBIENT_LIGHT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, color) {\n      self.tp$name = AMBIENT_LIGHT;\n      color = Sk.ffi.remapToJs(color);\n      self.v = new THREE[AMBIENT_LIGHT](color);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(lightPy, name) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR]));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(lightPy, name, valuePy) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_COLOR: {\n          light[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an settable attribute of \" + AMBIENT_LIGHT);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      if (isDefined(light)) {\n        var args = {};\n        args[PROP_COLOR] = light[PROP_COLOR];\n        return new Sk.builtin.str(AMBIENT_LIGHT + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + AMBIENT_LIGHT + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      var args = [light[PROP_COLOR]];\n      return new Sk.builtin.str(AMBIENT_LIGHT + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, AMBIENT_LIGHT, []);\n\n  mod[DIRECTIONAL_LIGHT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_INTENSITY = \"intensity\";\n    var PROP_DISTANCE = \"distance\";\n    $loc.__init__ = new Sk.builtin.func(function(self, color, intensity, distance) {\n      self.tp$name = DIRECTIONAL_LIGHT;\n      color = Sk.ffi.remapToJs(color);\n      intensity = Sk.ffi.remapToJs(intensity);\n      distance = Sk.ffi.remapToJs(distance);\n      self.v = new THREE[DIRECTIONAL_LIGHT](color, intensity, distance);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(lightPy, name) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR]));\n        }\n        case PROP_DISTANCE: {\n          return Sk.builtin.nmber(light[PROP_DISTANCE], Sk.builtin.nmber.float$);\n        }\n        case PROP_INTENSITY: {\n          return Sk.builtin.nmber(light[PROP_INTENSITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(light[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(light[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return light[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              light.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return lightPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(light, name, value) {\n      light = Sk.ffi.remapToJs(light);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_COLOR: {\n          light[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_DISTANCE: {\n          if (isNumber(value)) {\n            light[PROP_DISTANCE] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_DISTANCE + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_INTENSITY: {\n          if (isNumber(value)) {\n            light[PROP_INTENSITY] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_INTENSITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_POSITION: {\n          light[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          light[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          light[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            light[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          light[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          light[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          light[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an settable attribute of \" + DIRECTIONAL_LIGHT);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      if (isDefined(light)) {\n        var args = {};\n        args[PROP_COLOR] = light[PROP_COLOR];\n        args[PROP_INTENSITY] = light[PROP_INTENSITY];\n        args[PROP_DISTANCE] = light[PROP_DISTANCE];\n        return new Sk.builtin.str(DIRECTIONAL_LIGHT + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + DIRECTIONAL_LIGHT + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      var args = [light[PROP_COLOR], light[PROP_INTENSITY], light[PROP_DISTANCE]];\n      return new Sk.builtin.str(DIRECTIONAL_LIGHT + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, DIRECTIONAL_LIGHT, []);\n\n  mod[POINT_LIGHT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_INTENSITY = \"intensity\";\n    var PROP_DISTANCE = \"distance\";\n    $loc.__init__ = new Sk.builtin.func(function(self, color, intensity, distance) {\n      self.tp$name = POINT_LIGHT;\n      color = Sk.ffi.remapToJs(color);\n      intensity = Sk.ffi.remapToJs(intensity);\n      distance = Sk.ffi.remapToJs(distance);\n      self.v = new THREE[POINT_LIGHT](color, intensity, distance);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(lightPy, name) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR]));\n        }\n        case PROP_DISTANCE: {\n          return Sk.builtin.nmber(light[PROP_DISTANCE], Sk.builtin.nmber.float$);\n        }\n        case PROP_INTENSITY: {\n          return Sk.builtin.nmber(light[PROP_INTENSITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(light[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(light[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return light[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              light.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return lightPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(light, name, value) {\n      light = Sk.ffi.remapToJs(light);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_COLOR: {\n          light[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_DISTANCE: {\n          if (isNumber(value)) {\n            light[PROP_DISTANCE] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_DISTANCE + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_INTENSITY: {\n          if (isNumber(value)) {\n            light[PROP_INTENSITY] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_INTENSITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_POSITION: {\n          light[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          light[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          light[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            light[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          light[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          light[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          light[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an settable attribute of \" + POINT_LIGHT);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      if (isDefined(light)) {\n        var args = {};\n        args[PROP_COLOR] = light[PROP_COLOR];\n        args[PROP_INTENSITY] = light[PROP_INTENSITY];\n        args[PROP_DISTANCE] = light[PROP_DISTANCE];\n        return new Sk.builtin.str(POINT_LIGHT + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + POINT_LIGHT + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      var args = [light[PROP_COLOR], light[PROP_INTENSITY], light[PROP_DISTANCE]];\n      return new Sk.builtin.str(POINT_LIGHT + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, POINT_LIGHT, []);\n\n  mod[LINE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, geometryPy, materialPy, typePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy)\n      var material = Sk.ffi.remapToJs(materialPy)\n      var type = Sk.ffi.remapToJs(typePy)\n      self.v = new THREE[LINE](geometry, material, type);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(linePy, name) {\n      var line = Sk.ffi.remapToJs(linePy);\n      switch(name) {\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(line[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(line[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return line[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              line.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return linePy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case PROP_TYPE: {\n          return Sk.builtin.nmber(line[PROP_TYPE], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(linePy, name, value) {\n      var line = Sk.ffi.remapToJs(linePy);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_TYPE: {\n          if (isNumber(value)) {\n            line[PROP_TYPE] = value;\n          }\n          else {\n            throw new Error(PROP_TYPE + \" must be either LineStrip or LinePieces\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + LINE);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(LINE);\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(LINE);\n    });\n  }, LINE, []);\n\n  mod[LINE_BASIC_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = LINE_BASIC_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[LINE_BASIC_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(material, name) {\n      material = Sk.ffi.remapToJs(material);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR]));\n        }\n        case PROP_OPACITY: {\n          return Sk.builtin.nmber(material[PROP_OPACITY], Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(material, name, value) {\n      material = Sk.ffi.remapToJs(material);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_COLOR: {\n          if (isColor(value)) {\n            material.color = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_OPACITY + \"' attribute must be a <type '\" + COLOR + \"'>.\");\n          }\n        }\n        break;\n        case PROP_OPACITY: {\n          if (isNumber(value)) {\n            material.opacity = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_OPACITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + LINE_BASIC_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      args[PROP_COLOR] = material[PROP_COLOR];\n      args[PROP_OPACITY] = material[PROP_OPACITY];\n      return new Sk.builtin.str(LINE_BASIC_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = [{}];\n      return new Sk.builtin.str(LINE_BASIC_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, LINE_BASIC_MATERIAL, []);\n\n  mod[MESH] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, geometryPy, materialPy) {\n      self.tp$name = MESH;\n      self.v = new THREE[MESH](Sk.ffi.remapToJs(geometryPy), Sk.ffi.remapToJs(materialPy));\n      self.v[PROP_MASS] = multiVector3(0, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n      self.v[PROP_VELOCITY] = multiVector3(0, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(meshPy, name) {\n      var mesh = Sk.ffi.remapToJs(meshPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(mesh[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_GEOMETRY: {\n          var geometry = mesh[PROP_GEOMETRY];\n          return Sk.misceval.callsim(mod[GEOMETRY], Sk.ffi.referenceToPy(mesh[PROP_GEOMETRY]));\n        }\n        case PROP_MASS: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_MASS]));\n        }\n        case PROP_MATRIX_AUTO_UPDATE: {\n          return mesh[PROP_MATRIX_AUTO_UPDATE];\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(mesh[PROP_NAME]);\n        }\n        case PROP_OVERDRAW: {\n          if (isBoolean(mesh[PROP_OVERDRAW])) {\n            return mesh[PROP_OVERDRAW];\n          }\n          else {\n            return null;\n          }\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(mesh[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(mesh[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return mesh[PROP_USE_QUATERNION];\n        }\n        case PROP_VELOCITY: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_VELOCITY]));\n        }\n        case PROP_VISIBLE: {\n          return mesh[PROP_VISIBLE];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              mesh.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return meshPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case METHOD_SET_GEOMETRY: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_GEOMETRY;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, geometryPy) {\n              var geometry = Sk.ffi.remapToJs(geometryPy);\n              mesh[METHOD_SET_GEOMETRY](geometry);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_GEOMETRY)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_GEOMETRY)\n            })\n          }, METHOD_SET_GEOMETRY, []));\n        }\n        case METHOD_UPDATE_MATRIX: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_UPDATE_MATRIX;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              mesh[METHOD_UPDATE_MATRIX]();\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_UPDATE_MATRIX)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_UPDATE_MATRIX)\n            })\n          }, METHOD_UPDATE_MATRIX, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(mesh, name, value) {\n      mesh = Sk.ffi.remapToJs(mesh);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_MASS: {\n          if (isNumber(value)) {\n            mesh[PROP_MASS] = multiVector3(value, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n          }\n          else {\n            mesh[PROP_MASS] = value;\n          }\n        }\n        break;\n        case PROP_MATRIX_AUTO_UPDATE: {\n          if (isBoolean(value)) {\n            mesh[PROP_MATRIX_AUTO_UPDATE] = value;\n          }\n          else {\n            throw new Error(PROP_MATRIX_AUTO_UPDATE + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_NAME: {\n          if (isString(value)) {\n            mesh[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_OVERDRAW: {\n          if (isBoolean(value)) {\n            mesh[PROP_OVERDRAW] = value;\n          }\n          else if (isNull(value)) {\n            mesh[PROP_OVERDRAW] = null;\n          }\n          else {\n            throw new Error(name + \" must be either Boolean or None\");\n          }\n        }\n        break;\n        case PROP_POSITION: {\n          mesh[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          mesh[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          mesh[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            mesh[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          mesh[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          mesh[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          mesh[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        case PROP_VELOCITY: {\n          mesh[PROP_VELOCITY] = value;\n        }\n        break;\n        case PROP_VISIBLE: {\n          if (isBoolean(value)) {\n            mesh[PROP_VISIBLE] = value;\n          }\n          else {\n            throw new Error(PROP_VISIBLE + \" must be Boolean\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(mesh) {\n      mesh = Sk.ffi.remapToJs(mesh);\n      var args = {};\n      args[PROP_ID] = mesh[PROP_ID];\n      args[PROP_NAME] = mesh[PROP_NAME];\n      return new Sk.builtin.str(MESH + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(mesh) {\n      mesh = Sk.ffi.remapToJs(mesh);\n      var args = [/*mesh[PROP_GEOMETRY], mesh[PROP_MATERIAL]*/];\n      return new Sk.builtin.str(MESH + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH, []);\n\n  mod[MESH_BASIC_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_BASIC_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_BASIC_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(materialPy, name) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(material[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(material[PROP_NAME]);\n        }\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR]));\n        }\n        case PROP_NEEDS_UPDATE: {\n          return material[PROP_NEEDS_UPDATE];\n        }\n        case PROP_OPACITY: {\n          return Sk.builtin.nmber(material[PROP_OPACITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_OVERDRAW: {\n          return material[PROP_OVERDRAW];\n        }\n        case PROP_TRANSPARENT: {\n          return material[PROP_TRANSPARENT];\n        }\n        case PROP_WIREFRAME: {\n          return material[PROP_WIREFRAME];\n        }\n        case PROP_WIREFRAME_LINEWIDTH: {\n          return Sk.builtin.nmber(material[PROP_WIREFRAME_LINEWIDTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_VISIBLE: {\n          return material[PROP_VISIBLE];\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(materialPy, name, valuePy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_COLOR: {\n          material[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_NAME: {\n          if (isString(value)) {\n            material[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_NEEDS_UPDATE: {\n          if (isBoolean(value)) {\n            material[PROP_NEEDS_UPDATE] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_OPACITY: {\n          if (isNumber(value)) {\n            material.opacity = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_OPACITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_OVERDRAW: {\n          if (isBoolean(value)) {\n            material[PROP_OVERDRAW] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_TRANSPARENT: {\n          if (isBoolean(value)) {\n            material[PROP_TRANSPARENT] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_WIREFRAME: {\n          if (isBoolean(value)) {\n            material[PROP_WIREFRAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_WIREFRAME_LINEWIDTH: {\n          if (isNumber(value)) {\n            material[PROP_WIREFRAME_LINEWIDTH] = value;\n          }\n          else {\n            throw new Error(name + \" must be a number\");\n          }\n        }\n        break;\n        case PROP_VISIBLE: {\n          if (isBoolean(value)) {\n            material[PROP_VISIBLE] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_BASIC_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(materialPy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var args = {};\n      args[PROP_COLOR] = material[PROP_COLOR];\n      args[PROP_WIREFRAME] = material[PROP_WIREFRAME];\n      args[PROP_WIREFRAME_LINEWIDTH] = material[PROP_WIREFRAME_LINEWIDTH];\n      return new Sk.builtin.str(MESH_BASIC_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var parameters = {};\n      parameters[PROP_COLOR] = material[PROP_COLOR];\n      parameters[PROP_WIREFRAME] = material[PROP_WIREFRAME];\n      parameters[PROP_WIREFRAME_LINEWIDTH] = material[PROP_WIREFRAME_LINEWIDTH];\n      var args = [parameters];\n      return new Sk.builtin.str(MESH_BASIC_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH_BASIC_MATERIAL, []);\n\n  mod[MESH_LAMBERT_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_LAMBERT_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_LAMBERT_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(materialPy, name) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(material[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR]));\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(material[PROP_NAME]);\n        }\n        case PROP_NEEDS_UPDATE: {\n          return material[PROP_NEEDS_UPDATE];\n        }\n        case PROP_OPACITY: {\n          return Sk.builtin.nmber(material[PROP_OPACITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_OVERDRAW: {\n          return material[PROP_OVERDRAW];\n        }\n        case PROP_TRANSPARENT: {\n          return material[PROP_TRANSPARENT];\n        }\n        case PROP_VISIBLE: {\n          return material[PROP_VISIBLE];\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(materialPy, name, valuePy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_COLOR: {\n          material[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_NAME: {\n          if (isString(value)) {\n            material[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_NEEDS_UPDATE: {\n          if (isBoolean(value)) {\n            material[PROP_NEEDS_UPDATE] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_OPACITY: {\n          if (isNumber(value)) {\n            material.opacity = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_OPACITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_OVERDRAW: {\n          if (isBoolean(value)) {\n            material[PROP_OVERDRAW] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_TRANSPARENT: {\n          if (isBoolean(value)) {\n            material[PROP_TRANSPARENT] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_WIREFRAME: {\n          if (isBoolean(value)) {\n            material[PROP_WIREFRAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_WIREFRAME_LINEWIDTH: {\n          if (isNumber(value)) {\n            material[PROP_WIREFRAME_LINEWIDTH] = value;\n          }\n          else {\n            throw new Error(name + \" must be a number\");\n          }\n        }\n        break;\n        case PROP_VISIBLE: {\n          if (isBoolean(value)) {\n            material[PROP_VISIBLE] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_LAMBERT_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      return new Sk.builtin.str(MESH_LAMBERT_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var parameters = {};\n      parameters[PROP_COLOR] = material[PROP_COLOR];\n      var args = [parameters];\n      return new Sk.builtin.str(MESH_LAMBERT_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH_LAMBERT_MATERIAL, []);\n\n  mod[MESH_NORMAL_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_NORMAL_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_NORMAL_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_NORMAL_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      return new Sk.builtin.str(MESH_NORMAL_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = [{}];\n      return new Sk.builtin.str(MESH_NORMAL_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH_NORMAL_MATERIAL, []);\n\n  mod[MESH_PHONG_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_PHONG_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_PHONG_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_PHONG_MATERIAL);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(materialPy, name, valuePy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_PHONG_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      return new Sk.builtin.str(MESH_PHONG_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = [{}];\n      return new Sk.builtin.str(MESH_PHONG_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH_PHONG_MATERIAL, []);\n\n  if (typeof THREE !== 'undefined') {\n    mod.LineStrip  = Sk.builtin.assk$(THREE.LineStrip,  Sk.builtin.nmber.int$);\n    mod.LinePieces = Sk.builtin.assk$(THREE.LinePieces, Sk.builtin.nmber.int$);\n\n    mod.FlatShading   = Sk.builtin.assk$(THREE.FlatShading,   Sk.builtin.nmber.int$);\n    mod.NoShading     = Sk.builtin.assk$(THREE.NoShading,     Sk.builtin.nmber.int$);\n    mod.SmoothShading = Sk.builtin.assk$(THREE.SmoothShading, Sk.builtin.nmber.int$);\n  }\n\n  mod[SCALAR_3] = new Sk.builtin.func(function(w) {\n    w = Sk.ffi.remapToJs(w);\n    return remapE3ToPy(w, 0, 0, 0, 0, 0, 0, 0);\n  });\n\n  mod[VECTOR_3] = new Sk.builtin.func(function(x, y, z) {\n    x = Sk.ffi.remapToJs(x);\n    y = Sk.ffi.remapToJs(y);\n    z = Sk.ffi.remapToJs(z);\n    return remapE3ToPy(0, x, y, z, 0, 0, 0, 0);\n  });\n\n  mod[BIVECTOR_3] = new Sk.builtin.func(function(xy, yz, zx) {\n    xy = Sk.ffi.remapToJs(xy);\n    yz = Sk.ffi.remapToJs(yz);\n    zx = Sk.ffi.remapToJs(zx);\n    return remapE3ToPy(0, 0, 0, 0, xy, yz, zx, 0);\n  });\n\n  mod[PSEUDOSCALAR_3] = new Sk.builtin.func(function(xyz) {\n    xyz = Sk.ffi.remapToJs(xyz);\n    return remapE3ToPy(0, 0, 0, 0, 0, 0, 0, xyz);\n  });\n\n  return mod;\n}\n", "src/lib/webgl/primitives.js": "// most of this file is from 'tdl'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n\n\n    /**\n     * AttribBuffer manages a TypedArray as an array of vectors.\n     *\n     * @param {number} numComponents Number of components per\n     *     vector.\n     * @param {number|!Array.<number>} numElements Number of vectors or the data.\n     * @param {string} opt_type The type of the TypedArray to\n     *     create. Default = 'Float32Array'.\n     * @param {!Array.<number>} opt_data The data for the array.\n     */\n    var AttribBuffer = function(\n            numComponents, numElements, opt_type) {\n        opt_type = opt_type || 'Float32Array';\n        var type = window[opt_type];\n        if (numElements.length) {\n            this.buffer = new type(numElements);\n            numElements = this.buffer.length / numComponents;\n            this.cursor = numElements;\n        } else {\n            this.buffer = new type(numComponents * numElements);\n            this.cursor = 0;\n        }\n        this.numComponents = numComponents;\n        this.numElements = numElements;\n        this.type = opt_type;\n    };\n\n    AttribBuffer.prototype.stride = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.offset = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.getElement = function(index) {\n        var offset = index * this.numComponents;\n        var value = [];\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            value.push(this.buffer[offset + ii]);\n        }\n        return value;\n    };\n\n    AttribBuffer.prototype.setElement = function(index, value) {\n        var offset = index * this.numComponents;\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            this.buffer[offset + ii] = value[ii];\n        }\n    };\n\n    AttribBuffer.prototype.clone = function() {\n        var copy = new AttribBuffer(\n                this.numComponents, this.numElements, this.type);\n        copy.pushArray(this);\n        return copy;\n    }\n\n    AttribBuffer.prototype.push = function(value) {\n        this.setElement(this.cursor++, value);\n    };\n\n    AttribBuffer.prototype.pushArray = function(array) {\n        //  this.buffer.set(array, this.cursor * this.numComponents);\n        //  this.cursor += array.numElements;\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            this.push(array.getElement(ii));\n        }\n    };\n\n    AttribBuffer.prototype.pushArrayWithOffset =\n    function(array, offset) {\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            var elem = array.getElement(ii);\n            for (var jj = 0; jj < offset.length; ++jj) {\n                elem[jj] += offset[jj];\n            }\n            this.push(elem);\n        }\n    };\n\n    /**\n    * Computes the extents\n    * @param {!AttribBuffer} positions The positions\n    * @return {!{min: !tdl.math.Vector3, max:!tdl.math.Vector3}}\n    *     The min and max extents.\n    */\n    AttribBuffer.prototype.computeExtents = function() {\n        var numElements = this.numElements;\n        var numComponents = this.numComponents;\n        var minExtent = this.getElement(0);\n        var maxExtent = this.getElement(0);\n        for (var ii = 1; ii < numElements; ++ii) {\n            var element = this.getElement(ii);\n            for (var jj = 0; jj < numComponents; ++jj) {\n                minExtent[jj] = Math.min(minExtent[jj], element[jj]);\n                maxExtent[jj] = Math.max(maxExtent[jj], element[jj]);\n            }\n        }\n        return {min: minExtent, max: maxExtent};\n    };\n\n\n    /**\n     * Creates the vertices and indices for a cube. The\n     * cube will be created around the origin. (-size / 2, size / 2)\n     *\n     * @param {number} size Width, height and depth of the cube.\n     * @return {!Object.<string, !tdl.primitives.AttribBuffer>} The\n     *         created plane vertices.\n     */\n    mod.createCube = new Sk.builtin.func(function(size)\n            {\n                var CUBE_FACE_INDICES_ = [\n                    [3, 7, 5, 1],\n                    [0, 4, 6, 2],\n                    [6, 7, 3, 2],\n                    [0, 1, 5, 4],\n                    [5, 7, 6, 4],\n                    [2, 3, 1, 0]\n                ];\n\n                var k = size / 2;\n\n                var cornerVertices = [\n                        [-k, -k, -k],\n                        [+k, -k, -k],\n                        [-k, +k, -k],\n                        [+k, +k, -k],\n                        [-k, -k, +k],\n                        [+k, -k, +k],\n                        [-k, +k, +k],\n                        [+k, +k, +k]\n                    ];\n\n                var faceNormals = [\n                        [+1, +0, +0],\n                        [-1, +0, +0],\n                        [+0, +1, +0],\n                        [+0, -1, +0],\n                        [+0, +0, +1],\n                        [+0, +0, -1]\n                    ];\n\n                var uvCoords = [\n                        [0, 0],\n                        [1, 0],\n                        [1, 1],\n                        [0, 1]\n                    ];\n\n                var numVertices = 6 * 4;\n                var positions = new AttribBuffer(3, numVertices);\n                var normals = new AttribBuffer(3, numVertices);\n                var texCoords = new AttribBuffer(2, numVertices);\n                var indices = new AttribBuffer(3, 6 * 2, 'Uint16Array');\n\n                for (var f = 0; f < 6; ++f) {\n                    var faceIndices = CUBE_FACE_INDICES_[f];\n                    for (var v = 0; v < 4; ++v) {\n                        var position = cornerVertices[faceIndices[v]];\n                        var normal = faceNormals[f];\n                        var uv = uvCoords[v];\n\n                        // Each face needs all four vertices because the normals and texture\n                        // coordinates are not all the same.\n                        positions.push(position);\n                        normals.push(normal);\n                        texCoords.push(uv);\n\n                    }\n                    // Two triangles make a square face.\n                    var offset = 4 * f;\n                    indices.push([offset + 0, offset + 1, offset + 2]);\n                    indices.push([offset + 0, offset + 2, offset + 3]);\n                }\n\n                return {\n                        position: positions,\n                        normal: normals,\n                        texCoord: texCoords,\n                        indices: indices\n                };\n            });\n\n    return mod;\n};\n", "src/lib/document/__init__.js": "var $builtinmodule = function(name) {\n    var mod = {};\n\n    mod.getElementById = new Sk.builtin.func(function(id) {\n        var result = document.getElementById(id.v);\n        if (result) {\n            return Sk.misceval.callsim(mod.Element,result);\n        }\n        return Sk.builtin.none.none$;\n    });\n\n    mod.createElement = new Sk.builtin.func(function(eName) {\n            var r = document.createElement(eName.v);\n            if (r) {\n                return Sk.misceval.callsim(mod.Element,r);\n            }\n        });\n\n\n    mod.getElementsByTagName = new Sk.builtin.func(function(tag) {\n        var r = document.getElementsByTagName(tag.v)\n        var reslist = [];\n        for (var i = r.length - 1; i >= 0; i--) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]))\n        }\n        return new Sk.builtin.list(reslist)\n    });\n\n    mod.getElementsByClassName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByClassName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n    \n    mod.getElementsByName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n        \n    mod.currentDiv = new Sk.builtin.func(function() {\n        if (Sk.divid !== undefined) {\n            return new Sk.builtin.str(Sk.divid)\n        }\n        else {\n            throw new Sk.builtin.AttributeError(\"There is no value set for divid\");\n        }\n    })\n    var elementClass = function($gbl, $loc) {\n        /*\n            Notes:  self['$d'] is the dictionary used by the GenericGetAttr mechanism for an object.\n                    for various reasons  if you create a class in Javascript and have self.xxxx instance\n                    variables, you cannot say instance.xxx and get the value of the instance variable unless \n                    it is stored in the self['$d'] object.  This seems like a duplication of storage to me\n                    but that is how it works right now  (5/2013)\n\n                    Writing your own __getattr__ is also an option but this gets very tricky when an attr is \n                    a method...\n        */\n        $loc.__init__ = new Sk.builtin.func(function(self,elem) {\n            self.v = elem\n            self.innerHTML = elem.innerHTML\n            self.innerText = elem.innerText\n            if (elem.value !== undefined) {\n                self.value = elem.value\n                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('value'), new Sk.builtin.str(self.value))                \n            }\n\n            if (elem.checked !== undefined) {\n                self.checked = elem.checked\n                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('checked'), new Sk.builtin.str(self.checked))                \n            }\n\n            Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('innerHTML'), new Sk.builtin.str(self.innerHTML))\n            Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('innerText'), new Sk.builtin.str(self.innerText))            \n\n        })\n\n        $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n        $loc.__setattr__ = new Sk.builtin.func(function(self,key,value) {\n            if (key === 'innerHTML') {\n                self.innerHTML = value\n                self.v.innerHTML = value.v\n                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('innerHTML'), value)                \n            }\n            if (key === 'innerText') {\n                self.innerText = value\n                self.v.innerText = value.v\n                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str('innerText'), value)            \n            }\n        });\n\n\n        $loc.appendChild = new Sk.builtin.func(function(self,ch) {\n            self.v.appendChild(ch.v);\n        });\n\n        $loc.removeChild = new Sk.builtin.func(function(self,node) {\n            self.v.removeChild(node.v)\n        })\n\n        // getCSS\n                    \n        $loc.getCSS = new Sk.builtin.func(function(self,key) {\n            return new Sk.builtin.str(self.v.style[key.v]);\n        });\n    \n\n        $loc.setCSS = new Sk.builtin.func(function(self,attr,value) {\n            self.v.style[attr.v] = value.v\n\n        })\n\n        $loc.getAttribute = new Sk.builtin.func(function(self,key) {\n            var res = self.v.getAttribute(key.v)\n            if (res) {\n                return new Sk.builtin.str(res)\n            } else {\n                return Sk.builtin.none.none$;\n            }\n        });\n\n        $loc.setAttribute = new Sk.builtin.func(function(self,attr,value) {\n                self.v.setAttribute(attr.v,value.v)\n        });\n            \n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            console.log(self.v.tagName);\n            return new Sk.builtin.str(self.v.tagName)\n        })\n\n        $loc.__repr__ = new Sk.builtin.func(function(self) {\n            return new Sk.builtin.str('[DOM Element]')\n        })\n\n    \n    };\n\n    mod.Element = Sk.misceval.buildClass(mod,elementClass,'Element', []);\n\n    return mod;\n\n}   ", "src/lib/re/__init__.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // Constants (mostly unsupported)\n    mod.I = 2;\n    mod.IGNORECASE = 2;\n    // mod.L = 4;\n    // mod.LOCALE = 4;\n    mod.M = 8;\n    mod.MULTILINE = 8;\n    // mod.S = 16;\n    // mod.DOTALL = 16;\n    // mod.U = 32;\n    // mod.UNICODE = 32;\n    // mod.X = 64;\n    // mod.VERBOSE = 64;\n\n    var validGroups = [\"(?:\", \"(?=\", \"(?!\"];\n\n    var convert = function(pattern) {\n        var newpattern;\n        var match;\n        var i;\n\n        // Look for disallowed constructs\n        match = pattern.match(/\\(\\?./g);\n        if (match) {\n            for (i=0; i<match.length; i++) {\n                if (validGroups.indexOf(match[i]) == -1) {\n                    throw new Sk.builtin.ValueError(\"Disallowed group in pattern: '\"\n                                                    + match[i] + \"'\");\n                };\n            };\n        };\n\n        newpattern = pattern.replace('/\\\\/g', '\\\\\\\\');\n        newpattern = pattern.replace(/([^\\\\]){,(?![^\\[]*\\])/g, '$1{0,');\n\n        return newpattern;\n    };\n\n    var getFlags = function(flags) {\n        var jsflags = \"g\";\n        if ((flags & mod.IGNORECASE) == mod.IGNORECASE) {\n            jsflags += \"i\";\n        };\n        if ((flags & mod.MULTILINE) == mod.MULTILINE) {\n            jsflags += \"m\";\n        }; \n        return jsflags;\n    };\n\n    mod.split = Sk.nativejs.func(function split(pattern, string, maxsplit, flags) {\n        Sk.builtin.pyCheckArgs(\"split\", arguments, 2, 4);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        };\n        if (maxsplit === undefined) {\n            maxsplit = 0;\n        };\n        if (!Sk.builtin.checkNumber(maxsplit)) {\n            throw new Sk.builtin.TypeError(\"maxsplit must be a number\");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        };\n\n\tmaxsplit = Sk.builtin.asnum$(maxsplit);\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print(\"Pat: \" + pat);\n        //print(\"Str: \" + str);\n\n        var captured = !(pat.match(/^\\(.*\\)$/) === null);\n        //print(\"Captured: \", captured);\n\n        var jsflags = getFlags(flags);\n        //print(\"Flags: \", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n        var result = [];\n        var match;\n        var index = 0;\n        var splits = 0;\n        while ((match = regex.exec(str)) != null) {\n            //print(\"Matched '\" + match[0] + \"' at position \" + match.index + \n            //      \"; next search at \" + regex.lastIndex);\n            if (match.index === regex.lastIndex) {\n                // empty match\n                break;\n            };\n            result.push(new Sk.builtin.str(str.substring(index, match.index)));\n            if (captured) {\n                // Add matching pattern, too\n                result.push(new Sk.builtin.str(match[0]));\n            };\n            index = regex.lastIndex;\n            splits += 1;\n            if (maxsplit && (splits >= maxsplit)) {\n                break;\n            };\n        };\n        result.push(new Sk.builtin.str(str.substring(index)));\n\n        return new Sk.builtin.list(result);\n    });\n\n    mod.findall = Sk.nativejs.func(function findall(pattern, string, flags) {\n        Sk.builtin.pyCheckArgs(\"findall\", arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        };\n\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print(\"Pat: \" + pat);\n        //print(\"Str: \" + str);\n\n        var jsflags = getFlags(flags);\n        //print(\"Flags: \", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n\tvar newline_at_end = new RegExp(/\\n$/);\n\tif (str.match(newline_at_end)) {\n\t    str = str.slice(0,-1);\n\t}\n\n        var result = [];\n        var match;\n        while ((match = regex.exec(str)) != null) {\n            //print(\"Matched '\" + match[0] + \"' at position \" + match.index + \n            //      \"; next search at \" + regex.lastIndex);\n            // print(\"match: \" + JSON.stringify(match));\n            if (match.length < 2) {\n                result.push(new Sk.builtin.str(match[0]));\n            } else if (match.length == 2) {\n                result.push(new Sk.builtin.str(match[1]));\n            } else {\n                var groups = [];\n                for (var i=1; i<match.length; i++) {\n                    groups.push(new Sk.builtin.str(match[i]));  \n                };\n                result.push(new Sk.builtin.tuple(groups));\n            };\n            if (match.index === regex.lastIndex) {\n                regex.lastIndex += 1;\n            };\n        };\n\n        return new Sk.builtin.list(result);\n    });\n\n\n    var matchobj = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,thematch, pattern, string) {\n            self.thematch = thematch;\n\t    self.re = pattern;\n\t    self.string = string;\n        });\n\n\t$loc.groups = new Sk.builtin.func(function(self) {\n\t    return new Sk.builtin.tuple(self.thematch.v.slice(1))\n\t});\n\n\t$loc.group = new Sk.builtin.func(function(self,grpnum) {\n\t\tgrpnum = Sk.builtin.asnum$(grpnum);\n\t    if(grpnum >= self.thematch.v.length) {\n\t\tthrow new Sk.builtin.IndexError(\"Index out of range: \" + grpnum);\n\t\t}\n\t    return self.thematch.v[grpnum]\n\t});\n\n    }\n\n    mod.MatchObject = Sk.misceval.buildClass(mod, matchobj, 'MatchObject', []);\n\n    // Internal function to return a Python list of strings \n    // From a JS regular expression string\n    mod._findre = function(res, string) {\n\tres = res.replace(/([^\\\\]){,(?![^\\[]*\\])/g, '$1{0,');\n        var re = eval(res);\n\tvar patt = new RegExp('\\n$');\n\tif (string.v.match(patt))\n\t    var matches = string.v.slice(0,-1).match(re);\n\telse\n            var matches = string.v.match(re);\n        retval = new Sk.builtin.list();\n        if ( matches == null ) return retval;\n        for (var i = 0; i < matches.length; ++i) {\n            var sitem = new Sk.builtin.str(matches[i]);\n            retval.v.push(sitem);\n        }\n        return retval;\n    }\n\n    mod.search = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs('search', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        };\n        var res = \"/\"+pattern.v.replace(/\\//g,\"\\\\/\")+\"/\";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    mod.match = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs('match', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError(\"pattern must be a string\");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError(\"string must be a string\");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError(\"flags must be a number\");\n        };\n        var res = \"/^\"+pattern.v.replace(/\\//g,\"\\\\/\")+\"/\";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    return mod;\n}\n", "src/lib/urllib/__init__.js": "var $builtinmodule = function(name)\n{\n  var urllib = {};\n\n  return urllib;\n};\n", "src/lib/random/__init__.js": "\n/*\n  I've wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace\n  so it's better encapsulated. Now you can have multiple random number generators\n  and they won't stomp all over eachother's state.\n  \n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n  \n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n  \n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/* \n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n \n   Before using, initialize the state by using init_genrand(seed)  \n   or init_by_array(init_key, key_length).\n \n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.                          \n \n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n \n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n \n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n \n     3. The names of its contributors may not be used to endorse or promote \n        products derived from this software without specific prior written \n        permission.\n \n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n \n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n  if (seed == undefined) {\n    seed = new Date().getTime();\n  } \n  /* Period parameters */  \n  this.N = 624;\n  this.M = 397;\n  this.MATRIX_A = 0x9908b0df;   /* constant vector a */\n  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n \n  this.mt = new Array(this.N); /* the array for the state vector */\n  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n  this.init_genrand(seed);\n}  \n \n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function(s) {\n  this.mt[0] = s >>> 0;\n  for (this.mti=1; this.mti<this.N; this.mti++) {\n      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n  + this.mti;\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      this.mt[this.mti] >>>= 0;\n      /* for >32 bit machines */\n  }\n}\n \n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n  var i, j, k;\n  this.init_genrand(19650218);\n  i=1; j=0;\n  k = (this.N>key_length ? this.N : key_length);\n  for (; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n      + init_key[j] + j; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++; j++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n    if (j>=key_length) j=0;\n  }\n  for (k=this.N-1; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n      - i; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n  }\n\n  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */ \n}\n \n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function() {\n  var y;\n  var mag01 = new Array(0x0, this.MATRIX_A);\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (this.mti >= this.N) { /* generate N words at one time */\n    var kk;\n\n    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */\n      this.init_genrand(5489); /* a default initial seed is used */\n\n    for (kk=0;kk<this.N-this.M;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    for (;kk<this.N-1;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n    this.mti = 0;\n  }\n\n  y = this.mt[this.mti++];\n\n  /* Tempering */\n  y ^= (y >>> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >>> 18);\n\n  return y >>> 0;\n}\n \n/* generates a random number on [0,0x7fffffff]-interval */\nMersenneTwister.prototype.genrand_int31 = function() {\n  return (this.genrand_int32()>>>1);\n}\n \n/* generates a random number on [0,1]-real-interval */\nMersenneTwister.prototype.genrand_real1 = function() {\n  return this.genrand_int32()*(1.0/4294967295.0); \n  /* divided by 2^32-1 */ \n}\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n  return this.genrand_int32()*(1.0/4294967296.0); \n  /* divided by 2^32 */\n}\n \n/* generates a random number on (0,1)-real-interval */\nMersenneTwister.prototype.genrand_real3 = function() {\n  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0); \n  /* divided by 2^32 */\n}\n \n/* generates a random number on [0,1) with 53-bit resolution*/\nMersenneTwister.prototype.genrand_res53 = function() { \n  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6; \n  return(a*67108864.0+b)*(1.0/9007199254740992.0); \n} \n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n\n\nvar $builtinmodule = function(name)\n{\n\n    var mod = {};\n\n    var myGenerator = new MersenneTwister();\n\n    mod.seed = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"seed\", arguments, 0, 1);\n\tx = Sk.builtin.asnum$(x);\n\n        if (arguments.length > 0)\n            myGenerator = new MersenneTwister(x);\n        else\n            myGenerator = new MersenneTwister();\n\n\treturn Sk.builtin.none.none$;\n    });\n\n    mod.random = new Sk.builtin.func(function() {\n        Sk.builtin.pyCheckArgs(\"random\", arguments, 0, 0);\n\n\treturn new Sk.builtin.nmber(myGenerator.genrand_res53(), Sk.builtin.nmber.float$);\n    });\n\n    var toInt = function(num) {\n        return num | 0;\n    };\n\n    var randrange = function(start, stop, step) {\n        // Ported from CPython 2.7\n        var width, n, ret;\n\n        if (!Sk.builtin.checkInt(start)) {\n            throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");\n        };\n\n        if (stop === undefined) {\n            // Random in [0, start)\n            return toInt(myGenerator.genrand_res53() * start);\n        };\n\n        if (!Sk.builtin.checkInt(stop)) {\n            throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");\n        };\n\n        if (step === undefined) {\n            step = 1;\n        };\n\n        width = stop - start;\n\n        if ((step == 1) && (width > 0)) {\n            // Random in [start, stop), must use toInt on product for correct results with negative ranges\n            ret = start + toInt(myGenerator.genrand_res53() * width);\n\t    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n        };\n\n        if (step == 1) {\n            throw new Sk.builtin.ValueError(\"empty range for randrange() (\" + start + \", \" + stop + \", \" + width + \")\");\n        };\n\n        if (!Sk.builtin.checkInt(step)) {\n            throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");\n        };\n\n        if (step > 0) {\n            n = toInt((width + step - 1) / step);\n        } else if (step < 0) {\n            n = toInt((width + step + 1) / step);\n        } else {\n            throw new Sk.builtin.ValueError(\"zero step for randrange()\");\n        };\n\n        if (n <= 0) {\n            throw new Sk.builtin.ValueError(\"empty range for randrange()\");\n        };\n\n        // Random in range(start, stop, step)\n        ret = start + (step * toInt(myGenerator.genrand_res53() * n));\n\treturn new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n    };\n\n    mod.randint = new Sk.builtin.func(function(a, b) {\n        Sk.builtin.pyCheckArgs(\"randint\", arguments, 2, 2);\n\n\ta = Sk.builtin.asnum$(a);\n\tb = Sk.builtin.asnum$(b);\n        return randrange(a, b+1);\n    });\n\n    mod.randrange = new Sk.builtin.func(function(start, stop, step) {\n        Sk.builtin.pyCheckArgs(\"randrange\", arguments, 1, 3);\n\n\tstart = Sk.builtin.asnum$(start);\n\tstop = Sk.builtin.asnum$(stop);\n\tstep = Sk.builtin.asnum$(step);\n        return randrange(start, stop, step);\n    });\n\n    mod.choice = new Sk.builtin.func(function(seq) {\n        Sk.builtin.pyCheckArgs(\"choice\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"seq\", \"sequence\", Sk.builtin.checkSequence(seq));\n\n        if (seq.sq$length !== undefined) {\n            var r = toInt(myGenerator.genrand_res53() * seq.sq$length());\n            return seq.mp$subscript(r);\n        } else {\n            throw new Sk.builtin.TypeError(\"object has no length\");\n        }\n    });\n\n    mod.shuffle = new Sk.builtin.func(function(x) {\n        Sk.builtin.pyCheckArgs(\"shuffle\", arguments, 1, 1);\n        Sk.builtin.pyCheckType(\"x\", \"sequence\", Sk.builtin.checkSequence(x));\n\n        if (x.sq$length !== undefined) {\n            if (x.mp$ass_subscript !== undefined) {\n                for (var i = x.sq$length() - 1; i > 0; i -= 1) {\n                    var r = toInt(myGenerator.genrand_res53() * (i + 1));\n                    var tmp = x.mp$subscript(r);\n                    x.mp$ass_subscript(r, x.mp$subscript(i));\n                    x.mp$ass_subscript(i, tmp);\n                };\n            } else {\n                throw new Sk.builtin.TypeError(\"object is immutable\");\n            };\n        } else {\n            throw new Sk.builtin.TypeError(\"object has no length\");\n        };        \n\n\treturn Sk.builtin.none.none$;\n    });\n\n    return mod;\n}", "src/lib/test/__init__.py": "__author__ = 'bmiller'\n\ndef testEqual(actual, expected):\n    if type(expected) == type(1):\n        if actual == expected:\n            print('Pass')\n            return True\n    elif type(expected) == type(1.11):\n        if abs(actual-expected) < 0.00001:\n            print('Pass')\n            return True\n    else:\n        if actual == expected:\n            print('Pass')\n            return True\n    print('Test Failed: expected ' + str(expected) + ' but got ' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n", "src/builtin/this.py": "s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint \"\".join([d.get(c, c) for c in s])\n", "src/lib/e2ga/__init__.js": "/**\n * Geometric Algebra (e2ga) module.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n  var EUCLIDEAN_2    = \"Euclidean2\";\n\n  var PROP_W         = \"w\";\n  var PROP_X         = \"x\";\n  var PROP_Y         = \"y\";\n  var PROP_XY        = \"xy\";\n  var METHOD_CLONE   = \"clone\";\n  var METHOD_LENGTH  = \"length\";\n\n  var mod = {};\n\n  function isNumber(x)    { return typeof x === 'number'; }\n\n  function remapE2ToPy(x00, x01, x10, x11) {\n    return Sk.misceval.callsim(mod[EUCLIDEAN_2],\n      Sk.builtin.assk$(x00, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x01, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x10, Sk.builtin.nmber.float$),\n      Sk.builtin.assk$(x11, Sk.builtin.nmber.float$));\n  }\n\n  function stringFromCoordinates(coordinates, labels, multiplier) {\n    var append, i, sb, str, _i, _ref;\n    sb = [];\n    append = function(number, label) {\n      var n;\n      if (number !== 0) {\n        if (number >= 0) {\n          if (sb.length > 0) {\n            sb.push(\"+\");\n          }\n        } else {\n          sb.push(\"-\");\n        }\n        n = Math.abs(number);\n        if (n === 1) {\n          return sb.push(label);\n        } else {\n          sb.push(n.toString());\n          if (label !== \"1\") {\n            sb.push(multiplier);\n            return sb.push(label);\n          }\n        }\n      }\n    };\n    for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n      append(coordinates[i], labels[i]);\n    }\n    if (sb.length > 0) {\n      str = sb.join(\"\");\n    } else {\n      str = \"0\";\n    }\n    return str;\n  }\n\n  function divide(a00, a01, a10, a11, b00, b01, b10, b11, x) {\n    // r = ~b\n    var r00 = +b00;\n    var r01 = +b01;\n    var r10 = +b10;\n    var r11 = -b11;\n    // m = b * r\n    var m00 = b00 * r00 + b01 * r01 + b10 * r10 - b11 * r11;\n    var m01 = 0;\n    var m10 = 0;\n    var m11 = 0;\n    // c = cliffordConjugate(m)\n    var c00 = +m00;\n    var c01 = -m01;\n    var c10 = -m10;\n    var c11 = -m11;\n    // s = r * c\n    var s00 = r00 * c00 + r01 * c01 + r10 * c10 - r11 * c11;\n    var s01 = r00 * c01 + r01 * c00 - r10 * c11 + r11 * c10;\n    var s10 = r00 * c10 + r01 * c11 + r10 * c00 - r11 * c01;\n    var s11 = r00 * c11 + r01 * c10 - r10 * c01 + r11 * c00;\n    // k = b * s\n    var k00 = b00 * s00 + b01 * s01 + b10 * s10 - b11 * s11;\n    // i = inverse(b)\n    var i00 = s00/k00;\n    var i01 = s01/k00;\n    var i10 = s10/k00;\n    var i11 = s11/k00;\n    // x = a * inverse(b)\n    var x00 = a00 * i00 + a01 * i01 + a10 * i10 - a11 * i11;\n    var x01 = a00 * i01 + a01 * i00 - a10 * i11 + a11 * i10;\n    var x10 = a00 * i10 + a01 * i11 + a10 * i00 - a11 * i01;\n    var x11 = a00 * i11 + a01 * i10 - a10 * i01 + a11 * i00;\n    if (typeof x !== 'undefined') {\n      x[0] = x00;\n      x[1] = x01;\n      x[2] = x10;\n      x[3] = x11;\n    }\n    else {\n      return remapE2ToPy(x00, x01, x10, x11);\n    }\n  }\n\n  mod[EUCLIDEAN_2] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, x00, x01, x10, x11) {\n      x00 = Sk.ffi.remapToJs(x00);\n      x01 = Sk.ffi.remapToJs(x01);\n      x10 = Sk.ffi.remapToJs(x10);\n      x11 = Sk.ffi.remapToJs(x11);\n      self.tp$name = EUCLIDEAN_2;\n      self.v = [x00, x01, x10, x11];\n    });\n    $loc.__add__ = new Sk.builtin.func(function(lhs, rhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(rhs)) {\n        return remapE2ToPy(lhs[0] + rhs, lhs[1], lhs[2], lhs[3]);\n      }\n      else {\n        return remapE2ToPy(lhs[0] + rhs[0], lhs[1] + rhs[1], lhs[2] + rhs[2], lhs[3] + rhs[3]);\n      }\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs + rhs[0], rhs[1], rhs[2], rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" + \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] += other;\n        return selfPy;\n      }\n      else {\n        self[0] += other[0];\n        self[1] += other[1];\n        self[2] += other[2];\n        self[3] += other[3];\n        return selfPy;\n      }\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(lhs, rhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(rhs)) {\n        return remapE2ToPy(lhs[0] - rhs, lhs[1], lhs[2], lhs[3]);\n      }\n      else {\n        return remapE2ToPy(lhs[0] - rhs[0], lhs[1] - rhs[1], lhs[2] - rhs[2], lhs[3] - rhs[3]);\n      }\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs - rhs[0], -rhs[1], -rhs[2], -rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" - \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] -= other;\n        return selfPy;\n      }\n      else {\n        self[0] -= other[0];\n        self[1] -= other[1];\n        self[2] -= other[2];\n        self[3] -= other[3];\n        return selfPy;\n      }\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE2ToPy(a[0] * b, a[1] * b, a[2] * b, a[3] * b);\n      }\n      else {\n        var a00 = a[0];\n        var a01 = a[1];\n        var a10 = a[2];\n        var a11 = a[3];\n        var b00 = b[0];\n        var b01 = b[1];\n        var b10 = b[2];\n        var b11 = b[3];\n        var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        var x01 = a00 * b01 + a01 * b00 - a10 * b11 + a11 * b10;\n        var x10 = a00 * b10 + a01 * b11 + a10 * b00 - a11 * b01;\n        var x11 = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;\n        return remapE2ToPy(x00, x01, x10, x11);\n      }\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs * rhs[0], lhs * rhs[1], lhs * rhs[2], lhs * rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" * \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] *= other;\n        self[1] *= other;\n        self[2] *= other;\n        self[3] *= other;\n        return selfPy;\n      }\n      else {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other[0];\n        var b01 = other[1];\n        var b10 = other[2];\n        var b11 = other[3];\n        self[0] = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        self[1] = a00 * b01 + a01 * b00 - a10 * b11 + a11 * b10;\n        self[2] = a00 * b10 + a01 * b11 + a10 * b00 - a11 * b01;\n        self[3] = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;\n        return selfPy;\n      }\n    });\n    $loc.__div__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return divide(a[0], a[1], a[2], a[3], b, 0, 0, 0);\n      }\n      else {\n        return divide(a[0], a[1], a[2], a[3], b[0], b[1], b[2], b[3]);\n      }\n    });\n    $loc.__rdiv__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return divide(lhs, 0, 0, 0, rhs[0], rhs[1], rhs[2], rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" / \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__idiv__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        divide(self[0], self[1], self[2], self[3], other, 0, 0, 0, self);\n        return selfPy;\n      }\n      else {\n        divide(self[0], self[1], self[2], self[3], other[0], other[1], other[2], other[3], self);\n        return selfPy;\n      }\n    });\n    $loc.__xor__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE2ToPy(a[0] * b, a[1] * b, a[2] * b, a[3] * b);\n      }\n      else {\n        var a00 = a[0];\n        var a01 = a[1];\n        var a10 = a[2];\n        var a11 = a[3];\n        var b00 = b[0];\n        var b01 = b[1];\n        var b10 = b[2];\n        var b11 = b[3];\n        var x00 = a00 * b00;\n        var x01 = a00 * b01 + a01 * b00;\n        var x10 = a00 * b10             + a10 * b00;\n        var x11 = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;\n        return remapE2ToPy(x00, x01, x10, x11);\n      }\n    });\n    $loc.__rxor__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs * rhs[0], lhs * rhs[1], lhs * rhs[2], lhs * rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" ^ \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__ixor__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] *= other;\n        self[1] *= other;\n        self[2] *= other;\n        self[3] *= other;\n        return selfPy;\n      }\n      else {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other[0];\n        var b01 = other[1];\n        var b10 = other[2];\n        var b11 = other[3];\n        self[0] = a00 * b00;\n        self[1] = a00 * b01 + a01 * b00;\n        self[2] = a00 * b10             + a10 * b00;\n        self[3] = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;\n        return selfPy;\n      }\n    });\n    $loc.__lshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE2ToPy(a[0] * b, 0, 0, 0);\n      }\n      else {\n        var a00 = a[0];\n        var a01 = a[1];\n        var a10 = a[2];\n        var a11 = a[3];\n        var b00 = b[0];\n        var b01 = b[1];\n        var b10 = b[2];\n        var b11 = b[3];\n        var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        var x01 = a00 * b01             - a10 * b11;\n        var x10 = a00 * b10 + a01 * b11;\n        var x11 = a00 * b11;\n        return remapE2ToPy(x00, x01, x10, x11);\n      }\n    });\n    $loc.__rlshift__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs * rhs[0], lhs * rhs[1], lhs * rhs[2], lhs * rhs[3]);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" << \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__ilshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self[0] *= other;\n        self[1] = 0;\n        self[2] = 0;\n        self[3] = 0;\n        return selfPy;\n      }\n      else {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other[0];\n        var b01 = other[1];\n        var b10 = other[2];\n        var b11 = other[3];\n        self[0] = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        self[1] = a00 * b01             - a10 * b11;\n        self[2] = a00 * b10 + a01 * b11;\n        self[3] = a00 * b11;\n        return selfPy;\n      }\n    });\n    $loc.__rshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE2ToPy(a[0] * b, -a[1] * b, -a[2] * b, a[3] * b);\n      }\n      else {\n        var a00 = a[0];\n        var a01 = a[1];\n        var a10 = a[2];\n        var a11 = a[3];\n        var b00 = b[0];\n        var b01 = b[1];\n        var b10 = b[2];\n        var b11 = b[3];\n        var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        var x01 =           + a01 * b00             + a11 * b10;\n        var x10 =                       + a10 * b00 - a11 * b01;\n        var x11 =                                     a11 * b00;\n        return remapE2ToPy(x00, x01, x10, x11);\n      }\n    });\n    $loc.__rrshift__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return remapE2ToPy(lhs * rhs[0], 0, 0, 0);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" >> \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__irshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other;\n        var b01 = 0;\n        var b10 = 0;\n        var b11 = 0;\n        self[0] *=  other;\n        self[1] *= -other;\n        self[2] *= -other;\n        self[3] *=  other;\n        return selfPy;\n      }\n      else {\n        var a00 = self[0];\n        var a01 = self[1];\n        var a10 = self[2];\n        var a11 = self[3];\n        var b00 = other[0];\n        var b01 = other[1];\n        var b10 = other[2];\n        var b11 = other[3];\n        self[0] = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;\n        self[1] =           + a01 * b00             + a11 * b10;\n        self[2] =                       + a10 * b00 - a11 * b01;\n        self[3] =                                     a11 * b00;\n        return selfPy;\n      }\n    });\n    $loc.nb$negative = function() {\n      var self = Sk.ffi.remapToJs(this);\n      return remapE2ToPy(-self[0], -self[1], -self[2], -self[3]);\n    };\n    $loc.nb$positive = function() {\n      return this;\n    };\n    $loc.nb$invert = function() {\n      var self = Sk.ffi.remapToJs(this);\n      return remapE2ToPy(self[0], self[1], self[2], -self[3]);\n    };\n    $loc.__getitem__ = new Sk.builtin.func(function(mv, index) {\n      mv = Sk.ffi.remapToJs(mv);\n      index = Sk.builtin.asnum$(index);\n      switch(index) {\n        case 0: {\n          return remapE2ToPy(mv[0], 0, 0, 0);\n        }\n        case 1: {\n          return remapE2ToPy(0, mv[1], mv[2], 0);\n        }\n        case 2: {\n          return remapE2ToPy(0, 0, 0, mv[3]);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      return new Sk.builtin.str(EUCLIDEAN_2 + \"(\" + mv.join(\", \") + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      if (typeof mv !== 'undefined') {\n        return new Sk.builtin.str(stringFromCoordinates([mv[0], mv[1], mv[2], mv[3]], [\"1\", \"i\", \"j\", \"I\"], \"*\"));\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + EUCLIDEAN_2 + \"'>\");\n      }\n    });\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return (a[0] === b[0]) && (a[1] === b[1]) && (a[2] === b[2]) && (a[3] === b[3]);\n    });\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return (a[0] !== b[0]) || (a[1] !== b[1]) || (a[2] !== b[2]) || (a[3] !== b[3]);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(mvPy, name) {\n      var mv = Sk.ffi.remapToJs(mvPy);\n      switch(name) {\n        case PROP_W: {\n          return Sk.builtin.assk$(mv[0], Sk.builtin.nmber.float$);\n        }\n        break;\n        case PROP_X: {\n          return Sk.builtin.assk$(mv[1], Sk.builtin.nmber.float$);\n        }\n        break;\n        case PROP_Y: {\n          return Sk.builtin.assk$(mv[2], Sk.builtin.nmber.float$);\n        }\n        break;\n        case PROP_XY: {\n          return Sk.builtin.assk$(mv[3], Sk.builtin.nmber.float$);\n        }\n        break;\n        case METHOD_CLONE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(methodPy) {\n              methodPy.tp$name = METHOD_CLONE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(methodPy) {\n              return remapE2ToPy(mv[0], mv[1], mv[2], mv[3]);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(methodPy) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(methodPy) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n          }, METHOD_CLONE, []));\n        }\n        case METHOD_LENGTH: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(4, Sk.builtin.nmber.int$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n          }, METHOD_LENGTH, []));\n        }\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not a readable attribute of \" + EUCLIDEAN_2);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(selfPy, name, valuePy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_W: {\n          self[0] = value;\n        }\n        break;\n        case PROP_X: {\n          self[1] = value;\n        }\n        break;\n        case PROP_Y: {\n          self[2] = value;\n        }\n        break;\n        case PROP_XY: {\n          self[3] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not a writeable attribute of \" + EUCLIDEAN_2);\n        }\n      }\n    });\n  }, EUCLIDEAN_2, []);\n  return mod;\n}\n", "src/lib/eight/__init__.js": "/**\n * eight is a foreign function interface over Three.js for the DaVinci Python to JavaScript cross-compiler.\n *\n * The name eight reflects the 2 * 2 * 2 = 8 coordinates required in the Geometric Algebra generated by 3D Euclidean space.\n *\n * The eight module is in most respects API-compatible with the Three.js library except that THREE.Vector3 has\n * been extended in the ffi to Euclidean3.\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n  \n  var EUCLIDEAN_3           = \"Euclidean3\";\n  var SCALAR_3              = \"Scalar3\";\n  var VECTOR_3              = \"Vector3\";\n  var BIVECTOR_3            = \"Bivector3\";\n  var PSEUDOSCALAR_3        = \"Pseudoscalar3\";\n\n  var QUATERNION            = \"Quaternion\";\n\n  var SCENE                 = \"Scene\";\n  var CANVAS_RENDERER       = \"CanvasRenderer\";\n  var WEBGL_RENDERER        = \"WebGLRenderer\";\n  var COLOR                 = \"Color\";\n  var ORTHOGRAPHIC_CAMERA   = \"OrthographicCamera\";\n  var PERSPECTIVE_CAMERA    = \"PerspectiveCamera\";\n\n  var GEOMETRY              = \"Geometry\";\n  var OBJECT_3D             = \"Object3D\";\n\n  var AMBIENT_LIGHT         = \"AmbientLight\";\n  var DIRECTIONAL_LIGHT     = \"DirectionalLight\";\n  var POINT_LIGHT           = \"PointLight\";\n\n  var LINE                  = \"Line\";\n  var LINE_BASIC_MATERIAL   = \"LineBasicMaterial\";\n\n  var MESH                  = \"Mesh\";\n  var MESH_BASIC_MATERIAL   = \"MeshBasicMaterial\";\n  var MESH_LAMBERT_MATERIAL = \"MeshLambertMaterial\";\n  var MESH_NORMAL_MATERIAL  = \"MeshNormalMaterial\";\n  var MESH_PHONG_MATERIAL   = \"MeshPhongMaterial\";\n\n  var ARROW_GEOMETRY        = \"ArrowGeometry\";\n  var CIRCLE_GEOMETRY       = \"CircleGeometry\";\n  var CUBE_GEOMETRY         = \"CubeGeometry\";\n  var CYLINDER_GEOMETRY     = \"CylinderGeometry\";\n  var ICOSAHEDRON_GEOMETRY  = \"IcosahedronGeometry\";\n  var LATHE_GEOMETRY        = \"LatheGeometry\";\n  var OCTAHEDRON_GEOMETRY   = \"OctahedronGeometry\";\n  var PLANE_GEOMETRY        = \"PlaneGeometry\";\n  var SPHERE_GEOMETRY       = \"SphereGeometry\";\n  var TEXT_GEOMETRY         = \"TextGeometry\";\n  var TETRAHEDRON_GEOMETRY  = \"TetrahedronGeometry\";\n  var TORUS_GEOMETRY        = \"TorusGeometry\";\n\n  var PROP_BOTTOM              = \"bottom\";\n  var PROP_COLOR               = \"color\";\n  var PROP_DETAIL              = \"detail\";\n  var PROP_EULER_ORDER         = \"eulerOrder\";\n  var PROP_FAR                 = \"far\";\n  var PROP_GEOMETRY            = \"geometry\";\n  var PROP_ID                  = \"id\";\n  var PROP_LEFT                = \"left\";\n  var PROP_MASS                = \"mass\";\n  var PROP_MATERIAL            = \"material\";\n  var PROP_MATRIX_AUTO_UPDATE  = \"matrixAutoUpdate\";\n  var PROP_NAME                = \"name\";\n  var PROP_NEAR                = \"near\";\n  var PROP_NEEDS_UPDATE        = \"needsUpdate\";\n  var PROP_OPACITY             = \"opacity\";\n  var PROP_OVERDRAW            = \"overdraw\";\n  var PROP_POSITION            = \"position\";\n  var PROP_QUATERNION          = \"quaternion\";\n  var PROP_RADIUS              = \"radius\";\n  var PROP_RIGHT               = \"right\";\n  var PROP_ROTATION            = \"rotation\";\n  var PROP_SCALE               = \"scale\";\n  var PROP_SEGMENTS            = \"segments\";\n  var PROP_THETA_START         = \"thetaStart\";\n  var PROP_THETA_LENGTH        = \"thetaLength\";\n  var PROP_TOP                 = \"top\";\n  var PROP_TRANSPARENT         = \"transparent\";\n  var PROP_TYPE                = \"type\";\n  var PROP_UP                  = \"up\";\n  var PROP_USE_QUATERNION      = \"useQuaternion\";\n  var PROP_VELOCITY            = \"velocity\";\n  var PROP_VERTICES            = \"vertices\";\n  var PROP_VISIBLE             = \"visible\";\n  var PROP_WIREFRAME           = \"wireframe\";\n  var PROP_WIREFRAME_LINEWIDTH = \"wireframeLinewidth\";\n\n  var PROP_W                     = \"w\";\n  var PROP_X                     = \"x\";\n  var PROP_Y                     = \"y\";\n  var PROP_Z                     = \"z\";\n  var PROP_XY                    = \"xy\";\n  var PROP_YZ                    = \"yz\";\n  var PROP_ZX                    = \"zx\";\n  var PROP_XYZ                   = \"xyz\";\n  var METHOD_SET_X               = \"setX\";\n  var METHOD_SET_Y               = \"setY\";\n  var METHOD_SET_Z               = \"setZ\";\n  var METHOD_GET_COMPONENT       = \"getComponent\";\n  var METHOD_SET_COMPONENT       = \"setComponent\";\n  var METHOD_SET                 = \"set\";\n  var METHOD_SET_FROM_AXIS_ANGLE = \"setFromAxisAngle\";\n  var METHOD_SET_FROM_EULER      = \"setFromEuler\";\n  var METHOD_SET_GEOMETRY        = \"setGeometry\";\n  var METHOD_UPDATE_MATRIX       = \"updateMatrix\";\n\n  var METHOD_ADD               = \"add\";\n  var METHOD_CLONE             = \"clone\";\n  var METHOD_CONJUGATE         = \"conjugate\";\n  var METHOD_COPY              = \"copy\";\n  var METHOD_CROSS             = \"cross\";\n  var METHOD_DOT               = \"dot\";\n  var METHOD_INVERSE           = \"inverse\";\n  var METHOD_LENGTH            = \"length\";\n  var METHOD_LENGTH_SQ         = \"lengthSq\";\n  var METHOD_LOOK_AT           = \"lookAt\";\n  var METHOD_NORMALIZE         = \"normalize\";\n  var METHOD_REMOVE            = \"remove\";\n  var METHOD_SET_RGB           = \"setRGB\";\n\n  var mod = {};\n\n  function isBoolean(x)   { return typeof x === 'boolean'; }\n  function isFunction(x)  { return typeof x === 'function'; }\n  function isNumber(x)    { return typeof x === 'number'; }\n  function isObject(x)    { return typeof x === 'object'; }\n  function isString(x)    { return typeof x === 'string'; }\n  function isUndefined(x) { return typeof x === 'undefined'; }\n\n  function isDefined(x)   { return typeof x !== 'undefined'; }\n  function isNull(x)      { return typeof x === 'object' && x === null; }\n\n  function methodAdd(target) {\n    if (!isObject(target)) {\n      throw new Sk.builtin.AssertionError(\"target must be an object.\");\n    }\n    if (!isFunction(target[METHOD_ADD])) {\n      throw new Sk.builtin.AssertionError(\"target must have an 'add' function.\");\n    }\n    return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n      $loc.__init__ = new Sk.builtin.func(function(self) {\n        self.tp$name = METHOD_ADD;\n      });\n      $loc.__call__ = new Sk.builtin.func(function(self, childPy) {\n        var child = Sk.ffi.remapToJs(childPy);\n        target[METHOD_ADD](child);\n      });\n      $loc.__str__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_ADD)\n      })\n      $loc.__repr__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_ADD)\n      })\n    }, METHOD_ADD, []));\n  }\n\n  function methodRemove(target) {\n    if (!isObject(target)) {\n      throw new Sk.builtin.AssertionError(\"target must be an object.\");\n    }\n    if (!isFunction(target[METHOD_REMOVE])) {\n      throw new Sk.builtin.AssertionError(\"target must have a 'remove' function.\");\n    }\n    return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n      $loc.__init__ = new Sk.builtin.func(function(self) {\n        self.tp$name = METHOD_REMOVE;\n      });\n      $loc.__call__ = new Sk.builtin.func(function(self, childPy) {\n        var child = Sk.ffi.remapToJs(childPy);\n        target[METHOD_REMOVE](child);\n      });\n      $loc.__str__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_REMOVE)\n      })\n      $loc.__repr__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(METHOD_REMOVE)\n      })\n    }, METHOD_REMOVE, []));\n  }\n\n  function verticesPy(vertices) {\n    return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n      $loc.__init__ = new Sk.builtin.func(function(self) {\n        self.tp$name = PROP_VERTICES;\n        self.v = vertices;\n      });\n      $loc.__getattr__ = new Sk.builtin.func(function(verticesPy, name) {\n        var METHOD_APPEND = \"append\";\n        switch(name) {\n          case METHOD_APPEND: {\n            return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n              $loc.__init__ = new Sk.builtin.func(function(self) {\n                self.tp$name = METHOD_APPEND;\n              });\n              $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n                vertices.push(Sk.ffi.remapToJs(vectorPy));\n              });\n              $loc.__str__ = new Sk.builtin.func(function(self) {\n                return new Sk.builtin.str(METHOD_APPEND)\n              });\n              $loc.__repr__ = new Sk.builtin.func(function(self) {\n                return new Sk.builtin.str(METHOD_APPEND)\n              });\n            }, METHOD_APPEND, []));\n          }\n        }\n      });\n      $loc.__getitem__ = new Sk.builtin.func(function(verticesPy, indexPy) {\n        var index = Sk.ffi.remapToJs(indexPy);\n        return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(vertices[index], EUCLIDEAN_3));\n      });\n      $loc.mp$length = function() {return vertices.length;};\n      $loc.__str__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(PROP_VERTICES)\n      });\n      $loc.__repr__ = new Sk.builtin.func(function(self) {\n        return new Sk.builtin.str(PROP_VERTICES)\n      });\n    }, PROP_VERTICES, []));\n  }\n\n  /*\n   * Deterines whether the argument is a genuine Color reference.\n   */\n  function isColor(x) {\n    if (isDefined(x)) {\n      if (x.hasOwnProperty(\"r\") && x.hasOwnProperty(\"g\") && x.hasOwnProperty(\"b\")) {\n        return isNumber(x[\"r\"]) && isNumber(x[\"g\"]) && isNumber(x[\"b\"]);\n      }\n      else {\n        return false;\n      }\n    }\n    else {\n      return false;\n    }\n  }\n\n  function webGLSupported() {\n    try {\n      if (window.WebGLRenderingContext) {\n        if (document.createElement('canvas').getContext('experimental-webgl')) {\n          return true;\n        }\n        else {\n          return false;\n        }\n      }\n      else {\n        return false;\n      }\n    }\n    catch(e) {\n      return false;\n    }\n  }\n\n  function numberFromArg(arg, argName, functionName, lax) {\n    if (isUndefined(argName)) {\n      throw new Error(\"argName must be specified\")\n    }\n    if (isUndefined(functionName)) {\n      throw new Error(\"functionName must be specified\")\n    }\n    lax = isUndefined(lax) ? true : (isBoolean(lax) ? lax : true);\n    if (isUndefined(arg)) {\n      if (lax) {\n        return arg;\n      }\n      else {\n        throw new Sk.builtin.TypeError(functionName + \".\" + argName + \" must be convertible to a number, but was Missing.\");\n      }\n    }\n    else if (isNull(arg)) {\n      if (lax) {\n        return arg;\n      }\n      else {\n        throw new Sk.builtin.TypeError(functionName + \".\" + argName + \" must be convertible to a number, but was None.\");\n      }\n    }\n    if (isBoolean(arg)) {\n      throw new Sk.builtin.TypeError(functionName + \".\" + argName + \" must be convertible to a number, but was a Boolean.\");\n    }\n\n    if (arg.skType) {\n      switch(arg.skType) {\n        case 'float': {\n          return arg.v;\n        }\n        case 'int': {\n          return arg.v;\n        }\n        default: {\n          throw new Sk.builtin.TypeError(functionName + \"(\" + argName + \": \" + arg.skType + \") must be convertible to a number.\");\n        }\n      }\n    }\n    else if (arg.v) {\n      if (isString(arg.v)) {\n        throw new Sk.builtin.TypeError(functionName + \".\" + argName + \" must be convertible to a number, but was a String.\");\n      }\n      else {\n        throw new Sk.builtin.AssertionError(functionName + \".\" + argName + \" is unknown.\");\n      }\n    }\n    else {\n      throw new Sk.builtin.AssertionError(functionName + \".\" + argName + \" is unknown.\");\n    }\n  }\n\n  function numberFromIntegerArg(arg, argName, functionName) {\n    // TODO: Maybe need an argument to say whether undefined is acceptable?\n    // TODO: Likewise for whether null is acceptable.\n    if (isUndefined(arg)) {\n      return arg;\n    }\n    else if (isNull(arg)) {\n      return null;\n    }\n    else {\n      if (arg.skType) {\n        switch(arg.skType) {\n          case 'float': {\n            // TODO: Handle coercion to nearest integer.\n            return arg.v;\n          }\n          case 'int': {\n            return arg.v;\n          }\n        }\n      }\n      throw new Sk.builtin.AssertionError(functionName + \".\" + argName + \" must be an integer.\");\n    }\n  }\n\n  function remapE3ToPy(w, x, y, z, xy, yz, zx, xyz) {\n    w = Sk.builtin.assk$(w, Sk.builtin.nmber.float$);\n    x = Sk.builtin.assk$(x, Sk.builtin.nmber.float$);\n    y = Sk.builtin.assk$(y, Sk.builtin.nmber.float$);\n    z = Sk.builtin.assk$(z, Sk.builtin.nmber.float$);\n    xy = Sk.builtin.assk$(xy, Sk.builtin.nmber.float$);\n    yz = Sk.builtin.assk$(yz, Sk.builtin.nmber.float$);\n    zx = Sk.builtin.assk$(zx, Sk.builtin.nmber.float$);\n    xyz = Sk.builtin.assk$(xyz, Sk.builtin.nmber.float$);\n    return Sk.misceval.callsim(mod[EUCLIDEAN_3], w, x, y, z, xy, yz, zx, xyz);\n  }\n\n  function wxyzToPy(w, x, y, z) {\n    var wPy = Sk.builtin.assk$(w, Sk.builtin.nmber.float$);\n    var xPy = Sk.builtin.assk$(x, Sk.builtin.nmber.float$);\n    var yPy = Sk.builtin.assk$(y, Sk.builtin.nmber.float$);\n    var zPy = Sk.builtin.assk$(z, Sk.builtin.nmber.float$);\n    return Sk.misceval.callsim(mod[QUATERNION], xPy, yPy, zPy, wPy);\n  }\n\n  function divide(a000, a001, a010, a011, a100, a101, a110, a111, b000, b001, b010, b011, b100, b101, b110, b111, dst) {\n    // WARNING! bladeASM.mulE2 uses w,x,y,z,xy,yz,zx,xyz representation. Notice the ordering and sign change.\n    // TODO: Move everything to the more systematic bitmap representation.\n    // r = ~b = reverse(b)\n    var r000 = +b000; // w,   grade 0(+)\n    var r001 = +b001; // x,   grade 1(+)\n    var r010 = +b010; // y,   grade 1(+)\n    var r011 = -b011; // xy,  grade 2(-)\n    var r100 = +b100; // z,   grade 1(+)\n    var r101 = -b101; // yz,  grade 2(-)\n    var r110 = -b110; // yz,  grade 2(-)\n    var r111 = -b111; // xyz, grade 3(-)\n    // m = b * r = b * (~b)\n    // The grade 2 and grade 3 components evaluate to zero.\n    var m000 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 0);\n    var m001 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 1);\n    var m010 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 2);\n    var m011 =  0;//bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 4);\n    var m100 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 3);\n    var m101 =  0;//-bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 6);\n    var m110 =  0;//bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 5);\n    var m111 =  0;//bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 7);\n    // c = cliffordConjugate(m)\n    var c000 = +m000; // w,   grade 0(+)\n    var c001 = -m001; // x,   grade 1(-)\n    var c010 = -m010; // y,   grade 1(-)\n    var c011 = -m011; // xy,  grade 2(-)\n    var c100 = -m100; // z,   grade 1(-)\n    var c101 = -m101; // -zx, grade 2(-)\n    var c110 = -m110; // yz,  grade 2(-)\n    var c111 = +m111; // xyz, grade 3(+)\n    // s = r * c\n    // TODO: Presumably there is some simplified computation on account of the c's being sparse.\n    var s000 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 0);\n    var s001 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 1);\n    var s010 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 2);\n    var s011 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 4);\n    var s100 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 3);\n    var s101 = -bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 6);\n    var s110 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 5);\n    var s111 =  bladeASM.mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 7);\n    // k = b * s\n    var k000 =  bladeASM.mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, s000, s001, s010, s100, s011, s110, -s101, s111, 0);\n    // i = inverse(b)\n    var i000 = s000/k000;\n    var i001 = s001/k000;\n    var i010 = s010/k000;\n    var i011 = s011/k000;\n    var i100 = s100/k000;\n    var i101 = s101/k000;\n    var i110 = s110/k000;\n    var i111 = s111/k000;\n    // x = a * inverse(b)\n    var x000 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 0);\n    var x001 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 1);\n    var x010 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 2);\n    var x011 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 4);\n    var x100 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 3);\n    var x101 = -bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 6);\n    var x110 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 5);\n    var x111 =  bladeASM.mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 7);\n    // translate bitmap representation to Cartesian.\n    var w   =  x000;\n    var x   =  x001;\n    var y   =  x010;\n    var z   =  x100;\n    var xy  =  x011;\n    var yz  =  x110;\n    var zx  = -x101;\n    var xyz =  x111;\n    // return or populate the optional dst parameter.\n    if (typeof dst !== 'undefined') {\n      dst.w   = w;\n      dst.x   = x;\n      dst.y   = y;\n      dst.z   = z;\n      dst.xy  = xy;\n      dst.yz  = yz;\n      dst.zx  = zx;\n      dst.xyz = xyz;\n    }\n    else {\n      return remapE3ToPy(w, x, y, z, xy, yz, zx, xyz);\n    }\n  }\n\n  function multiVector3(w, vector, xy, yz, zx, xyz) {\n    vector.w = w;\n    vector.xy = xy;\n    vector.yz = yz;\n    vector.zx = zx;\n    vector.xyz = xyz;\n    return vector;\n  }\n\n  function coord(mv, index) {\n    switch(index) {\n      case 0: {\n        return mv.w;\n      }\n      case 1: {\n        return mv.x;\n      }\n      case 2: {\n        return mv.y;\n      }\n      case 3: {\n        return mv.z;\n      }\n      case 4: {\n        return mv.xy;\n      }\n      case 5: {\n        return mv.yz;\n      }\n      case 6: {\n        return mv.zx;\n      }\n      case 7: {\n        return mv.xyz;\n      }\n      default: {\n        throw new Sk.builtin.AssertionError(\"\" + index + \" is not a valid multivector coordinate index\");\n      }\n    }\n  }\n  \n  function compute(f, a, b, coord, pack) {\n    var a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, x0, x1, x2, x3, x4, x5, x6, x7;\n    a0 = a.w;\n    a1 = a.x;\n    a2 = a.y;\n    a3 = a.z;\n    a4 = a.xy;\n    a5 = a.yz;\n    a6 = a.zx;\n    a7 = a.xyz;\n    b0 = b.w;\n    b1 = b.x;\n    b2 = b.y;\n    b3 = b.z;\n    b4 = b.xy;\n    b5 = b.yz;\n    b6 = b.zx;\n    b7 = b.xyz;\n    x0 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n    x1 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n    x2 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n    x3 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n    x4 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n    x5 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n    x6 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n    x7 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n    return pack(x0, x1, x2, x3, x4, x5, x6, x7);\n  }\n\n  mod[EUCLIDEAN_3] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, w, x, y, z, xy, yz, zx, xyz) {\n      w = Sk.ffi.remapToJs(w);\n      x = Sk.ffi.remapToJs(x);\n      y = Sk.ffi.remapToJs(y);\n      z = Sk.ffi.remapToJs(z);\n      xy = Sk.ffi.remapToJs(xy);\n      yz = Sk.ffi.remapToJs(yz);\n      zx = Sk.ffi.remapToJs(zx);\n      xyz = Sk.ffi.remapToJs(xyz);\n      if (isNumber(w) && isNumber(x) && isNumber(y) && isNumber(z) && isNumber(xy) && isNumber(yz) && isNumber(zx) && isNumber(xyz)) {\n        self.v = multiVector3(w, new THREE.Vector3(x, y, z), xy, yz, zx, xyz);\n      }\n      else if (isDefined(w) && isUndefined(x) && isUndefined(y) && isUndefined(z) && isUndefined(xy) && isUndefined(yz) && isUndefined(zx) && isUndefined(xyz)) {\n        self.v = multiVector3(w.w || 0, w, w.xy || 0, w.yz || 0, w.zx|| 0, w.xyz || 0);\n      }\n      else if (isDefined(w) && isUndefined(x) && isUndefined(y) && isUndefined(z) && isDefined(xy) && isDefined(yz) && isDefined(zx) && isDefined(xyz)) {\n        self.v = multiVector3(w, new THREE.Vector3(0, 0, 0), xy, yz, zx, xyz);\n      }\n      else if (isUndefined(w) && isUndefined(x) && isUndefined(y) && isUndefined(z) && isUndefined(xy) && isUndefined(yz) && isUndefined(zx) && isUndefined(xyz)) {\n        self.v = multiVector3(0, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(EUCLIDEAN_3);\n      }\n      self.tp$name = EUCLIDEAN_3;\n    });\n    $loc.__add__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w + b, a.x, a.y, a.z, a.xy, a.yz, a.zx, a.xyz);\n      }\n      else {\n        var w = a.w + b.w;\n        var x = a.x + b.x;\n        var y = a.y + b.y;\n        var z = a.z + b.z;\n        var xy = a.xy + b.xy;\n        var yz = a.yz + b.yz;\n        var zx = a.zx + b.zx;\n        var xyz = a.xyz + b.xyz;\n        return remapE3ToPy(w, x, y, z, xy, yz, zx, xyz);\n      }\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a + b.w, b.x, b.y, b.z, b.xy, b.yz, b.zx, b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w += other;\n      }\n      else {\n        self.w += other.w;\n        self.x += other.x;\n        self.y += other.y;\n        self.z += other.z;\n        self.xy += other.xy;\n        self.yz += other.yz;\n        self.zx += other.zx;\n        self.xyz += other.xyz;\n      }\n      return selfPy;\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w - b, a.x, a.y, a.z, a.xy, a.yz, a.zx, a.xyz);\n      }\n      else {\n        var w = a.w - b.w;\n        var x = a.x - b.x;\n        var y = a.y - b.y;\n        var z = a.z - b.z;\n        var xy = a.xy - b.xy;\n        var yz = a.yz - b.yz;\n        var zx = a.zx - b.zx;\n        var xyz = a.xyz - b.xyz;\n        return remapE3ToPy(w, x, y, z, xy, yz, zx, xyz);\n      }\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a - b.w, -b.x, -b.y, -b.z, -b.xy, -b.yz, -b.zx, -b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w -= other;\n      }\n      else {\n        self.w -= other.w;\n        self.x -= other.x;\n        self.y -= other.y;\n        self.z -= other.z;\n        self.xy -= other.xy;\n        self.yz -= other.yz;\n        self.zx -= other.zx;\n        self.xyz -= other.xyz;\n      }\n      return selfPy;\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);\n      }\n      else {\n        return compute(bladeASM.mulE3, a, b, coord, remapE3ToPy);\n      }\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var a4 = a.xy;\n      var a5 = a.yz;\n      var a6 = a.zx;\n      var a7 = a.xyz;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        b0 = b;\n        b1 = 0;\n        b2 = 0;\n        b3 = 0;\n        b4 = 0;\n        b5 = 0;\n        b6 = 0;\n        b7 = 0;\n      }\n      else {\n        b0 = b.w;\n        b1 = b.x;\n        b2 = b.y;\n        b3 = b.z;\n        b4 = b.xy;\n        b5 = b.yz;\n        b6 = b.zx;\n        b7 = b.xyz;\n      }\n      a.w   = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n      a.x   = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n      a.y   = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n      a.z   = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n      a.xy  = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n      a.yz  = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n      a.zx  = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n      a.xyz = bladeASM.mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n      return selfPy;\n    });\n    $loc.__div__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b, 0, 0, 0, 0, 0, 0, 0);\n      }\n      else {\n        return divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz);\n      }\n    });\n    $loc.__rdiv__ = new Sk.builtin.func(function(rhs, lhs) {\n      lhs = Sk.ffi.remapToJs(lhs);\n      rhs = Sk.ffi.remapToJs(rhs);\n      if (isNumber(lhs)) {\n        return divide(lhs, 0, 0, 0, 0, 0, 0, 0, rhs.w, rhs.x, rhs.y, rhs.xy, rhs.z, -rhs.zx, rhs.yz, rhs.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError(\"\" + JSON.stringify(lhs, null, 2) + \" / \" + JSON.stringify(rhs, null, 2));\n      }\n    });\n    $loc.__idiv__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(b)) {\n        divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b, 0, 0, 0, 0, 0, 0, 0, a);\n        return selfPy;\n      }\n      else {\n        divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz, a);\n        return selfPy;\n      }\n    });\n    $loc.__xor__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);\n      }\n      else {\n        return compute(bladeASM.extE3, a, b, coord, remapE3ToPy);\n      }\n    });\n    $loc.__rxor__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__ixor__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var a4 = a.xy;\n      var a5 = a.yz;\n      var a6 = a.zx;\n      var a7 = a.xyz;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        b0 = b;\n        b1 = 0;\n        b2 = 0;\n        b3 = 0;\n        b4 = 0;\n        b5 = 0;\n        b6 = 0;\n        b7 = 0;\n      }\n      else {\n        b0 = b.w;\n        b1 = b.x;\n        b2 = b.y;\n        b3 = b.z;\n        b4 = b.xy;\n        b5 = b.yz;\n        b6 = b.zx;\n        b7 = b.xyz;\n      }\n      a.w   = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n      a.x   = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n      a.y   = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n      a.z   = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n      a.xy  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n      a.yz  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n      a.zx  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n      a.xyz = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n      return selfPy;\n    });\n    $loc.__lshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w * b, 0, 0, 0, 0, 0, 0, 0);\n      }\n      else {\n        return compute(bladeASM.lcoE3, a, b, coord, remapE3ToPy);\n      }\n    });\n    $loc.__rlshift__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__ilshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var a4 = a.xy;\n      var a5 = a.yz;\n      var a6 = a.zx;\n      var a7 = a.xyz;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        b0 = b;\n        b1 = 0;\n        b2 = 0;\n        b3 = 0;\n        b4 = 0;\n        b5 = 0;\n        b6 = 0;\n        b7 = 0;\n      }\n      else {\n        b0 = b.w;\n        b1 = b.x;\n        b2 = b.y;\n        b3 = b.z;\n        b4 = b.xy;\n        b5 = b.yz;\n        b6 = b.zx;\n        b7 = b.xyz;\n      }\n      a.w   = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n      a.x   = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n      a.y   = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n      a.z   = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n      a.xy  = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n      a.yz  = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n      a.zx  = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n      a.xyz = bladeASM.lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n      return selfPy;\n    });\n    $loc.__rshift__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return remapE3ToPy(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);\n      }\n      else {\n        return compute(bladeASM.rcoE3, a, b, coord, remapE3ToPy);\n      }\n    });\n    $loc.__rrshift__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return remapE3ToPy(a * b.w, 0, 0, 0, 0, 0, 0, 0);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__irshift__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var a4 = a.xy;\n      var a5 = a.yz;\n      var a6 = a.zx;\n      var a7 = a.xyz;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        b0 = b;\n        b1 = 0;\n        b2 = 0;\n        b3 = 0;\n        b4 = 0;\n        b5 = 0;\n        b6 = 0;\n        b7 = 0;\n      }\n      else {\n        b0 = b.w;\n        b1 = b.x;\n        b2 = b.y;\n        b3 = b.z;\n        b4 = b.xy;\n        b5 = b.yz;\n        b6 = b.zx;\n        b7 = b.xyz;\n      }\n      a.w   = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);\n      a.x   = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n      a.y   = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n      a.z   = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n      a.xy  = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);\n      a.yz  = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);\n      a.zx  = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);\n      a.xyz = bladeASM.rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);\n      return selfPy;\n    });\n    $loc.nb$positive = function() {\n      return this;\n    };\n    $loc.nb$negative = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return remapE3ToPy(-mv.w, -mv.x, -mv.y, -mv.z, -mv.xy, -mv.yz, -mv.zx, -mv.xyz);\n    };\n    $loc.nb$invert = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return remapE3ToPy(mv.w, mv.x, mv.y, mv.z, -mv.xy, -mv.yz, -mv.zx, -mv.xyz);\n    };\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w === b.w && a.x === b.x && a.y === b.y && a.z === b.z && a.xy === b.xy && a.yz === b.yz && a.zx === b.zx && a.xyz === b.xyz;\n    });\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.z !== b.z || a.xy !== b.xy || a.yz !== b.yz || a.zx !== b.zx || a.xyz !== b.xyz;\n    });\n    $loc.__getitem__ = new Sk.builtin.func(function(mv, index) {\n      mv = Sk.ffi.remapToJs(mv);\n      index = Sk.builtin.asnum$(index);\n      switch(index) {\n        case 0: {\n          return remapE3ToPy(mv.w, 0, 0, 0, 0, 0, 0, 0);\n        }\n        case 1: {\n          return remapE3ToPy(0, mv.x, mv.y, mv.z, 0, 0, 0, 0);\n        }\n        case 2: {\n          return remapE3ToPy(0, 0, 0, 0, mv.xy, mv.yz, mv.zx, 0);\n        }\n        case 3: {\n          return remapE3ToPy(0, 0, 0, 0, 0, 0, 0, mv.xyz);\n        }\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(mvPy, name) {\n      var mv = Sk.ffi.remapToJs(mvPy);\n      switch(name) {\n        case PROP_W: {\n          return Sk.builtin.assk$(mv.w, Sk.builtin.nmber.float$);\n        }\n        case PROP_X: {\n          return Sk.builtin.assk$(mv.x, Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(mv.y, Sk.builtin.nmber.float$);\n        }\n        case PROP_Z: {\n          return Sk.builtin.assk$(mv.z, Sk.builtin.nmber.float$);\n        }\n        case PROP_XY: {\n          return Sk.builtin.assk$(mv.xy, Sk.builtin.nmber.float$);\n        }\n        case PROP_YZ: {\n          return Sk.builtin.assk$(mv.yz, Sk.builtin.nmber.float$);\n        }\n        case PROP_ZX: {\n          return Sk.builtin.assk$(mv.zx, Sk.builtin.nmber.float$);\n        }\n        case PROP_XYZ: {\n          return Sk.builtin.assk$(mv.xyz, Sk.builtin.nmber.float$);\n        }\n        case METHOD_ADD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_ADD;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, arg) {\n              arg  = Sk.ffi.remapToJs(arg);\n              mv.w += arg.w;\n              mv.x += arg.x;\n              mv.y += arg.y;\n              mv.z += arg.z;\n              mv.xy += arg.xy;\n              mv.yz += arg.yz;\n              mv.zx += arg.zx;\n              mv.xyz += arg.xyz;\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_ADD);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_ADD);\n            });\n          }, METHOD_ADD, []));\n        }\n        case METHOD_CROSS: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CROSS;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vPy) {\n              var v  = Sk.ffi.remapToJs(vPy);\n              mv.w = 0;\n              mv[METHOD_CROSS](v);\n//            mv.x  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);\n//            mv.y  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);\n//            mv.z  = bladeASM.extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);\n              mv.xy = 0;\n              mv.yz = 0;\n              mv.zx = 0;\n              mv.xyz = 0;\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CROSS);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CROSS);\n            });\n          }, METHOD_CROSS, []));\n        }\n        case METHOD_DOT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_DOT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vPy) {\n              var v  = Sk.ffi.remapToJs(vPy);\n              return Sk.builtin.assk$(mv[METHOD_DOT](v), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_DOT);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_DOT);\n            });\n          }, METHOD_DOT, []));\n        }\n        case METHOD_SET_X: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_X;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x) {\n              x  = Sk.ffi.remapToJs(x);\n              mv[METHOD_SET_X](x);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_X);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_X);\n            });\n          }, METHOD_SET_X, []));\n        }\n        case METHOD_SET_Y: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_Y;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, y) {\n              y  = Sk.ffi.remapToJs(y);\n              mv[METHOD_SET_Y](y);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_Y);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_Y);\n            });\n          }, METHOD_SET_Y, []));\n        }\n        case METHOD_SET_Z: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_Z;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, z) {\n              z  = Sk.ffi.remapToJs(z);\n              mv[METHOD_SET_Z](z);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_Z);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_Z);\n            });\n          }, METHOD_SET_Z, []));\n        }\n        case METHOD_GET_COMPONENT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_COMPONENT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, index) {\n              index  = Sk.ffi.remapToJs(index);\n              return Sk.builtin.assk$(mv[METHOD_GET_COMPONENT](index), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_COMPONENT);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_COMPONENT);\n            });\n          }, METHOD_GET_COMPONENT, []));\n        }\n        case METHOD_SET_COMPONENT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_COMPONENT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, index, value) {\n              index  = Sk.ffi.remapToJs(index);\n              value  = Sk.ffi.remapToJs(value);\n              mv[METHOD_SET_COMPONENT](index, value);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_COMPONENT);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_COMPONENT);\n            });\n          }, METHOD_SET_COMPONENT, []));\n        }\n        case METHOD_SET: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y, z) {\n              x  = Sk.ffi.remapToJs(x);\n              y  = Sk.ffi.remapToJs(y);\n              z  = Sk.ffi.remapToJs(z);\n              mv[METHOD_SET](x, y, z);\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n          }, METHOD_SET, []));\n        }\n        case METHOD_CLONE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CLONE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return remapE3ToPy(mv.w, mv.x, mv.y, mv.z, mv.xy, mv.yz, mv.zx, mv.xyz);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n          }, METHOD_CLONE, []));\n        }\n        case METHOD_LENGTH: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(mv[METHOD_LENGTH](), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n          }, METHOD_LENGTH, []));\n        }\n        case METHOD_NORMALIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_NORMALIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              mv[METHOD_NORMALIZE]();\n              return mvPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n          }, METHOD_NORMALIZE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(mv, name, value) {\n      mv = Sk.ffi.remapToJs(mv);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_W: {\n          mv.w = value;\n        }\n        break;\n        case PROP_X: {\n          mv.x = value;\n        }\n        break;\n        case PROP_Y: {\n          mv.y = value;\n        }\n        break;\n        case PROP_Z: {\n          mv.z = value;\n        }\n        break;\n        case PROP_XY: {\n          mv.xy = value;\n        }\n        break;\n        case PROP_YZ: {\n          mv.yz = value;\n        }\n        break;\n        case PROP_ZX: {\n          mv.zx = value;\n        }\n        break;\n        case PROP_XYZ: {\n          mv.xyz = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not an attribute of \" + EUCLIDEAN_3);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(m) {\n      m = Sk.ffi.remapToJs(m);\n      var grade0 = m.w !== 0;\n      var grade1 = m.x !== 0 || m.y != 0 || m.z !== 0;\n      var grade2 = m.xy !== 0 || m.yz !== 0 || m.zx !== 0;\n      var grade3 = m.xyz !== 0;\n      if (grade0 && !grade1 && !grade2 && !grade3) {\n        var args = [m.w];\n        return new Sk.builtin.str(SCALAR_3 + \"(\" + args.join(\", \") + \")\");\n      }\n      else if (!grade0 && grade1 && !grade2 && !grade3) {\n        var args = [m.x, m.y, m.z];\n        return new Sk.builtin.str(VECTOR_3 + \"(\" + args.join(\", \") + \")\");\n      }\n      else if (!grade0 && !grade1 && grade2 && !grade3) {\n        var args = [m.xy, m.yz, m.zx];\n        return new Sk.builtin.str(BIVECTOR_3 + \"(\" + args.join(\", \") + \")\");\n      }\n      else if (!grade0 && !grade1 && !grade2 && grade3) {\n        var args = [m.xyz];\n        return new Sk.builtin.str(PSEUDOSCALAR_3 + \"(\" + args.join(\", \") + \")\");\n      }\n      else {\n        var args = [m.w, m.x, m.y, m.z, m.xy, m.yz, m.zx, m.xyz];\n        return new Sk.builtin.str(EUCLIDEAN_3 + \"(\" + args.join(\", \") + \")\");\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(mv) {\n      mv = Sk.ffi.remapToJs(mv);\n      if (isDefined(mv)) {\n        return new Sk.builtin.str(bladeSTR.stringFromCoordinates([mv.w, mv.x, mv.y, mv.z, mv.xy, mv.yz, mv.zx, mv.xyz], [\"1\", \"i\", \"j\", \"k\", \"ij\", \"jk\", \"ki\", \"I\"]));\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + EUCLIDEAN_3 + \"'>\");\n      }\n    });\n  }, EUCLIDEAN_3, []);\n\n  mod[QUATERNION] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, x, y, z, w) {\n      x = Sk.ffi.remapToJs(x);\n      y = Sk.ffi.remapToJs(y);\n      z = Sk.ffi.remapToJs(z);\n      w = Sk.ffi.remapToJs(w);\n      if (isObject(x) && isUndefined(y) && isUndefined(z) && isUndefined(w)) {\n        self.v = x;\n      }\n      else {\n        self.v = new THREE[QUATERNION](x, y, z, w);\n      }\n      self.tp$name = QUATERNION;\n    });\n    $loc.__add__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return wxyzToPy(a.w + b, a.x, a.y, a.z);\n      }\n      else {\n        var w = a.w + b.w;\n        var x = a.x + b.x;\n        var y = a.y + b.y;\n        var z = a.z + b.z;\n        return wxyzToPy(w, x, y, z);\n      }\n    });\n    $loc.__radd__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return wxyzToPy(a + b.w, b.x, b.y, b.z);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__iadd__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w += other;\n      }\n      else {\n        self.w += other.w;\n        self.x += other.x;\n        self.y += other.y;\n        self.z += other.z;\n      }\n      return selfPy;\n    });\n    $loc.__sub__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return wxyzToPy(a.w - b, a.x, a.y, a.z);\n      }\n      else {\n        var w = a.w - b.w;\n        var x = a.x - b.x;\n        var y = a.y - b.y;\n        var z = a.z - b.z;\n        return wxyzToPy(w, x, y, z);\n      }\n    });\n    $loc.__rsub__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return wxyzToPy(a - b.w, -b.x, -b.y, -b.z);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__isub__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var self = Sk.ffi.remapToJs(selfPy);\n      var other = Sk.ffi.remapToJs(otherPy);\n      if (isNumber(other)) {\n        self.w -= other;\n      }\n      else {\n        self.w -= other.w;\n        self.x -= other.x;\n        self.y -= other.y;\n        self.z -= other.z;\n      }\n      return selfPy;\n    });\n    $loc.__mul__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(b)) {\n        return wxyzToPy(a.w * b, a.x * b, a.y * b, a.z * b);\n      }\n      else {\n        var ab = new THREE[QUATERNION]().multiplyQuaternions(a, b);\n        return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(ab, QUATERNION));\n      }\n    });\n    $loc.__rmul__ = new Sk.builtin.func(function(b, a) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      if (isNumber(a)) {\n        return quaternionToPy(a * b.w, a * b.x, a * b.y, a * b.z);\n      }\n      else {\n        throw new Sk.builtin.AssertionError();\n      }\n    });\n    $loc.__imul__ = new Sk.builtin.func(function(selfPy, otherPy) {\n      var a = Sk.ffi.remapToJs(selfPy);\n      var b = Sk.ffi.remapToJs(otherPy);\n      var a0 = a.w;\n      var a1 = a.x;\n      var a2 = a.y;\n      var a3 = a.z;\n      var b0, b1, b2, b3, b4, b5, b6, b7;\n      if (isNumber(b)) {\n        a.w *= b;\n        a.x *= b;\n        a.y *= b;\n        a.z *= b;\n      }\n      else {\n        a.multiply(b);\n      }\n      return selfPy;\n    });\n    $loc.nb$positive = function() {\n      return this;\n    };\n    $loc.nb$negative = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return quaternionToPy(-mv.x, -mv.y, -mv.z, -mv.w);\n    };\n    $loc.nb$invert = function() {\n      var mv = Sk.ffi.remapToJs(this);\n      return remapE3ToPy(mv.w, mv.x, mv.y, mv.z, -mv.xy, -mv.yz, -mv.zx, -mv.xyz);\n    };\n    $loc.__eq__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w === b.w && a.x === b.x && a.y === b.y && a.z === b.z;\n    });\n    $loc.__ne__ = new Sk.builtin.func(function(a, b) {\n      a = Sk.ffi.remapToJs(a);\n      b = Sk.ffi.remapToJs(b);\n      return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.z !== b.z;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(quaternionPy, name) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      switch(name) {\n        case PROP_X: {\n          return Sk.builtin.assk$(quaternion.x, Sk.builtin.nmber.float$);\n        }\n        case PROP_Y: {\n          return Sk.builtin.assk$(quaternion.y, Sk.builtin.nmber.float$);\n        }\n        case PROP_Z: {\n          return Sk.builtin.assk$(quaternion.z, Sk.builtin.nmber.float$);\n        }\n        case PROP_W: {\n          return Sk.builtin.assk$(quaternion.w, Sk.builtin.nmber.float$);\n        }\n        case METHOD_COPY: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_COPY;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, qPy) {\n              var q  = Sk.ffi.remapToJs(qPy);\n              quaternion.x = q.x;\n              quaternion.y = q.y;\n              quaternion.z = q.z;\n              quaternion.w = q.w;\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_COPY);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_COPY);\n            });\n          }, METHOD_COPY, []));\n        }\n        case METHOD_SET_FROM_AXIS_ANGLE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_FROM_AXIS_ANGLE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, axisPy, anglePy) {\n              var axis = Sk.ffi.remapToJs(axisPy);\n              var angle = Sk.ffi.remapToJs(anglePy);\n              quaternion[METHOD_SET_FROM_AXIS_ANGLE](axis, angle);\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_AXIS_ANGLE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_AXIS_ANGLE);\n            });\n          }, METHOD_SET_FROM_AXIS_ANGLE, []));\n        }\n        case METHOD_SET_FROM_EULER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_FROM_EULER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy, orderPy) {\n              var vector = Sk.ffi.remapToJs(vectorPy);\n              var order = Sk.ffi.remapToJs(orderPy);\n              quaternion[METHOD_SET_FROM_EULER](vector, order);\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_EULER);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_FROM_EULER);\n            });\n          }, METHOD_SET_FROM_EULER, []));\n        }\n        case METHOD_SET: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, x, y, z, w) {\n              quaternion.x = Sk.ffi.remapToJs(x);\n              quaternion.y = Sk.ffi.remapToJs(y);\n              quaternion.z = Sk.ffi.remapToJs(z);\n              quaternion.w = Sk.ffi.remapToJs(w);\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET);\n            });\n          }, METHOD_SET, []));\n        }\n        case METHOD_CLONE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CLONE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return wxyzToPy(quaternion.w, quaternion.x, quaternion.y, quaternion.z);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CLONE);\n            });\n          }, METHOD_CLONE, []));\n        }\n        case METHOD_CONJUGATE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_CONJUGATE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              quaternion[METHOD_CONJUGATE]();\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CONJUGATE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_CONJUGATE);\n            });\n          }, METHOD_CONJUGATE, []));\n        }\n        case METHOD_INVERSE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_INVERSE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              var k = 1.0 / quaternion.lengthSq();\n              quaternion[METHOD_CONJUGATE]();\n              quaternion.w *= k;\n              quaternion.x *= k;\n              quaternion.y *= k;\n              quaternion.z *= k;\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_INVERSE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_INVERSE);\n            });\n          }, METHOD_INVERSE, []));\n        }\n        case METHOD_LENGTH: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(quaternion[METHOD_LENGTH](), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH);\n            });\n          }, METHOD_LENGTH, []));\n        }\n        case METHOD_LENGTH_SQ: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LENGTH_SQ;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.builtin.assk$(quaternion[METHOD_LENGTH_SQ](), Sk.builtin.nmber.float$);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH_SQ);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LENGTH_SQ);\n            });\n          }, METHOD_LENGTH_SQ, []));\n        }\n        case METHOD_NORMALIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_NORMALIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              quaternion[METHOD_NORMALIZE]();\n              return quaternionPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_NORMALIZE);\n            });\n          }, METHOD_NORMALIZE, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(quaternionPy, name, valuePy) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_X: {\n          quaternion.x = value;\n        }\n        break;\n        case PROP_Y: {\n          quaternion.y = value;\n        }\n        break;\n        case PROP_Z: {\n          quaternion.z = value;\n        }\n        break;\n        case PROP_W: {\n          quaternion.w = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not an attribute of \" + QUATERNION);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(quaternionPy) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      var args = [quaternion.x, quaternion.y, quaternion.z, quaternion.w];\n      return new Sk.builtin.str(QUATERNION + \"(\" + args.join(\", \") + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(quaternionPy) {\n      var quaternion = Sk.ffi.remapToJs(quaternionPy);\n      if (isDefined(quaternion)) {\n        return new Sk.builtin.str(bladeSTR.stringFromCoordinates([quaternion.w, quaternion.x, quaternion.y, quaternion.z], [\"1\", \"i\", \"j\", \"k\"]));\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + QUATERNION + \"'>\");\n      }\n    });\n  }, QUATERNION, []);\n\n  // Erik Moller's requestAnimationFrame for smart(er) animating\n  // Minor formatting changes and use of braces for if conditions.\n  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n  // The purpose of this enhanced shim is to \n  (function(scope) {\n    if (isDefined(scope)) {\n      var lastTime = 0;\n      var vendors = ['ms', 'moz', 'webkit', 'o'];\n      for(var x = 0; x < vendors.length && !scope.requestAnimationFrame; ++x) {\n        scope.requestAnimationFrame = scope[vendors[x]+'RequestAnimationFrame'];\n        scope.cancelRequestAnimationFrame = scope[vendors[x]+'CancelRequestAnimationFrame'];\n      }\n\n      if (!scope.requestAnimationFrame) {\n        scope.requestAnimationFrame = function(callback, element) {\n          var currTime = new Date().getTime();\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n          var id = scope.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);\n          lastTime = currTime + timeToCall;\n          return id;\n        };\n      }\n\n      if (!scope.cancelAnimationFrame) {\n        scope.cancelAnimationFrame = function(id) {\n          clearTimeout(id);\n        };\n      }\n    }\n  }((typeof window === 'object') ? window : void 0));\n\n   mod[SCENE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.v = new THREE[SCENE]();\n      self.tp$name = SCENE;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(scenePy, name) {\n      var scene = Sk.ffi.remapToJs(scenePy);\n      switch(name) {\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_POSITION], EUCLIDEAN_3));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(scene[PROP_QUATERNION], QUATERNION));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_ROTATION], EUCLIDEAN_3));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(scene[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_SCALE], EUCLIDEAN_3));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(scene[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return scene[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              scene.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return scenePy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case METHOD_ADD: {\n          return methodAdd(scene);\n        }\n        case METHOD_REMOVE: {\n          return methodRemove(scene);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(scenePy, name, valuePy) {\n      var scene = Sk.ffi.remapToJs(scenePy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_POSITION: {\n          scene[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          scene[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          scene[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            scene[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          scene[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          scene[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          scene[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not a write attribute of \" + SCENE);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(SCENE);\n    });\n  }, SCENE, []);\n\n  mod[CANVAS_RENDERER] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_AUTO_CLEAR   = \"autoClear\";\n    var PROP_CLEAR_COLOR  = \"clearColor\";\n    var PROP_DOM_ELEMENT  = \"domElement\";\n    var PROP_GAMMA_INPUT  = \"gammaInput\";\n    var PROP_GAMMA_OUTPUT = \"gammaOutput\";\n    var PROP_SORT_OBJECTS = \"sortObjects\";\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = CANVAS_RENDERER;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[CANVAS_RENDERER](parameters);\n    });\n    $loc.setSize = new Sk.builtin.func(function(self, width, height) {\n      self.v.setSize(Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      var METHOD_RENDER = \"render\";\n      var METHOD_GET_CLEAR_COLOR = \"getClearColor\";\n      var METHOD_SET_CLEAR_COLOR = \"setClearColor\";\n      var METHOD_SET_SIZE        = \"setSize\";\n      var renderer  = Sk.ffi.remapToJs(self);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          return renderer[PROP_AUTO_CLEAR];\n        }\n        case PROP_GAMMA_INPUT: {\n          return renderer[PROP_GAMMA_INPUT];\n        }\n        case PROP_GAMMA_OUTPUT: {\n          return renderer[PROP_GAMMA_OUTPUT];\n        }\n        case PROP_SORT_OBJECTS: {\n          return renderer[PROP_SORT_OBJECTS];\n        }\n        case PROP_DOM_ELEMENT: {\n          // TODO: I think duck-typing means that this will work as long as we don't\n          // try to do anything more ambitious.\n          return {v: renderer.domElement};\n        }\n        case METHOD_RENDER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_RENDER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, scene, camera) {\n              scene  = Sk.ffi.remapToJs(scene);\n              camera = Sk.ffi.remapToJs(camera);\n              renderer.render(scene, camera);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n          }, METHOD_RENDER, []));\n        }\n        case METHOD_GET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(renderer.getClearColor()));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n          }, METHOD_GET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color, alpha) {\n              color  = Sk.ffi.remapToJs(color);\n              alpha = Sk.ffi.remapToJs(alpha);\n              renderer.setClearColor(color, alpha);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n          }, METHOD_SET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_SIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_SIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, width, height, updateStyle) {\n              width  = Sk.ffi.remapToJs(width);\n              height = Sk.ffi.remapToJs(height);\n              updateStyle = Sk.ffi.remapToJs(updateStyle);\n              renderer.setSize(width, height, updateStyle);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n          }, METHOD_SET_SIZE, []));\n        }\n        default: {\n          // The framework will raise an AttributeError exception.\n          return /* undefined */;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(self, name, value) {\n      var renderer  = Sk.ffi.remapToJs(self);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          if (isBoolean(value)) {\n            renderer[PROP_AUTO_CLEAR] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_AUTO_CLEAR + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_GAMMA_INPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_INPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_GAMMA_INPUT + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_GAMMA_OUTPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_OUTPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_GAMMA_OUTPUT + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_SORT_OBJECTS: {\n          if (isBoolean(value)) {\n            renderer[PROP_SORT_OBJECTS] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_SORT_OBJECTS + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case \"size\": {\n          var width  = Sk.builtin.asnum$(value[0]);\n          var height = Sk.builtin.asnum$(value[1]);\n          renderer.setSize(width, height);\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + CANVAS_RENDERER);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var args = {};\n      args[PROP_AUTO_CLEAR] = renderer[PROP_AUTO_CLEAR];\n      args[PROP_GAMMA_INPUT] = renderer[PROP_GAMMA_INPUT];\n      args[PROP_GAMMA_OUTPUT] = renderer[PROP_GAMMA_OUTPUT];\n      return new Sk.builtin.str(CANVAS_RENDERER + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var autoClear = renderer[PROP_AUTO_CLEAR];\n      // Note: The WebGLRenderer takes only one argument, but it is a dictionary.\n      var args = [{\"autoClear\": autoClear}];\n      return new Sk.builtin.str(CANVAS_RENDERER + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, CANVAS_RENDERER, []);\n\n  mod[WEBGL_RENDERER] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_AUTO_CLEAR   = \"autoClear\";\n    var PROP_CLEAR_COLOR  = \"clearColor\";\n    var PROP_DOM_ELEMENT  = \"domElement\";\n    var PROP_GAMMA_INPUT  = \"gammaInput\";\n    var PROP_GAMMA_OUTPUT = \"gammaOutput\";\n    var PROP_SORT_OBJECTS = \"sortObjects\";\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = WEBGL_RENDERER;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[WEBGL_RENDERER](parameters);\n    });\n    $loc.setSize = new Sk.builtin.func(function(self, width, height) {\n      self.v.setSize(Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      var METHOD_RENDER = \"render\";\n      var METHOD_GET_CLEAR_COLOR = \"getClearColor\";\n      var METHOD_SET_CLEAR_COLOR = \"setClearColor\";\n      var METHOD_SET_SIZE        = \"setSize\";\n      var renderer  = Sk.ffi.remapToJs(self);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          return renderer[PROP_AUTO_CLEAR];\n        }\n        case PROP_GAMMA_INPUT: {\n          return renderer[PROP_GAMMA_INPUT];\n        }\n        case PROP_GAMMA_OUTPUT: {\n          return renderer[PROP_GAMMA_OUTPUT];\n        }\n        case PROP_SORT_OBJECTS: {\n          return renderer[PROP_SORT_OBJECTS];\n        }\n        case PROP_DOM_ELEMENT: {\n          // TODO: I think duck-typing means that this will work as long as we don't\n          // try to do anything more ambitious.\n          return {v: renderer.domElement};\n        }\n        case METHOD_RENDER: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_RENDER;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, scene, camera) {\n              scene  = Sk.ffi.remapToJs(scene);\n              camera = Sk.ffi.remapToJs(camera);\n              renderer.render(scene, camera);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_RENDER);\n            })\n          }, METHOD_RENDER, []));\n        }\n        case METHOD_GET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_GET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(renderer.getClearColor()));\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_GET_CLEAR_COLOR);\n            });\n          }, METHOD_GET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_CLEAR_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_CLEAR_COLOR;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, color, alpha) {\n              color  = Sk.ffi.remapToJs(color);\n              alpha = Sk.ffi.remapToJs(alpha);\n              renderer.setClearColor(color, alpha);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_CLEAR_COLOR);\n            });\n          }, METHOD_SET_CLEAR_COLOR, []));\n        }\n        case METHOD_SET_SIZE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_SIZE;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, width, height, updateStyle) {\n              width  = Sk.ffi.remapToJs(width);\n              height = Sk.ffi.remapToJs(height);\n              updateStyle = Sk.ffi.remapToJs(updateStyle);\n              renderer.setSize(width, height, updateStyle);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_SIZE);\n            });\n          }, METHOD_SET_SIZE, []));\n        }\n        default: {\n          // The framework will raise an AttributeError exception.\n          return /* undefined */;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(self, name, value) {\n      var renderer  = Sk.ffi.remapToJs(self);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_AUTO_CLEAR: {\n          if (isBoolean(value)) {\n            renderer[PROP_AUTO_CLEAR] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_AUTO_CLEAR + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_GAMMA_INPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_INPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_GAMMA_INPUT + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_GAMMA_OUTPUT: {\n          if (isBoolean(value)) {\n            renderer[PROP_GAMMA_OUTPUT] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_GAMMA_OUTPUT + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case PROP_SORT_OBJECTS: {\n          if (isBoolean(value)) {\n            renderer[PROP_SORT_OBJECTS] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_SORT_OBJECTS + \"' attribute must be a <type 'bool'>.\");\n          }\n        }\n        break;\n        case \"size\": {\n          var width  = Sk.builtin.asnum$(value[0]);\n          var height = Sk.builtin.asnum$(value[1]);\n          renderer.setSize(width, height);\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + WEBGL_RENDERER);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var args = {};\n      args[PROP_AUTO_CLEAR] = renderer[PROP_AUTO_CLEAR];\n      args[PROP_GAMMA_INPUT] = renderer[PROP_GAMMA_INPUT];\n      args[PROP_GAMMA_OUTPUT] = renderer[PROP_GAMMA_OUTPUT];\n      return new Sk.builtin.str(WEBGL_RENDERER + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var renderer = self.v;\n      var autoClear = renderer[PROP_AUTO_CLEAR];\n      // Note: The WebGLRenderer takes only one argument, but it is a dictionary.\n      var args = [{\"autoClear\": autoClear}];\n      return new Sk.builtin.str(WEBGL_RENDERER + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, WEBGL_RENDERER, []);\n\n  mod[COLOR] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_R = \"r\";\n    var PROP_G = \"g\";\n    var PROP_B = \"b\";\n    $loc.__init__ = new Sk.builtin.func(function(self, value) {\n      value = Sk.ffi.remapToJs(value);\n      self.tp$name = COLOR;\n      if (isUndefined(value)) {\n        self.v = new THREE.Color();\n      }\n      else {\n        if (isNumber(value) || isString(value)) {\n          self.v = new THREE.Color(value);\n        }\n        else if (isColor(value)) {\n          self.v = new THREE.Color(value);\n        }\n        else {\n          throw new Sk.builtin.AssertionError(\"value must be either a number, string or Color.\");\n        }\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(colorPy, name) {\n      var color = Sk.ffi.remapToJs(colorPy);\n      switch(name) {\n        case PROP_R: {\n          return Sk.builtin.assk$(color[PROP_R], Sk.builtin.nmber.float$);\n        }\n        case PROP_G: {\n          return Sk.builtin.assk$(color[PROP_G], Sk.builtin.nmber.float$);\n        }\n        case PROP_B: {\n          return Sk.builtin.assk$(color[PROP_B], Sk.builtin.nmber.float$);\n        }\n        case METHOD_SET_RGB: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_RGB;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, rPy, gPy, bPy) {\n              var r  = Sk.ffi.remapToJs(rPy);\n              var g  = Sk.ffi.remapToJs(gPy);\n              var b  = Sk.ffi.remapToJs(bPy);\n              color.setRGB(r, g, b);\n              return colorPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_RGB);\n            });\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_RGB);\n            });\n          }, METHOD_SET_RGB, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(colorPy, name, valuePy) {\n      var color = Sk.ffi.remapToJs(colorPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_R: {\n          color[PROP_R] = value;\n        }\n        break;\n        case PROP_G: {\n          color[PROP_G] = value;\n        }\n        break;\n        case PROP_B: {\n          color[PROP_B] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AttributeError(name + \" is not an attribute of \" + COLOR);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var color = self.v;\n      var args = {};\n      args[PROP_R] = color[PROP_R];\n      args[PROP_G] = color[PROP_G];\n      args[PROP_B] = color[PROP_B];\n      return new Sk.builtin.str(COLOR + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var color = self.v;\n      var r = color[PROP_R];\n      var g = color[PROP_G];\n      var b = color[PROP_B];\n      var args = [r, g, b];\n      return new Sk.builtin.str(COLOR + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, COLOR, []);\n\n  mod[PERSPECTIVE_CAMERA] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, fov, aspect, near, far) {\n      var fieldOfView = Sk.builtin.asnum$(fov)\n      var aspectRatio = Sk.builtin.asnum$(aspect)\n      var nearPlane = Sk.builtin.asnum$(near)\n      var farPlane = Sk.builtin.asnum$(far)\n      self.v = new THREE[PERSPECTIVE_CAMERA](fieldOfView, aspectRatio, nearPlane, farPlane);\n      self.tp$name = PERSPECTIVE_CAMERA;\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(cameraPy, name) {\n      camera = Sk.ffi.remapToJs(cameraPy);\n      var UPDATE_PROJECTION_MATRIX = \"updateProjectionMatrix\"\n      switch(name) {\n        case \"aspect\": {\n          return Sk.builtin.assk$(camera.aspect, Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(camera[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(camera[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return camera[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              camera.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return cameraPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case UPDATE_PROJECTION_MATRIX: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = UPDATE_PROJECTION_MATRIX;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              camera[name]();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n          }, UPDATE_PROJECTION_MATRIX, []));\n        }\n        default: {\n          return;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(cameraPy, name, valuePy) {\n      var camera = Sk.ffi.remapToJs(cameraPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case \"aspect\": {\n          camera.aspect = value;\n        }\n        break;\n        case PROP_POSITION: {\n          camera[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          camera[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          camera[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            camera[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          camera[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          camera[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          camera[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AssertionError(name + \" is not an attribute of \" + PERSPECTIVE_CAMERA);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(PERSPECTIVE_CAMERA);\n    });\n  }, PERSPECTIVE_CAMERA, []);\n\n  mod[ORTHOGRAPHIC_CAMERA] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, leftPy, rightPy, topPy, bottomPy, nearPy, farPy) {\n      var left = Sk.builtin.asnum$(leftPy)\n      var right = Sk.builtin.asnum$(rightPy)\n      var top = Sk.builtin.asnum$(topPy)\n      var bottom = Sk.builtin.asnum$(bottomPy)\n      var near = Sk.builtin.asnum$(nearPy)\n      var far = Sk.builtin.asnum$(farPy)\n      self.v = new THREE[ORTHOGRAPHIC_CAMERA](left, right, top, bottom, near, far);\n      self.tp$name = ORTHOGRAPHIC_CAMERA;\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(cameraPy, name) {\n      camera = Sk.ffi.remapToJs(cameraPy);\n      var UPDATE_PROJECTION_MATRIX = \"updateProjectionMatrix\"\n      switch(name) {\n        case \"aspect\": {\n          return Sk.builtin.assk$(camera.aspect, Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(camera[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(camera[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(camera[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return camera[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              camera.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return cameraPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case UPDATE_PROJECTION_MATRIX: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = UPDATE_PROJECTION_MATRIX;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              camera[name]();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(UPDATE_PROJECTION_MATRIX)\n            })\n\n          }, UPDATE_PROJECTION_MATRIX, []));\n        }\n        default: {\n          return;\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(cameraPy, name, valuePy) {\n      var camera = Sk.ffi.remapToJs(cameraPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_LEFT: {\n          camera[PROP_LEFT] = value;\n        }\n        break;\n        case PROP_RIGHT: {\n          camera[PROP_RIGHT] = value;\n        }\n        break;\n        case PROP_TOP: {\n          camera[PROP_TOP] = value;\n        }\n        break;\n        case PROP_BOTTOM: {\n          camera[PROP_BOTTOM] = value;\n        }\n        break;\n        case PROP_POSITION: {\n          camera[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          camera[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          camera[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            camera[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          camera[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          camera[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          camera[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Sk.builtin.AssertionError(name + \" is not an attribute of \" + ORTHOGRAPHIC_CAMERA);\n        }\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(cameraPy) {\n      var camera = Sk.ffi.remapToJs(cameraPy);\n      var args = [camera[PROP_LEFT], camera[PROP_RIGHT], camera[PROP_TOP], camera[PROP_BOTTOM], camera[PROP_NEAR], camera[PROP_FAR]];\n      return new Sk.builtin.str(ORTHOGRAPHIC_CAMERA + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(ORTHOGRAPHIC_CAMERA);\n    });\n  }, ORTHOGRAPHIC_CAMERA, []);\n\n  mod[ARROW_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, length, segments, radiusShaft, radiusCone, lengthCone) {\n      length = Sk.ffi.remapToJs(length) || 1;\n      segments = Sk.ffi.remapToJs(segments);\n      radiusShaft = Sk.ffi.remapToJs(radiusShaft) || 0.01;\n      radiusCone = Sk.ffi.remapToJs(radiusCone) || 0.08;\n      lengthCone = Sk.ffi.remapToJs(lengthCone) || 0.2;\n      var lengthShaft = 1 - lengthCone;\n      var a = new THREE.Vector3(0, 0, length);\n      var b = new THREE.Vector3(radiusCone, 0, lengthShaft);\n      var c = new THREE.Vector3(radiusShaft, 0, lengthShaft);\n      var d = new THREE.Vector3(radiusShaft, 0, 0);\n      var e = new THREE.Vector3(0, 0, 0);\n      var points = [a, b, c, d, e];\n      self.v = new THREE.LatheGeometry(points, segments);\n      self.tp$name = ARROW_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(geometryPy, name) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(geometry[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(geometry[PROP_NAME]);\n        }\n        case PROP_VERTICES: {\n          return verticesPy(geometry.vertices);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_NAME: {\n          if (isString(value)) {\n            geometry[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + ARROW_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var geometry = Sk.ffi.remapToJs(self);\n      var args = {};\n      return new Sk.builtin.str(ARROW_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var geometry = Sk.ffi.remapToJs(self);\n      var args = [];\n      return new Sk.builtin.str(ARROW_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, ARROW_GEOMETRY, []);\n\n   mod[CIRCLE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, segments, thetaStart, thetaLength) {\n      radius      = numberFromArg(radius,          PROP_RADIUS,       CIRCLE_GEOMETRY);\n      segments    = numberFromIntegerArg(segments, PROP_SEGMENTS,     CIRCLE_GEOMETRY);\n      thetaStart  = numberFromArg(thetaStart,      PROP_THETA_START,  CIRCLE_GEOMETRY);\n      thetaLength = numberFromArg(thetaLength,     PROP_THETA_LENGTH, CIRCLE_GEOMETRY);\n      self.v = new THREE[CIRCLE_GEOMETRY](radius, segments, thetaStart, thetaLength);\n      self.tp$name = CIRCLE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + CIRCLE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var args = {};\n      return new Sk.builtin.str(CIRCLE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var args = [];\n      return new Sk.builtin.str(CIRCLE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, CIRCLE_GEOMETRY, []);\n\n   mod[CUBE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_WIDTH           = \"width\";\n    var PROP_HEIGHT          = \"height\";\n    var PROP_DEPTH           = \"depth\";\n    var PROP_WIDTH_SEGMENTS  = \"widthSegments\";\n    var PROP_HEIGHT_SEGMENTS = \"heightSegments\";\n    var PROP_DEPTH_SEGMENTS  = \"depthSegments\";\n    $loc.__init__ = new Sk.builtin.func(function(self, width, height, depth, widthSegments, heightSegments, depthSegments) {\n      width          = numberFromArg(width,                 PROP_WIDTH,           CUBE_GEOMETRY);\n      height         = numberFromArg(height,                PROP_HEIGHT,          CUBE_GEOMETRY);\n      depth          = numberFromArg(depth,                 PROP_DEPTH,           CUBE_GEOMETRY);\n      widthSegments  = numberFromIntegerArg(widthSegments,  PROP_WIDTH_SEGMENTS,  CUBE_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, CUBE_GEOMETRY);\n      depthSegments  = numberFromIntegerArg(depthSegments,  PROP_DEPTH_SEGMENTS,  CUBE_GEOMETRY);\n      self.v = new THREE[CUBE_GEOMETRY](width, height, depth, widthSegments, heightSegments, depthSegments);\n      self.tp$name = CUBE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_WIDTH: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT], Sk.builtin.nmber.float$);\n        }\n        case PROP_DEPTH: {\n          return Sk.builtin.assk$(self.v[PROP_DEPTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_WIDTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_DEPTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_DEPTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + CUBE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var cube = self.v;\n      var args = {};\n      args[PROP_WIDTH]  = cube[PROP_WIDTH];\n      args[PROP_HEIGHT] = cube[PROP_HEIGHT];\n      args[PROP_DEPTH]  = cube[PROP_DEPTH];\n      return new Sk.builtin.str(CUBE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var cube = self.v;\n      var width          = cube[PROP_WIDTH];\n      var height         = cube[PROP_HEIGHT];\n      var depth          = cube[PROP_DEPTH];\n      var widthSegments  = cube[PROP_WIDTH_SEGMENTS];\n      var heightSegments = cube[PROP_HEIGHT_SEGMENTS];\n      var depthSegments  = cube[PROP_DEPTH_SEGMENTS];\n      var args = [width, height, depth, widthSegments, heightSegments, depthSegments];\n      return new Sk.builtin.str(CUBE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, CUBE_GEOMETRY, []);\n\n  mod[CYLINDER_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_RADIUS_TOP      = \"radiusTop\";\n    var PROP_RADIUS_BOTTOM   = \"radiusBottom\";\n    var PROP_HEIGHT          = \"height\";\n    var PROP_RADIUS_SEGMENTS = \"radiusSegments\";\n    var PROP_HEIGHT_SEGMENTS = \"heightSegments\";\n    var PROP_OPEN_ENDED      = \"openEnded\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded) {\n      radiusTop      = numberFromArg(radiusTop,             PROP_RADIUS_TOP,      CYLINDER_GEOMETRY);\n      radiusBottom   = numberFromArg(radiusBottom,          PROP_RADIUS_BOTTOM,   CYLINDER_GEOMETRY);\n      height         = numberFromArg(height,                PROP_HEIGHT,          CYLINDER_GEOMETRY);\n      radiusSegments = numberFromIntegerArg(radiusSegments, PROP_RADIUS_SEGMENTS, CYLINDER_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, CYLINDER_GEOMETRY);\n      openEnded      = Sk.ffi.remapToJs(openEnded);\n      self.v = new THREE[CYLINDER_GEOMETRY](radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded);\n      self.tp$name = CYLINDER_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS_TOP: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS_TOP], Sk.builtin.nmber.float$);\n        }\n        case PROP_RADIUS_BOTTOM: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS_BOTTOM], Sk.builtin.nmber.float$);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT], Sk.builtin.nmber.float$);\n        }\n        case PROP_RADIUS_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_OPEN_ENDED: {\n          return self.v[PROP_OPEN_ENDED];\n        }\n        default: {\n          // Framework will take care of the error message.\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + CYLINDER_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var cylinder = self.v;\n      var args = {};\n      args[PROP_RADIUS_TOP] = cylinder[PROP_RADIUS_TOP];\n      args[PROP_RADIUS_BOTTOM] = cylinder[PROP_RADIUS_BOTTOM];\n      args[PROP_HEIGHT] = cylinder[PROP_HEIGHT];\n      args[PROP_OPEN_ENDED] = cylinder[PROP_OPEN_ENDED];\n      // TODO: Need a Python.stringify because Boolean is {True, False} etc.\n      return new Sk.builtin.str(CYLINDER_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var cylinder = self.v;\n      var radiusTop      = cylinder[PROP_RADIUS_TOP];\n      var radiusBottom   = cylinder[PROP_RADIUS_BOTTOM];\n      var height         = cylinder[PROP_HEIGHT];\n      var radiusSegments = cylinder[PROP_RADIUS_SEGMENTS];\n      var heightSegments = cylinder[PROP_HEIGHT_SEGMENTS];\n      var openEnded      = cylinder[PROP_OPEN_ENDED];\n      var args = [radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded];\n      return new Sk.builtin.str(CYLINDER_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, CYLINDER_GEOMETRY, []);\n\n  mod[LATHE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, pointsPy, segmentsPy, phiStart, phiLength) {\n      var points = Sk.ffi.remapToJs(pointsPy);\n      var segments = Sk.ffi.remapToJs(segmentsPy);\n      phiStart = Sk.ffi.remapToJs(phiStart);\n      phiLength = Sk.ffi.remapToJs(phiLength);\n      self.v = new THREE[LATHE_GEOMETRY](points, segments, phiStart, phiLength);\n      self.tp$name = LATHE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(geometryPy, name) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(geometry[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(geometry[PROP_NAME]);\n        }\n        case PROP_VERTICES: {\n          return verticesPy(geometry.vertices);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_NAME: {\n          if (isString(value)) {\n            geometry[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + LATHE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var latheGeometry = self.v;\n      var args = {};\n      return new Sk.builtin.str(LATHE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var latheGeometry = self.v;\n      var args = [];\n      return new Sk.builtin.str(LATHE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, LATHE_GEOMETRY, []);\n\n  mod[ICOSAHEDRON_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, detail) {\n      radius = numberFromArg(radius,        PROP_RADIUS, ICOSAHEDRON_GEOMETRY);\n      detail = numberFromIntegerArg(detail, PROP_DETAIL, ICOSAHEDRON_GEOMETRY);\n      self.v = new THREE[ICOSAHEDRON_GEOMETRY](radius, detail);\n      self.tp$name = ICOSAHEDRON_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_DETAIL: {\n          return Sk.builtin.assk$(self.v[PROP_DETAIL], Sk.builtin.nmber.int$);\n        }\n        default: {\n          // Framework will take care of the error message.\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + ICOSAHEDRON_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var icosahedron = self.v;\n      var args = {};\n      args[PROP_RADIUS] = icosahedron[PROP_RADIUS];\n      args[PROP_DETAIL] = icosahedron[PROP_DETAIL];\n      return new Sk.builtin.str(ICOSAHEDRON_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var icosahedron = self.v;\n      var radius = icosahedron[PROP_RADIUS];\n      var detail = icosahedron[PROP_DETAIL];\n      var args = [radius, detail];\n      return new Sk.builtin.str(ICOSAHEDRON_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, ICOSAHEDRON_GEOMETRY, []);\n\n  mod[OCTAHEDRON_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_DETAIL = \"detail\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, detail) {\n      radius = numberFromArg(radius,        PROP_RADIUS, OCTAHEDRON_GEOMETRY);\n      detail = numberFromIntegerArg(detail, PROP_DETAIL, OCTAHEDRON_GEOMETRY);\n      self.v = new THREE[OCTAHEDRON_GEOMETRY](radius, detail);\n      self.v.radius = radius; // workaround for THREE not caching radius.\n      self.v.detail = detail; // workaround for THREE not caching detail.\n      self.tp$name = OCTAHEDRON_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_DETAIL: {\n          return Sk.builtin.assk$(self.v[PROP_DETAIL], Sk.builtin.nmber.int$);\n        }\n        default: {\n          // Framework will take care of the error message.\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + OCTAHEDRON_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var octahedron = self.v;\n      var args = {};\n      args[PROP_RADIUS] = octahedron[PROP_RADIUS];\n      args[PROP_DETAIL] = octahedron[PROP_DETAIL];\n      return new Sk.builtin.str(OCTAHEDRON_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var octahedron = self.v;\n      var radius = octahedron[PROP_RADIUS];\n      var detail = octahedron[PROP_DETAIL];\n      var args = [radius, detail];\n      return new Sk.builtin.str(OCTAHEDRON_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, OCTAHEDRON_GEOMETRY, []);\n\n   mod[PLANE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_WIDTH           = \"width\";\n    var PROP_HEIGHT          = \"height\";\n    var PROP_WIDTH_SEGMENTS  = \"widthSegments\";\n    var PROP_HEIGHT_SEGMENTS = \"heightSegments\";\n    $loc.__init__ = new Sk.builtin.func(function(self, width, height, widthSegments, heightSegments) {\n      width          = numberFromArg(width,                 PROP_WIDTH,           PLANE_GEOMETRY);\n      height         = numberFromArg(height,                PROP_HEIGHT,          PLANE_GEOMETRY);\n      widthSegments  = numberFromIntegerArg(widthSegments,  PROP_WIDTH_SEGMENTS,  PLANE_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, PLANE_GEOMETRY);\n      self.v = new THREE[PLANE_GEOMETRY](width, height, widthSegments, heightSegments);\n      self.tp$name = PLANE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_WIDTH: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_HEIGHT: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT], Sk.builtin.nmber.float$);\n        }\n        case PROP_WIDTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + PLANE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var plane = self.v;\n      var args = {};\n      args[PROP_WIDTH]  = plane[PROP_WIDTH];\n      args[PROP_HEIGHT] = plane[PROP_HEIGHT];\n      return new Sk.builtin.str(PLANE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var plane = self.v;\n      var width          = plane[PROP_WIDTH];\n      var height         = plane[PROP_HEIGHT];\n      var widthSegments  = plane[PROP_WIDTH_SEGMENTS];\n      var heightSegments = plane[PROP_HEIGHT_SEGMENTS];\n      var args = [width, height, widthSegments, heightSegments];\n      return new Sk.builtin.str(PLANE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, PLANE_GEOMETRY, []);\n\n   mod[SPHERE_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_WIDTH_SEGMENTS  = \"widthSegments\";\n    var PROP_HEIGHT_SEGMENTS = \"heightSegments\";\n    var PROP_PHI_START       = \"phiStart\";\n    var PROP_PHI_LENGTH      = \"phiLength\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {\n      radius         = numberFromArg(radius,                PROP_RADIUS,          SPHERE_GEOMETRY);\n      widthSegments  = numberFromIntegerArg(widthSegments,  PROP_WIDTH_SEGMENTS,  SPHERE_GEOMETRY);\n      heightSegments = numberFromIntegerArg(heightSegments, PROP_HEIGHT_SEGMENTS, SPHERE_GEOMETRY);\n      phiStart       = numberFromArg(phiStart,              PROP_PHI_START,       SPHERE_GEOMETRY);\n      phiLength      = numberFromArg(phiLength,             PROP_PHI_LENGTH,      SPHERE_GEOMETRY);\n      thetaStart     = numberFromArg(thetaStart,            PROP_THETA_START,     SPHERE_GEOMETRY);\n      thetaLength    = numberFromArg(thetaLength,           PROP_THETA_LENGTH,    SPHERE_GEOMETRY);\n      self.v = new THREE[SPHERE_GEOMETRY](radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);\n      self.tp$name = SPHERE_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_WIDTH_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_WIDTH_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_HEIGHT_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_HEIGHT_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_PHI_START: {\n          return Sk.builtin.assk$(self.v[PROP_PHI_START], Sk.builtin.nmber.float$);\n        }\n        case PROP_PHI_LENGTH: {\n          return Sk.builtin.assk$(self.v[PROP_PHI_LENGTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_THETA_START: {\n          return Sk.builtin.assk$(self.v[PROP_THETA_START], Sk.builtin.nmber.float$);\n        }\n        case PROP_THETA_LENGTH: {\n          return Sk.builtin.assk$(self.v[PROP_THETA_LENGTH], Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + SPHERE_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var radius = sphere[PROP_RADIUS];\n      var args = {};\n      args[PROP_RADIUS] = radius;\n      return new Sk.builtin.str(SPHERE_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var sphere = self.v;\n      var radius         = sphere[PROP_RADIUS];\n      var widthSegments  = sphere[PROP_WIDTH_SEGMENTS];\n      var heightSegments = sphere[PROP_HEIGHT_SEGMENTS];\n      var phiStart       = sphere[PROP_PHI_START];\n      var phiLength      = sphere[PROP_PHI_LENGTH];\n      var thetaStart     = sphere[PROP_THETA_START];\n      var thetaLength    = sphere[PROP_THETA_LENGTH];\n      var args = [radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength];\n      return new Sk.builtin.str(SPHERE_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, SPHERE_GEOMETRY, []);\n\n  mod[TETRAHEDRON_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_DETAIL = \"detail\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, detail) {\n      radius = numberFromArg(radius,        PROP_RADIUS, TETRAHEDRON_GEOMETRY);\n      detail = numberFromIntegerArg(detail, PROP_DETAIL, TETRAHEDRON_GEOMETRY);\n      self.v = new THREE[TETRAHEDRON_GEOMETRY](radius, detail);\n      self.v.radius = radius; // workaround for THREE not caching radius.\n      self.v.detail = detail; // workaround for THREE not caching detail.\n      self.tp$name = TETRAHEDRON_GEOMETRY;\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_DETAIL: {\n          return Sk.builtin.assk$(self.v[PROP_DETAIL], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + TETRAHEDRON_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var tetrahedron = self.v;\n      var args = {};\n      args[PROP_RADIUS] = tetrahedron[PROP_RADIUS];\n      args[PROP_DETAIL] = tetrahedron[PROP_DETAIL];\n      return new Sk.builtin.str(TETRAHEDRON_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var tetrahedron = self.v;\n      var radius = tetrahedron[PROP_RADIUS];\n      var detail = tetrahedron[PROP_DETAIL];\n      var args = [radius, detail];\n      return new Sk.builtin.str(TETRAHEDRON_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, TETRAHEDRON_GEOMETRY, []);\n\n   mod[TEXT_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, text, parameters) {\n      text = Sk.ffi.remapToJs(text);\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[TEXT_GEOMETRY](text, parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + TEXT_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var text = Sk.ffi.remapToJs(self);\n      var args = {};\n      return new Sk.builtin.str(TEXT_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var text = Sk.ffi.remapToJs(self);\n      var args = [];\n      return new Sk.builtin.str(TEXT_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, TEXT_GEOMETRY, []);\n\n   mod[TORUS_GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_TUBE             = \"tube\";\n    var PROP_RADIAL_SEGMENTS  = \"radialSegments\";\n    var PROP_TUBULAR_SEGMENTS = \"tubularSegments\";\n    var PROP_ARC              = \"arc\";\n    $loc.__init__ = new Sk.builtin.func(function(self, radius, tube, radialSegments, tubularSegments, arc) {\n      radius = numberFromArg(radius,                          PROP_RADIUS,           TORUS_GEOMETRY);\n      tube = numberFromArg(tube,                              PROP_TUBE,             TORUS_GEOMETRY);\n      radialSegments = numberFromIntegerArg(radialSegments,   PROP_RADIAL_SEGMENTS,  TORUS_GEOMETRY);\n      tubularSegments = numberFromIntegerArg(tubularSegments, PROP_TUBULAR_SEGMENTS, TORUS_GEOMETRY);\n      arc = numberFromArg(arc,                                PROP_ARC,              TORUS_GEOMETRY);\n      self.v = new THREE[TORUS_GEOMETRY](radius, tube, radialSegments, tubularSegments, arc);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        case PROP_RADIUS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIUS], Sk.builtin.nmber.float$);\n        }\n        case PROP_TUBE: {\n          return Sk.builtin.assk$(self.v[PROP_TUBE], Sk.builtin.nmber.float$);\n        }\n        case PROP_RADIAL_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_RADIAL_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_TUBULAR_SEGMENTS: {\n          return Sk.builtin.assk$(self.v[PROP_TUBULAR_SEGMENTS], Sk.builtin.nmber.int$);\n        }\n        case PROP_ARC: {\n          return Sk.builtin.assk$(self.v[PROP_ARC], Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + TORUS_GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      var torus = self.v;\n      var args = {};\n      args[PROP_RADIUS] = torus[PROP_RADIUS];\n      args[PROP_TUBE]   = torus[PROP_TUBE];\n      args[PROP_ARC]    = torus[PROP_ARC];\n      return new Sk.builtin.str(TORUS_GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var torus = self.v;\n      var radius          = torus[PROP_RADIUS];\n      var tube            = torus[PROP_TUBE];\n      var radialSegments  = torus[PROP_RADIAL_SEGMENTS];\n      var tubularSegments = torus[PROP_TUBULAR_SEGMENTS];\n      var arc             = torus[PROP_ARC];\n      var args = [radius, tube, radialSegments, tubularSegments, arc];\n      return new Sk.builtin.str(TORUS_GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, TORUS_GEOMETRY, []);\n\n   mod[GEOMETRY] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, geometryPy) {\n      if (isDefined(geometryPy)) {\n        self.v = Sk.ffi.remapToJs(geometryPy);\n        self.tp$name = geometryPy.tp$name;\n      }\n      else {\n        self.v = new THREE[GEOMETRY]();\n        self.tp$name = GEOMETRY;\n      }\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(geometryPy, name) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(geometry[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(geometry[PROP_NAME]);\n        }\n        case PROP_VERTICES: {\n          return verticesPy(geometry.vertices);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(geometryPy, name, valuePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + GEOMETRY);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(geometryPy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy);\n      if (isDefined(geometry)) {\n        var args = {};\n        return new Sk.builtin.str(GEOMETRY + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + GEOMETRY + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(geometry) {\n      geometry = Sk.ffi.remapToJs(geometry);\n      var args = [];\n      return new Sk.builtin.str(GEOMETRY + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, GEOMETRY, []);\n\n  mod[OBJECT_3D] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      self.tp$name = OBJECT_3D;\n      self.v = new THREE[OBJECT_3D]();\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(objPy, name) {\n      var obj = Sk.ffi.remapToJs(objPy);\n      switch(name) {\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(obj[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(obj[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(obj[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return obj[PROP_USE_QUATERNION];\n        }\n        case METHOD_ADD: {\n          return methodAdd(obj);\n        }\n        case METHOD_REMOVE: {\n          return methodRemove(obj);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(obj, name, value) {\n      obj = Sk.ffi.remapToJs(obj);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_POSITION: {\n          obj[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          obj[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          obj[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            obj[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          obj[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          obj[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          obj[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an settable attribute of \" + OBJECT_3D);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(obj) {\n      obj = Sk.ffi.remapToJs(obj);\n      if (isDefined(obj)) {\n        var args = {};\n        return new Sk.builtin.str(OBJECT_3D + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + OBJECT_3D + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(obj) {\n      obj = Sk.ffi.remapToJs(obj);\n      var args = [];\n      return new Sk.builtin.str(OBJECT_3D + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, OBJECT_3D, []);\n\n  mod[AMBIENT_LIGHT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, color) {\n      self.tp$name = AMBIENT_LIGHT;\n      color = Sk.ffi.remapToJs(color);\n      self.v = new THREE[AMBIENT_LIGHT](color);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(lightPy, name) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR]));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(lightPy, name, valuePy) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_COLOR: {\n          light[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an settable attribute of \" + AMBIENT_LIGHT);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      if (isDefined(light)) {\n        var args = {};\n        args[PROP_COLOR] = light[PROP_COLOR];\n        return new Sk.builtin.str(AMBIENT_LIGHT + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + AMBIENT_LIGHT + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      var args = [light[PROP_COLOR]];\n      return new Sk.builtin.str(AMBIENT_LIGHT + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, AMBIENT_LIGHT, []);\n\n  mod[DIRECTIONAL_LIGHT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_INTENSITY = \"intensity\";\n    var PROP_DISTANCE = \"distance\";\n    $loc.__init__ = new Sk.builtin.func(function(self, color, intensity, distance) {\n      self.tp$name = DIRECTIONAL_LIGHT;\n      color = Sk.ffi.remapToJs(color);\n      intensity = Sk.ffi.remapToJs(intensity);\n      distance = Sk.ffi.remapToJs(distance);\n      self.v = new THREE[DIRECTIONAL_LIGHT](color, intensity, distance);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(lightPy, name) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR]));\n        }\n        case PROP_DISTANCE: {\n          return Sk.builtin.nmber(light[PROP_DISTANCE], Sk.builtin.nmber.float$);\n        }\n        case PROP_INTENSITY: {\n          return Sk.builtin.nmber(light[PROP_INTENSITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(light[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(light[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return light[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              light.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return lightPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(light, name, value) {\n      light = Sk.ffi.remapToJs(light);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_COLOR: {\n          light[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_DISTANCE: {\n          if (isNumber(value)) {\n            light[PROP_DISTANCE] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_DISTANCE + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_INTENSITY: {\n          if (isNumber(value)) {\n            light[PROP_INTENSITY] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_INTENSITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_POSITION: {\n          light[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          light[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          light[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            light[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          light[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          light[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          light[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an settable attribute of \" + DIRECTIONAL_LIGHT);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      if (isDefined(light)) {\n        var args = {};\n        args[PROP_COLOR] = light[PROP_COLOR];\n        args[PROP_INTENSITY] = light[PROP_INTENSITY];\n        args[PROP_DISTANCE] = light[PROP_DISTANCE];\n        return new Sk.builtin.str(DIRECTIONAL_LIGHT + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + DIRECTIONAL_LIGHT + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      var args = [light[PROP_COLOR], light[PROP_INTENSITY], light[PROP_DISTANCE]];\n      return new Sk.builtin.str(DIRECTIONAL_LIGHT + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, DIRECTIONAL_LIGHT, []);\n\n  mod[POINT_LIGHT] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    var PROP_INTENSITY = \"intensity\";\n    var PROP_DISTANCE = \"distance\";\n    $loc.__init__ = new Sk.builtin.func(function(self, color, intensity, distance) {\n      self.tp$name = POINT_LIGHT;\n      color = Sk.ffi.remapToJs(color);\n      intensity = Sk.ffi.remapToJs(intensity);\n      distance = Sk.ffi.remapToJs(distance);\n      self.v = new THREE[POINT_LIGHT](color, intensity, distance);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(lightPy, name) {\n      var light = Sk.ffi.remapToJs(lightPy);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR]));\n        }\n        case PROP_DISTANCE: {\n          return Sk.builtin.nmber(light[PROP_DISTANCE], Sk.builtin.nmber.float$);\n        }\n        case PROP_INTENSITY: {\n          return Sk.builtin.nmber(light[PROP_INTENSITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(light[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(light[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(light[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return light[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              light.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return lightPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(light, name, value) {\n      light = Sk.ffi.remapToJs(light);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_COLOR: {\n          light[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_DISTANCE: {\n          if (isNumber(value)) {\n            light[PROP_DISTANCE] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_DISTANCE + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_INTENSITY: {\n          if (isNumber(value)) {\n            light[PROP_INTENSITY] = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_INTENSITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_POSITION: {\n          light[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          light[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          light[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            light[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          light[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          light[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          light[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an settable attribute of \" + POINT_LIGHT);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      if (isDefined(light)) {\n        var args = {};\n        args[PROP_COLOR] = light[PROP_COLOR];\n        args[PROP_INTENSITY] = light[PROP_INTENSITY];\n        args[PROP_DISTANCE] = light[PROP_DISTANCE];\n        return new Sk.builtin.str(POINT_LIGHT + \"(\" + JSON.stringify(args) + \")\");\n      }\n      else {\n        return new Sk.builtin.str(\"<type '\" + POINT_LIGHT + \"'>\");\n      }\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(light) {\n      light = Sk.ffi.remapToJs(light);\n      var args = [light[PROP_COLOR], light[PROP_INTENSITY], light[PROP_DISTANCE]];\n      return new Sk.builtin.str(POINT_LIGHT + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, POINT_LIGHT, []);\n\n  mod[LINE] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, geometryPy, materialPy, typePy) {\n      var geometry = Sk.ffi.remapToJs(geometryPy)\n      var material = Sk.ffi.remapToJs(materialPy)\n      var type = Sk.ffi.remapToJs(typePy)\n      self.v = new THREE[LINE](geometry, material, type);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(linePy, name) {\n      var line = Sk.ffi.remapToJs(linePy);\n      switch(name) {\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(line[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(line[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(line[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return line[PROP_USE_QUATERNION];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              line.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return linePy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case PROP_TYPE: {\n          return Sk.builtin.nmber(line[PROP_TYPE], Sk.builtin.nmber.int$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(linePy, name, value) {\n      var line = Sk.ffi.remapToJs(linePy);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_TYPE: {\n          if (isNumber(value)) {\n            line[PROP_TYPE] = value;\n          }\n          else {\n            throw new Error(PROP_TYPE + \" must be either LineStrip or LinePieces\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + LINE);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(LINE);\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      return new Sk.builtin.str(LINE);\n    });\n  }, LINE, []);\n\n  mod[LINE_BASIC_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = LINE_BASIC_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[LINE_BASIC_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(material, name) {\n      material = Sk.ffi.remapToJs(material);\n      switch(name) {\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR]));\n        }\n        case PROP_OPACITY: {\n          return Sk.builtin.nmber(material[PROP_OPACITY], Sk.builtin.nmber.float$);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(material, name, value) {\n      material = Sk.ffi.remapToJs(material);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_COLOR: {\n          if (isColor(value)) {\n            material.color = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_OPACITY + \"' attribute must be a <type '\" + COLOR + \"'>.\");\n          }\n        }\n        break;\n        case PROP_OPACITY: {\n          if (isNumber(value)) {\n            material.opacity = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_OPACITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + LINE_BASIC_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      args[PROP_COLOR] = material[PROP_COLOR];\n      args[PROP_OPACITY] = material[PROP_OPACITY];\n      return new Sk.builtin.str(LINE_BASIC_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = [{}];\n      return new Sk.builtin.str(LINE_BASIC_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, LINE_BASIC_MATERIAL, []);\n\n  mod[MESH] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, geometryPy, materialPy) {\n      self.tp$name = MESH;\n      self.v = new THREE[MESH](Sk.ffi.remapToJs(geometryPy), Sk.ffi.remapToJs(materialPy));\n      self.v[PROP_MASS] = multiVector3(0, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n      self.v[PROP_VELOCITY] = multiVector3(0, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(meshPy, name) {\n      var mesh = Sk.ffi.remapToJs(meshPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(mesh[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_GEOMETRY: {\n          var geometry = mesh[PROP_GEOMETRY];\n          return Sk.misceval.callsim(mod[GEOMETRY], Sk.ffi.referenceToPy(mesh[PROP_GEOMETRY]));\n        }\n        case PROP_MASS: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_MASS]));\n        }\n        case PROP_MATRIX_AUTO_UPDATE: {\n          return mesh[PROP_MATRIX_AUTO_UPDATE];\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(mesh[PROP_NAME]);\n        }\n        case PROP_OVERDRAW: {\n          if (isBoolean(mesh[PROP_OVERDRAW])) {\n            return mesh[PROP_OVERDRAW];\n          }\n          else {\n            return null;\n          }\n        }\n        case PROP_POSITION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_POSITION]));\n        }\n        case PROP_QUATERNION: {\n          return Sk.misceval.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(mesh[PROP_QUATERNION]));\n        }\n        case PROP_ROTATION: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_ROTATION]));\n        }\n        case PROP_EULER_ORDER: {\n          return new Sk.builtin.str(mesh[PROP_EULER_ORDER]);\n        }\n        case PROP_SCALE: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_SCALE]));\n        }\n        case PROP_UP: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_UP]));\n        }\n        case PROP_USE_QUATERNION: {\n          return mesh[PROP_USE_QUATERNION];\n        }\n        case PROP_VELOCITY: {\n          return Sk.misceval.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(mesh[PROP_VELOCITY]));\n        }\n        case PROP_VISIBLE: {\n          return mesh[PROP_VISIBLE];\n        }\n        case METHOD_LOOK_AT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_LOOK_AT;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, vectorPy) {\n              mesh.lookAt(Sk.ffi.remapToJs(vectorPy));\n              return meshPy;\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_LOOK_AT);\n            })\n          }, METHOD_LOOK_AT, []));\n        }\n        case METHOD_SET_GEOMETRY: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_SET_GEOMETRY;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self, geometryPy) {\n              var geometry = Sk.ffi.remapToJs(geometryPy);\n              mesh[METHOD_SET_GEOMETRY](geometry);\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_GEOMETRY)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_SET_GEOMETRY)\n            })\n          }, METHOD_SET_GEOMETRY, []));\n        }\n        case METHOD_UPDATE_MATRIX: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = METHOD_UPDATE_MATRIX;\n            });\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              mesh[METHOD_UPDATE_MATRIX]();\n            });\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_UPDATE_MATRIX)\n            })\n            $loc.__repr__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(METHOD_UPDATE_MATRIX)\n            })\n          }, METHOD_UPDATE_MATRIX, []));\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(mesh, name, value) {\n      mesh = Sk.ffi.remapToJs(mesh);\n      value = Sk.ffi.remapToJs(value);\n      switch(name) {\n        case PROP_MASS: {\n          if (isNumber(value)) {\n            mesh[PROP_MASS] = multiVector3(value, new THREE.Vector3(0, 0, 0), 0, 0, 0, 0);\n          }\n          else {\n            mesh[PROP_MASS] = value;\n          }\n        }\n        break;\n        case PROP_MATRIX_AUTO_UPDATE: {\n          if (isBoolean(value)) {\n            mesh[PROP_MATRIX_AUTO_UPDATE] = value;\n          }\n          else {\n            throw new Error(PROP_MATRIX_AUTO_UPDATE + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_NAME: {\n          if (isString(value)) {\n            mesh[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_OVERDRAW: {\n          if (isBoolean(value)) {\n            mesh[PROP_OVERDRAW] = value;\n          }\n          else if (isNull(value)) {\n            mesh[PROP_OVERDRAW] = null;\n          }\n          else {\n            throw new Error(name + \" must be either Boolean or None\");\n          }\n        }\n        break;\n        case PROP_POSITION: {\n          mesh[PROP_POSITION] = value;\n        }\n        break;\n        case PROP_QUATERNION: {\n          mesh[PROP_QUATERNION] = value;\n        }\n        break;\n        case PROP_ROTATION: {\n          mesh[PROP_ROTATION] = value;\n        }\n        break;\n        case PROP_EULER_ORDER: {\n          if (isString(value)) {\n            mesh[PROP_EULER_ORDER] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_SCALE: {\n          mesh[PROP_SCALE] = value;\n        }\n        break;\n        case PROP_UP: {\n          mesh[PROP_UP] = value;\n        }\n        break;\n        case PROP_USE_QUATERNION: {\n          mesh[PROP_USE_QUATERNION] = value;\n        }\n        break;\n        case PROP_VELOCITY: {\n          mesh[PROP_VELOCITY] = value;\n        }\n        break;\n        case PROP_VISIBLE: {\n          if (isBoolean(value)) {\n            mesh[PROP_VISIBLE] = value;\n          }\n          else {\n            throw new Error(PROP_VISIBLE + \" must be Boolean\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(mesh) {\n      mesh = Sk.ffi.remapToJs(mesh);\n      var args = {};\n      args[PROP_ID] = mesh[PROP_ID];\n      args[PROP_NAME] = mesh[PROP_NAME];\n      return new Sk.builtin.str(MESH + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(mesh) {\n      mesh = Sk.ffi.remapToJs(mesh);\n      var args = [/*mesh[PROP_GEOMETRY], mesh[PROP_MATERIAL]*/];\n      return new Sk.builtin.str(MESH + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH, []);\n\n  mod[MESH_BASIC_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_BASIC_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_BASIC_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(materialPy, name) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(material[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(material[PROP_NAME]);\n        }\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR]));\n        }\n        case PROP_NEEDS_UPDATE: {\n          return material[PROP_NEEDS_UPDATE];\n        }\n        case PROP_OPACITY: {\n          return Sk.builtin.nmber(material[PROP_OPACITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_OVERDRAW: {\n          return material[PROP_OVERDRAW];\n        }\n        case PROP_TRANSPARENT: {\n          return material[PROP_TRANSPARENT];\n        }\n        case PROP_WIREFRAME: {\n          return material[PROP_WIREFRAME];\n        }\n        case PROP_WIREFRAME_LINEWIDTH: {\n          return Sk.builtin.nmber(material[PROP_WIREFRAME_LINEWIDTH], Sk.builtin.nmber.float$);\n        }\n        case PROP_VISIBLE: {\n          return material[PROP_VISIBLE];\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(materialPy, name, valuePy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_COLOR: {\n          material[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_NAME: {\n          if (isString(value)) {\n            material[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_NEEDS_UPDATE: {\n          if (isBoolean(value)) {\n            material[PROP_NEEDS_UPDATE] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_OPACITY: {\n          if (isNumber(value)) {\n            material.opacity = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_OPACITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_OVERDRAW: {\n          if (isBoolean(value)) {\n            material[PROP_OVERDRAW] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_TRANSPARENT: {\n          if (isBoolean(value)) {\n            material[PROP_TRANSPARENT] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_WIREFRAME: {\n          if (isBoolean(value)) {\n            material[PROP_WIREFRAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_WIREFRAME_LINEWIDTH: {\n          if (isNumber(value)) {\n            material[PROP_WIREFRAME_LINEWIDTH] = value;\n          }\n          else {\n            throw new Error(name + \" must be a number\");\n          }\n        }\n        break;\n        case PROP_VISIBLE: {\n          if (isBoolean(value)) {\n            material[PROP_VISIBLE] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_BASIC_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(materialPy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var args = {};\n      args[PROP_COLOR] = material[PROP_COLOR];\n      args[PROP_WIREFRAME] = material[PROP_WIREFRAME];\n      args[PROP_WIREFRAME_LINEWIDTH] = material[PROP_WIREFRAME_LINEWIDTH];\n      return new Sk.builtin.str(MESH_BASIC_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var parameters = {};\n      parameters[PROP_COLOR] = material[PROP_COLOR];\n      parameters[PROP_WIREFRAME] = material[PROP_WIREFRAME];\n      parameters[PROP_WIREFRAME_LINEWIDTH] = material[PROP_WIREFRAME_LINEWIDTH];\n      var args = [parameters];\n      return new Sk.builtin.str(MESH_BASIC_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH_BASIC_MATERIAL, []);\n\n  mod[MESH_LAMBERT_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_LAMBERT_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_LAMBERT_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(materialPy, name) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      switch(name) {\n        case PROP_ID: {\n          return Sk.builtin.nmber(material[PROP_ID], Sk.builtin.nmber.int$);\n        }\n        case PROP_COLOR: {\n          return Sk.misceval.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR]));\n        }\n        case PROP_NAME: {\n          return new Sk.builtin.str(material[PROP_NAME]);\n        }\n        case PROP_NEEDS_UPDATE: {\n          return material[PROP_NEEDS_UPDATE];\n        }\n        case PROP_OPACITY: {\n          return Sk.builtin.nmber(material[PROP_OPACITY], Sk.builtin.nmber.float$);\n        }\n        case PROP_OVERDRAW: {\n          return material[PROP_OVERDRAW];\n        }\n        case PROP_TRANSPARENT: {\n          return material[PROP_TRANSPARENT];\n        }\n        case PROP_VISIBLE: {\n          return material[PROP_VISIBLE];\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(materialPy, name, valuePy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        case PROP_COLOR: {\n          material[PROP_COLOR] = new THREE.Color(value);\n        }\n        break;\n        case PROP_NAME: {\n          if (isString(value)) {\n            material[PROP_NAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be a string\");\n          }\n        }\n        break;\n        case PROP_NEEDS_UPDATE: {\n          if (isBoolean(value)) {\n            material[PROP_NEEDS_UPDATE] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_OPACITY: {\n          if (isNumber(value)) {\n            material.opacity = value;\n          }\n          else {\n            throw new Sk.builtin.TypeError(\"'\" + PROP_OPACITY + \"' attribute must be a <type 'float'>.\");\n          }\n        }\n        break;\n        case PROP_OVERDRAW: {\n          if (isBoolean(value)) {\n            material[PROP_OVERDRAW] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_TRANSPARENT: {\n          if (isBoolean(value)) {\n            material[PROP_TRANSPARENT] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_WIREFRAME: {\n          if (isBoolean(value)) {\n            material[PROP_WIREFRAME] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        case PROP_WIREFRAME_LINEWIDTH: {\n          if (isNumber(value)) {\n            material[PROP_WIREFRAME_LINEWIDTH] = value;\n          }\n          else {\n            throw new Error(name + \" must be a number\");\n          }\n        }\n        break;\n        case PROP_VISIBLE: {\n          if (isBoolean(value)) {\n            material[PROP_VISIBLE] = value;\n          }\n          else {\n            throw new Error(name + \" must be Boolean\");\n          }\n        }\n        break;\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_LAMBERT_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      return new Sk.builtin.str(MESH_LAMBERT_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var parameters = {};\n      parameters[PROP_COLOR] = material[PROP_COLOR];\n      var args = [parameters];\n      return new Sk.builtin.str(MESH_LAMBERT_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH_LAMBERT_MATERIAL, []);\n\n  mod[MESH_NORMAL_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_NORMAL_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_NORMAL_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_NORMAL_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      return new Sk.builtin.str(MESH_NORMAL_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = [{}];\n      return new Sk.builtin.str(MESH_NORMAL_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH_NORMAL_MATERIAL, []);\n\n  mod[MESH_PHONG_MATERIAL] = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, parameters) {\n      self.tp$name = MESH_PHONG_MATERIAL;\n      parameters = Sk.ffi.remapToJs(parameters);\n      self.v = new THREE[MESH_PHONG_MATERIAL](parameters);\n    });\n    $loc.__getattr__ = new Sk.builtin.func(function(self, name) {\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_PHONG_MATERIAL);\n        }\n      }\n    });\n    $loc.__setattr__ = new Sk.builtin.func(function(materialPy, name, valuePy) {\n      var material = Sk.ffi.remapToJs(materialPy);\n      var value = Sk.ffi.remapToJs(valuePy);\n      switch(name) {\n        default: {\n          throw new Error(name + \" is not an attribute of \" + MESH_PHONG_MATERIAL);\n        }\n      }\n    });\n    $loc.__str__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = {};\n      return new Sk.builtin.str(MESH_PHONG_MATERIAL + \"(\" + JSON.stringify(args) + \")\");\n    });\n    $loc.__repr__ = new Sk.builtin.func(function(material) {\n      material = Sk.ffi.remapToJs(material);\n      var args = [{}];\n      return new Sk.builtin.str(MESH_PHONG_MATERIAL + \"(\" + args.map(function(x) {return JSON.stringify(x);}).join(\", \") + \")\");\n    });\n  }, MESH_PHONG_MATERIAL, []);\n\n  if (typeof THREE !== 'undefined') {\n    mod.LineStrip  = Sk.builtin.assk$(THREE.LineStrip,  Sk.builtin.nmber.int$);\n    mod.LinePieces = Sk.builtin.assk$(THREE.LinePieces, Sk.builtin.nmber.int$);\n\n    mod.FlatShading   = Sk.builtin.assk$(THREE.FlatShading,   Sk.builtin.nmber.int$);\n    mod.NoShading     = Sk.builtin.assk$(THREE.NoShading,     Sk.builtin.nmber.int$);\n    mod.SmoothShading = Sk.builtin.assk$(THREE.SmoothShading, Sk.builtin.nmber.int$);\n  }\n\n  mod[SCALAR_3] = new Sk.builtin.func(function(w) {\n    w = Sk.ffi.remapToJs(w);\n    return remapE3ToPy(w, 0, 0, 0, 0, 0, 0, 0);\n  });\n\n  mod[VECTOR_3] = new Sk.builtin.func(function(x, y, z) {\n    x = Sk.ffi.remapToJs(x);\n    y = Sk.ffi.remapToJs(y);\n    z = Sk.ffi.remapToJs(z);\n    return remapE3ToPy(0, x, y, z, 0, 0, 0, 0);\n  });\n\n  mod[BIVECTOR_3] = new Sk.builtin.func(function(xy, yz, zx) {\n    xy = Sk.ffi.remapToJs(xy);\n    yz = Sk.ffi.remapToJs(yz);\n    zx = Sk.ffi.remapToJs(zx);\n    return remapE3ToPy(0, 0, 0, 0, xy, yz, zx, 0);\n  });\n\n  mod[PSEUDOSCALAR_3] = new Sk.builtin.func(function(xyz) {\n    xyz = Sk.ffi.remapToJs(xyz);\n    return remapE3ToPy(0, 0, 0, 0, 0, 0, 0, xyz);\n  });\n\n  return mod;\n}\n"}}